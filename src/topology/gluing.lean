/-
Copyright (c) 2021 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import topology.category.Top
import category_theory.glue_data

/-!
# Gluing Topological spaces

Given a family of gluing data, consisting of
1. An index type `Œπ`
2. A topological space `U i` for each `i : Œπ`.
3. An open immersion `f i j : V i j ‚Ü™ U i` for each `i j : Œπ`.
4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.
such that
6. `f i i : V i i ‚Ü™ U i` is iso.
7. Each `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i` via some
   `t' i j k : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.
8. The cocycle condition `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô`.

We can then glue the topological spaces `U i` along `V i j`.

The construction should be "sealed" and considered as a black box, while only using the API
provided.

## Main definitions

* `Top.gluing_data`: A structure containing the family of gluing data.
* `Top.gluing_data.glued`: The glued topological space.
    This is defined as the coequalizer of `‚àê V i j ‚áâ ‚àê U i`, so that the general colimit API can
    be used.
* `Top.gluing_data.imm`: The immersion `imm i : U i ‚ü∂ glued` for each `i : Œπ`.
* `Top.gluing_data.rel`: A relation on `Œ£ i, D.U i` defined by `‚ü®i, x‚ü© ~ ‚ü®j, y‚ü©` iff
    `‚ü®i, x‚ü© = ‚ü®j, y‚ü©` or `t i j x = y`. See `Top.gluing_data.imm_eq_iff_rel`.

## Main results

* `Top.gluing_data.is_open_iff`: A set in `glued` is open iff its preimage along each `imm i` is
    open.
* `Top.gluing_data.imm_jointly_surjective`: The `imm i`s are jointly surjective.
* `Top.gluing_data.glue_condition` : `f i j ‚â´ imm j = imm i`.
* `Top.gluing_data.rel_equiv`: `rel` is an equivalence relation.
* `Top.gluing_data.imm_eq_iff_rel`: `imm i x = imm j y ‚Üî ‚ü®i, x‚ü© ~ ‚ü®j, y‚ü©`.
* `Top.gluing_data.image_inter`: The intersection of the images of `U i` and `U j` in `glued` is
    `V i j`.
* `Top.gluing_data.preimage_range`: The preimage of the image of `U i` in `U j` is `V i j`.
* `Top.gluing_data.preimage_image_eq_preimage_f`: The preimage of the image of some `U ‚äÜ U i` is
    given by the preimage along `f j i`.
* `Top.gluing_data.imm_open_embedding`: Each of the `imm i`s are open embeddings.

-/

noncomputable theory

open topological_space category_theory

universes v u
open category_theory.limits
namespace Top

/--
A family of gluing data consists of
1. An index type `Œπ`
2. A topological space `U i` for each `i : Œπ`.
3. An open immersion `f i j : V i j ‚Ü™ U i` for each `i j : Œπ`.
4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.
such that
6. `f i i : V i i ‚Ü™ U i` is iso.
7. Each `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i` via some
   `t' i j k : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.
8. The cocycle condition `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô`.

We can then glue the topological spaces `U i` along `V i j`.
-/
@[nolint has_inhabited_instance]
structure glue_data extends glue_data Top :=
  (f_open : ‚àÄ i j, open_embedding (f i j))
  (f_mono := Œª i j, (Top.mono_iff_injective _).mpr (f_open i j).to_embedding.inj)

-- attribute [simp] glue_data.t_id
-- attribute [instance] glue_data.f_id
open category_theory.glue_data

namespace glue_data

variable (D : glue_data.{u})

local notation `D'` := D.to_glue_data

lemma œÄ_surjective : function.surjective D' .œÄ :=
(Top.epi_iff_surjective D' .œÄ).mp infer_instance

/-- The open immersion `D.U i ‚ü∂ D.glued` for each `i`. -/
def imm (i : D.Œπ) : D.U i ‚ü∂ D' .glued :=
multicoequalizer.œÄ D' .diagram i

lemma is_open_iff (U : set D' .glued) : is_open U ‚Üî ‚àÄ i, is_open (D.imm i ‚Åª¬π' U) :=
begin
  delta imm,
  simp_rw ‚Üê multicoequalizer.Œπ_sigma_œÄ D' .diagram,
  rw ‚Üê (homeo_of_iso (multicoequalizer.iso_coequalizer D' .diagram).symm).is_open_preimage,
  rw [coequalizer_is_open_iff, colimit_is_open_iff],
  refl
end

lemma imm_jointly_surjective (x : D' .glued) : ‚àÉ i (y : D.U i), D.imm i y = x :=
begin
  delta imm,
  simp_rw ‚Üê multicoequalizer.Œπ_sigma_œÄ D' .diagram,
  rcases D.œÄ_surjective x with ‚ü®x', rfl‚ü©,
  rw ‚Üê (show (sigma_iso_sigma _).inv _ = x',
    from concrete_category.congr_hom ((sigma_iso_sigma _).hom_inv_id) x'),
  rcases (sigma_iso_sigma _).hom x' with ‚ü®i, y‚ü©,
  exact ‚ü®i, y, by { simpa [‚Üê multicoequalizer.Œπ_sigma_œÄ, -multicoequalizer.Œπ_sigma_œÄ] }‚ü©
end

@[simp, elementwise]
lemma glue_condition (i j : D.Œπ) :
  D.t i j ‚â´ D.f j i ‚â´ D.imm j = D.f i j ‚â´ D.imm i :=
(multicoequalizer.condition D' .diagram ‚ü®i, j‚ü©).symm

/--
 An equivalence relation on `Œ£ i, D.U i` that holds iff `D.imm i x = D.imm j y`.
 See `Top.gluing_data.imm_eq_iff_rel`.
 -/
def rel (a b : Œ£ i, ((D.U i : Top) : Type*)) : Prop :=
  a = b ‚à® ‚àÉ (x : D.V (a.1, b.1)) , D.f _ _ x = a.2 ‚àß D.f _ _ (D.t _ _ x) = b.2

lemma rel_equiv : equivalence D.rel :=
‚ü® Œª x, or.inl (refl x),
  Œª a b h,
  begin
    rcases h with (‚ü®‚ü®‚ü©‚ü©|‚ü®x,e‚ÇÅ,e‚ÇÇ‚ü©), exact or.inl rfl,
    right,
    use (D.t _ _ x), simp[e‚ÇÅ, e‚ÇÇ]
  end,
  begin
    rintros ‚ü®i,a‚ü© ‚ü®j,b‚ü© ‚ü®k,c‚ü© (‚ü®‚ü®‚ü©‚ü©|‚ü®x,e‚ÇÅ,e‚ÇÇ‚ü©), exact id,
    rintro (‚ü®‚ü®‚ü©‚ü©|‚ü®y,e‚ÇÉ,e‚ÇÑ‚ü©), exact or.inr ‚ü®x,e‚ÇÅ,e‚ÇÇ‚ü©,
    let z := (pullback_iso_prod_subtype (D.f j i) (D.f j k)).inv ‚ü®‚ü®_,_‚ü©, e‚ÇÇ.trans e‚ÇÉ.symm‚ü©,
    have eq‚ÇÅ : (D.t j i) ((pullback.fst : _ ‚ü∂ D.V _) z) = x := by simp,
    have eq‚ÇÇ : (pullback.snd : _ ‚ü∂ D.V _) z = _ := pullback_iso_prod_subtype_inv_snd_apply _ _ _,
    clear_value z,
    right,
    use (pullback.fst : _ ‚ü∂ D.V (i, k)) (D.t' _ _ _ z),
    dsimp only at *,
    cases e‚ÇÅ, cases e‚ÇÉ, cases e‚ÇÑ, cases eq‚ÇÅ, cases eq‚ÇÇ, simp,
    have h‚ÇÅ : D.t' j i k ‚â´ pullback.fst ‚â´ D.f i k = pullback.fst ‚â´ D.t j i ‚â´ D.f i j,
    { rw ‚ÜêD' .t_fac_assoc, congr' 1, exact pullback.condition },
    have h‚ÇÇ : D.t' j i k ‚â´ pullback.fst ‚â´ D.t i k ‚â´ D.f k i =
      pullback.snd ‚â´ D.t j k ‚â´ D.f k j,
    { rw ‚ÜêD' .t_fac_assoc,
      apply @epi.left_cancellation _ _ _ _ (D.t' k j i),
      rw [D' .cocycle_assoc, D' .t_fac_assoc, D' .t_inv_assoc],
      exact pullback.condition.symm },
    exact ‚ü®continuous_map.congr_fun h‚ÇÅ z, continuous_map.congr_fun h‚ÇÇ z‚ü©
  end‚ü©

open category_theory.limits.walking_parallel_pair

lemma eqv_gen_of_œÄ_eq {x y : ‚àê D.U} (h : D' .œÄ x = D' .œÄ y) :
  eqv_gen (types.coequalizer_rel D' .diagram.fst_sigma_map D' .diagram.snd_sigma_map) x y :=
begin
  delta œÄ multicoequalizer.sigma_œÄ at h,
  simp_rw comp_app at h,
  replace h := (Top.mono_iff_injective (multicoequalizer.iso_coequalizer D' .diagram).inv).mp _ h,
  let diagram := parallel_pair D' .diagram.fst_sigma_map D' .diagram.snd_sigma_map ‚ãô forget _,
  have : colimit.Œπ diagram one x = colimit.Œπ diagram one y,
  { rw ‚ÜêŒπ_preserves_colimits_iso_hom,
    simp [h] },
  have :
    (colimit.Œπ diagram _ ‚â´ colim.map _ ‚â´ (colimit.iso_colimit_cocone _).hom) _ =
    (colimit.Œπ diagram _ ‚â´ colim.map _ ‚â´ (colimit.iso_colimit_cocone _).hom) _ :=
    (congr_arg (colim.map (diagram_iso_parallel_pair diagram).hom
    ‚â´ (colimit.iso_colimit_cocone (types.coequalizer_colimit _ _)).hom) this : _),
  simp only [eq_to_hom_refl, types_comp_apply, colimit.Œπ_map_assoc,
    diagram_iso_parallel_pair_hom_app, colimit.iso_colimit_cocone_Œπ_hom, types_id_apply] at this,
  exact quot.eq.1 this,
  apply_instance
end

lemma inv_image.equivalence {Œ± : Sort u} {Œ≤ : Sort v} (r : Œ≤ ‚Üí Œ≤ ‚Üí Prop) (f : Œ± ‚Üí Œ≤)
  (h : equivalence r) : equivalence (inv_image r f) :=
‚ü®Œª _, h.1 _, Œª _ _ x, h.2.1 x, inv_image.trans r f h.2.2‚ü©

lemma imm_eq_iff_rel (i j : D.Œπ) (x : D.U i) (y : D.U j) :
  D.imm i x = D.imm j y ‚Üî D.rel ‚ü®i, x‚ü© ‚ü®j, y‚ü© :=
begin
  split,
  { delta imm,
    simp_rw ‚Üê multicoequalizer.Œπ_sigma_œÄ,
    intro h,
    rw ‚Üê (show _ = sigma.mk i x,
      from concrete_category.congr_hom (sigma_iso_sigma D.U).inv_hom_id _),
    rw ‚Üê (show _ = sigma.mk j y,
      from concrete_category.congr_hom (sigma_iso_sigma D.U).inv_hom_id _),
    change inv_image D.rel (sigma_iso_sigma D.U).hom _ _,
    simp only [Top.sigma_iso_sigma_inv_apply],
    rw ‚Üê (inv_image.equivalence _ _ D.rel_equiv).eqv_gen_iff,
    refine eqv_gen.mono _ (D.eqv_gen_of_œÄ_eq h : _),
    rintros _ _ ‚ü®x‚ü©,
    rw ‚Üê (show (sigma_iso_sigma _).inv _ = x,
      from concrete_category.congr_hom (sigma_iso_sigma _).hom_inv_id x),
    generalize : (sigma_iso_sigma D.V).hom x = x',
    rcases x' with ‚ü®‚ü®i,j‚ü©,y‚ü©,
    unfold inv_image multispan_index.fst_sigma_map multispan_index.snd_sigma_map,
    simp only [opens.inclusion_to_fun, Top.comp_app, sigma_iso_sigma_inv_apply,
      category_theory.limits.colimit.Œπ_desc_apply, cofan.mk_Œπ_app,
      sigma_iso_sigma_hom_Œπ_apply, continuous_map.to_fun_eq_coe],
    erw [sigma_iso_sigma_hom_Œπ_apply, sigma_iso_sigma_hom_Œπ_apply],
    exact or.inr ‚ü®y, by { dsimp [diagram], simp }‚ü© },
  { rintro (‚ü®‚ü®‚ü©‚ü© | ‚ü®z, e‚ÇÅ, e‚ÇÇ‚ü©),
    refl, dsimp only at *, subst e‚ÇÅ, subst e‚ÇÇ, simp }
end

lemma imm_injective (i : D.Œπ) : function.injective (D.imm i) :=
begin
  intros x y h,
  rcases (D.imm_eq_iff_rel _ _ _ _).mp h with (‚ü®‚ü®‚ü©‚ü©| ‚ü®_,e‚ÇÅ,e‚ÇÇ‚ü©),
  refl,
  dsimp only at *,
  cases e‚ÇÅ, cases e‚ÇÇ, simp
end

instance imm_mono (i : D.Œπ) : mono (D.imm i) :=
(Top.mono_iff_injective _).mpr (D.imm_injective _)

local attribute [elementwise] is_iso.hom_inv_id is_iso.inv_hom_id

lemma image_inter (i j : D.Œπ) :
  set.range (D.imm i) ‚à© set.range (D.imm j) = set.range (D.f i j ‚â´ D.imm _) :=
begin
  ext x,
  split,
  { rintro ‚ü®‚ü®x‚ÇÅ, eq‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, eq‚ÇÇ‚ü©‚ü©,
    have := (D.imm_eq_iff_rel _ _ _ _).mp (eq‚ÇÅ.trans eq‚ÇÇ.symm),
    rcases this with (‚ü®‚ü®‚ü©‚ü©|‚ü®y,e‚ÇÅ,e‚ÇÇ‚ü©),
    exact ‚ü®inv (D.f i i) x‚ÇÅ, by simp[eq‚ÇÅ]‚ü©,
    dsimp only at *,
    cases e‚ÇÅ, cases eq‚ÇÅ,
    exact ‚ü®y, by simp‚ü© },
  { rintro ‚ü®x, hx‚ü©,
    exact ‚ü®‚ü®D.f i j x, hx‚ü©, ‚ü®D.f j i (D.t _ _ x), by simp[‚Üêhx]‚ü©‚ü© }
end

lemma preimage_range (i j : D.Œπ) :
  D.imm j ‚Åª¬π' (set.range (D.imm i)) = set.range (D.f j i) :=
by rw [ ‚Üêset.preimage_image_eq (set.range (D.f j i)) (D.imm_injective j), ‚Üêset.image_univ,
        ‚Üêset.image_univ, ‚Üêset.image_comp, ‚Üêcoe_comp, set.image_univ,set.image_univ,
        ‚Üêimage_inter, set.preimage_range_inter]

lemma preimage_image_eq_image (i j : D.Œπ) (U : set (D' .U i)) :
D.imm j ‚Åª¬π' (D.imm i '' U) = D.f _ _ '' ((D.t j i ‚â´ D.f _ _) ‚Åª¬π' U) :=
begin
  have : D.f _ _ ‚Åª¬π' (D.imm j ‚Åª¬π' (D.imm i '' U)) = (D.t j i ‚â´ D.f _ _) ‚Åª¬π' U,
  { ext x,
    conv_rhs { rw ‚Üê set.preimage_image_eq U (D.imm_injective _) },
    generalize : D.imm i '' U = U',
    simp },
  rw [‚Üêthis, set.image_preimage_eq_inter_range],
  symmetry,
  apply set.inter_eq_self_of_subset_left,
  rw ‚Üê D.preimage_range i j,
  exact set.preimage_mono (set.image_subset_range _ _),
end

lemma preimage_image_eq_image' (i j : D.Œπ) (U : set (D' .U i)) :
D.imm j ‚Åª¬π' (D.imm i '' U) = (D.t i j ‚â´ D.f _ _) '' ((D.f _ _) ‚Åª¬π' U) :=
begin
  convert D.preimage_image_eq_image i j U using 1,
  rw [coe_comp, coe_comp, ‚Üê set.image_image],
  congr' 1,
  rw ‚Üê set.eq_preimage_iff_image_eq,
  rw set.preimage_preimage,
  change _ = (D.t i j ‚â´ D.t j i ‚â´ _) ‚Åª¬π' _,
  rw D' .t_inv_assoc,
  rw ‚Üê is_iso_iff_bijective,
  apply (forget Top).map_is_iso
end

lemma open_image_open (i : D.Œπ) (U : opens (D' .U i)) : is_open (D.imm i '' U) :=
begin
  rw is_open_iff,
  intro j,
  rw preimage_image_eq_image,
  apply (D.f_open _ _).is_open_map,
  apply (D.t j i ‚â´ D.f i j).continuous_to_fun.is_open_preimage,
  exact U.property
end

lemma imm_open_embedding (i : D.Œπ) : open_embedding (D.imm i) :=
open_embedding_of_continuous_injective_open
  (D.imm i).continuous_to_fun (D.imm_injective i) (Œª U h, D.open_image_open i ‚ü®U, h‚ü©)

end glue_data

end Top
