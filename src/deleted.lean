-- #exit
-- lemma property_next_height_iterated_aux (P : A) (n : ℕ) :
--   f.to_fun ((next f.m)^[n.succ] P) ≤
--   2^n.succ * ((f.m^2)⁻¹)^n.succ * f.to_fun P +
--   (f.m^2)⁻¹ * (∑ i in finset.range n.succ,2^(i+1)) * (C1' f + f.C2) :=
-- have ineq1 : _ := property_next_height f P,
-- begin
--   induction n with n ih,

--   { rw [pow_one, function.iterate_one, pow_one, finset.range_one,
--       finset.sum_singleton, zero_add, pow_one],
--     apply le_trans ineq1, rw [add_assoc, mul_add], apply add_le_add,
--     rw ←mul_assoc, apply mul_le_mul, rw mul_comm, refl,
--     exact f.nonneg _, apply mul_nonneg, norm_num, rw inv_nonneg,
--     norm_cast, apply pow_nonneg, linarith [f.hm], apply mul_le_mul,
--     rw le_mul_iff_one_le_right, norm_num,
--     rw inv_pos, norm_cast, apply pow_pos, linarith [f.hm], refl,
--     apply add_nonneg, exact C1'_nonneg f, linarith [f.C2_pos],
--     apply mul_nonneg, rw inv_nonneg, norm_cast, apply pow_nonneg, linarith [f.hm], norm_num, },

--   { have ineq2 := property_next_height f ((next f.m)^[n.succ] P),
--     rw [function.iterate_succ'],
--     apply le_trans ineq2,
--     have ineq3 := mul_le_mul (show (2 : ℝ) ≤ 2, by refl) ih (f.nonneg _) (by norm_num),
--     rw [mul_add, ←mul_assoc, ←mul_assoc, show (2 : ℝ) * 2^n.succ = 2^n.succ.succ,
--       by conv_rhs { rw pow_succ }, ←mul_assoc, ←mul_assoc,
--       mul_comm (2 : ℝ) ((f.m) ^ 2)⁻¹, mul_assoc (↑(f.m) ^ 2)⁻¹, finset.mul_sum] at ineq3,
--     have ineq4 := add_le_add ineq3 (show C1' f + f.C2 ≤ C1' f + f.C2, by refl),
--     rw [←add_assoc, add_assoc _ _ (C1' f + f.C2),
--       show ∀ x, x * (C1' f + f.C2) + (C1' f + f.C2) = (x + 1) * (C1' f + f.C2), begin
--         intros x, rw [add_mul x 1, one_mul],
--       end] at ineq4,
--     have ineq5 := mul_le_mul (show ((f.m : ℝ) ^ 2)⁻¹ ≤ ((f.m) ^ 2)⁻¹, by refl) ineq4 begin
--       apply add_nonneg, apply add_nonneg, apply mul_nonneg, norm_num, apply f.nonneg,
--       apply C1'_nonneg, linarith [f.C2_pos],
--     end begin
--       rw inv_nonneg, norm_cast, apply pow_nonneg, linarith [f.hm],
--     end,
--     apply le_trans ineq5,
--     rw [mul_add, show ∀ (a b c : ℝ) (k : ℕ), a * (b * a ^ k * c) = a^k.succ * b * c, begin
--       intros a b c k, rw [←mul_assoc, ←mul_assoc, mul_comm a b, mul_assoc b a (a^k),
--         show a * a^k = a ^ k.succ, by rw pow_succ, mul_comm b _],
--     end],
--     apply add_le_add, ring_nf,
--     have eq1 : ∑ i in range n.succ, (2 : ℝ) * 2 ^ (i + 1) = ∑ i in range n.succ, 2 ^ ((i + 1) + 1),
--     { apply finset.sum_congr, refl, intros, ring_nf, },
--     have eq2 : ∑ i in range n.succ, (2 : ℝ) ^ ((i+1)+1) = ∑ i in range n.succ.succ\{0}, 2^(i+1),
--     { apply finset.sum_bij (λ i h, i + 1),
--       intros a ha, simp only [and_true, mem_sdiff, mem_range, nat.succ_ne_zero,
--         not_false_iff, mem_singleton] at ha ⊢,
--       apply nat.succ_lt_succ, exact ha,

--       intros a ha, refl,

--       intros a b ha hb heq,
--       exact nat.succ_injective heq,

--       intros b hb, simp only [mem_sdiff, mem_range, mem_singleton] at hb, use b.pred,
--       have : b.pred ∈ range n.succ,
--       { simp only [mem_range],
--         rw [nat.lt_succ_iff, nat.pred_le_iff, ←nat.lt_succ_iff], exact hb.1, },
--       use this, dsimp only,
--       rw [←nat.succ_eq_add_one, nat.succ_pred_eq_of_pos (nat.pos_of_ne_zero hb.2)], },
--     rw [eq1, eq2, mul_assoc],

--     have seteq1 : range n.succ.succ = (range n.succ.succ \ {0}) ∪ {0},
--     { ext, split; intro ha,
--       { rw [mem_union, mem_singleton, mem_sdiff, mem_singleton], by_cases h : a = 0, right, exact h,
--         left, refine ⟨ha, h⟩, },
--       { rw [mem_union, mem_singleton, mem_sdiff, mem_singleton] at ha, cases ha, exact ha.1,
--         rw [mem_range, ha], exact nat.zero_lt_succ _, } },
--     conv_rhs { rw [seteq1] },
--     rw [finset.sum_union, finset.sum_singleton, zero_add, pow_one,
--       add_mul, one_mul, mul_add, add_mul],
--     conv_rhs { rw [mul_add] },
--     apply add_le_add, rw [mul_assoc, mul_le_iff_le_one_left],
--     apply inv_le_one, norm_cast, rw [←nat.lt_iff_add_one_le], apply pow_pos, linarith [f.hm],

--     apply mul_pos, rw inv_pos, norm_cast, apply pow_pos, linarith [f.hm],
--     apply mul_pos, apply finset.sum_pos, intros i hi, apply pow_pos, exact zero_lt_two,
--     use 1, simp only [mem_sdiff, mem_range, mem_singleton], split,
--     exact nat.one_lt_succ_succ n, exact nat.one_ne_zero, norm_cast, apply add_pos,
--     exact C1'_pos _, exact f.C2_pos,
--     rw [mul_comm (2 : ℝ), ←mul_assoc, mul_two, le_add_iff_nonneg_right],

--     apply mul_nonneg, rw inv_nonneg, norm_cast, apply pow_nonneg, linarith [f.hm],
--     apply add_nonneg, exact C1'_nonneg f, linarith [f.C2_pos],

--     rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem], intros x hx,
--     simp only [sdiff_inter_self, not_mem_empty] at hx, exact hx, }
-- end

-- lemma property_next_height_iterated (P : A) (n : ℕ) :
--   f.to_fun ((next f.m)^[n.succ] P) ≤ (2^(n.succ))⁻¹ * f.to_fun P + 2⁻¹ * (C1' f + f.C2) :=
-- have ineq1 : _ := property_next_height_iterated_aux f P n,
-- have ineq2 : 2 ^ n.succ * ((f.m : ℝ) ^ 2)⁻¹ ^ n.succ ≤ (2 ^ n.succ)⁻¹, from sorry,
-- have eq1 : ∑ (i : ℕ) in range n.succ, (2 : ℝ) ^ (i + 1) = 2 * ∑ (i : ℕ) in range n.succ, 2^i,
-- begin
--   rw finset.mul_sum, apply finset.sum_congr rfl, intros i hi, rw pow_succ,
-- end,
-- -- have ineq3 : ∑ (i : ℕ) in range n.succ, (2 : ℝ) ^ (i + 1) ≤ 1,
-- -- begin
-- --   rw eq1, transitivity 2 * ∑' (i : ℕ), (2 : ℝ) ^ (i + 1),
-- --   sorry
-- -- end,
-- begin
--   apply le_trans ineq1, apply add_le_add,
--   apply mul_le_mul, exact ineq2, refl, apply f.nonneg,
--   rw inv_nonneg, norm_cast, apply pow_nonneg, exact zero_le _,

--   rw [eq1, ←geom_sum_def, geom_sum_eq, show (2 : ℝ) - 1 = 1, by ring, div_one,
--     mul_sub],
--   -- apply mul_le_mul, transitivity ((f.m : ℝ) ^ 2)⁻¹ * 1,
--   -- apply mul_le_mul, refl, exact ineq3, apply finset.sum_nonneg,
--   -- intros i hi, norm_cast, apply pow_nonneg, exact zero_le _,
--   -- rw inv_nonneg, norm_cast, apply pow_nonneg, linarith [f.hm],
--   -- rw [mul_one, inv_le_inv], norm_cast, transitivity 2 ^ 2,
--   -- conv_lhs { rw [show 2 = 2^1, by rw pow_one] },
--   -- apply nat.pow_le_pow_of_le_right, exact nat.zero_lt_succ 1,
--   -- exact one_le_two, apply nat.pow_le_pow_of_le_left,
--   -- exact f.hm, norm_cast, apply pow_pos, linarith [f.hm],
--   -- norm_cast, exact nat.zero_lt_succ 1, refl, apply add_nonneg,
--   -- exact C1'_nonneg f, linarith [f.C2_pos], rw inv_nonneg, norm_cast, exact zero_le _,
-- end
