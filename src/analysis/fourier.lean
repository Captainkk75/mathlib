/-
Copyright (c) 2021 Heather Macbeth. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth
-/
import measure_theory.function.continuous_map_dense
import measure_theory.function.l2_space
import measure_theory.measure.haar
import measure_theory.measure.lebesgue
import analysis.complex.circle
import topology.metric_space.emetric_paracompact
import topology.continuous_function.stone_weierstrass

-- ALEX ADDED
import algebra.floor
import group_theory.coset
/-!

# Fourier analysis on the circle

This file contains basic technical results for a development of Fourier series.

## Main definitions

* `haar_circle`, Haar measure on the circle, normalized to have total measure `1`
* instances `measure_space`, `probability_measure` for the circle with respect to this measure
* for `n : ℤ`, `fourier n` is the monomial `λ z, z ^ n`, bundled as a continuous map from `circle`
  to `ℂ`
* for `n : ℤ` and `p : ℝ≥0∞`, `fourier_Lp p n` is an abbreviation for the monomial `fourier n`
  considered as an element of the Lᵖ-space `Lp ℂ p haar_circle`, via the embedding
  `continuous_map.to_Lp`

## Main statements

The theorem `span_fourier_closure_eq_top` states that the span of the monomials `fourier n` is
dense in `C(circle, ℂ)`, i.e. that its `submodule.topological_closure` is `⊤`.  This follows from
the Stone-Weierstrass theorem after checking that it is a subalgebra, closed under conjugation, and
separates points.

The theorem `span_fourier_Lp_closure_eq_top` states that for `1 ≤ p < ∞` the span of the monomials
`fourier_Lp` is dense in `Lp ℂ p haar_circle`, i.e. that its `submodule.topological_closure` is
`⊤`.  This follows from the previous theorem using general theory on approximation of Lᵖ functions
by continuous functions.

The theorem `orthonormal_fourier` states that the monomials `fourier_Lp 2 n` form an orthonormal
set (in the L² space of the circle).

By definition, a Hilbert basis for an inner product space is an orthonormal set whose span is
dense.  Thus, the last two results together establish that the functions `fourier_Lp 2 n` form a
Hilbert basis for L².

## TODO

Once mathlib has general theory showing that a Hilbert basis of an inner product space induces a
unitary equivalence with L², the results in this file will give Fourier series applications such
as Parseval's formula.

-/

noncomputable theory
open_locale ennreal
open topological_space continuous_map measure_theory measure_theory.measure algebra submodule set

local attribute [instance] fact_one_le_two_ennreal

/-! ### Choice of measure on the circle -/

section haar_circle
/-! We make the circle into a measure space, using the Haar measure normalized to have total
measure 1. -/

instance : measurable_space circle := borel circle
instance : borel_space circle := ⟨rfl⟩

/-- Haar measure on the circle, normalized to have total measure 1. -/
def haar_circle : measure circle := haar_measure positive_compacts_univ

instance : probability_measure haar_circle := ⟨haar_measure_self⟩

instance : measure_space circle :=
{ volume := haar_circle,
  .. circle.measurable_space }

end haar_circle

/-! ### Monomials on the circle -/

section fourier

/-- The family of monomials `λ z, z ^ n`, parametrized by `n : ℤ` and considered as bundled
continuous maps from `circle` to `ℂ`. -/
@[simps] def fourier (n : ℤ) : C(circle, ℂ) :=
{ to_fun := λ z, z ^ n,
  continuous_to_fun := continuous_subtype_coe.fpow nonzero_of_mem_circle n }

@[simp] lemma fourier_zero {z : circle} : fourier 0 z = 1 := rfl

@[simp] lemma fourier_neg {n : ℤ} {z : circle} : fourier (-n) z = complex.conj (fourier n z) :=
by simp [← coe_inv_circle_eq_conj z]

@[simp] lemma fourier_add {m n : ℤ} {z : circle} :
  fourier (m + n) z = (fourier m z) * (fourier n z) :=
by simp [fpow_add (nonzero_of_mem_circle z)]

/-- The subalgebra of `C(circle, ℂ)` generated by `z ^ n` for `n ∈ ℤ`; equivalently, polynomials in
`z` and `conj z`. -/
def fourier_subalgebra : subalgebra ℂ C(circle, ℂ) := algebra.adjoin ℂ (range fourier)

/-- The subalgebra of `C(circle, ℂ)` generated by `z ^ n` for `n ∈ ℤ` is in fact the linear span of
these functions. -/
lemma fourier_subalgebra_coe : fourier_subalgebra.to_submodule = span ℂ (range fourier) :=
begin
  apply adjoin_eq_span_of_subset,
  refine subset.trans _ submodule.subset_span,
  intros x hx,
  apply submonoid.closure_induction hx (λ _, id) ⟨0, rfl⟩,
  rintros _ _ ⟨m, rfl⟩ ⟨n, rfl⟩,
  refine ⟨m + n, _⟩,
  ext1 z,
  exact fourier_add,
end

/-- The subalgebra of `C(circle, ℂ)` generated by `z ^ n` for `n ∈ ℤ` separates points. -/
lemma fourier_subalgebra_separates_points : fourier_subalgebra.separates_points :=
begin
  intros x y hxy,
  refine ⟨_, ⟨fourier 1, _, rfl⟩, _⟩,
  { exact subset_adjoin ⟨1, rfl⟩ },
  { simp [hxy] }
end

/-- The subalgebra of `C(circle, ℂ)` generated by `z ^ n` for `n ∈ ℤ` is invariant under complex
conjugation. -/
lemma fourier_subalgebra_conj_invariant :
  conj_invariant_subalgebra (fourier_subalgebra.restrict_scalars ℝ) :=
begin
  rintros _ ⟨f, hf, rfl⟩,
  change _ ∈ fourier_subalgebra,
  change _ ∈ fourier_subalgebra at hf,
  apply adjoin_induction hf,
  { rintros _ ⟨n, rfl⟩,
    suffices : fourier (-n) ∈ fourier_subalgebra,
    { convert this,
      ext1,
      simp },
    exact subset_adjoin ⟨-n, rfl⟩ },
  { intros c,
    exact fourier_subalgebra.algebra_map_mem (complex.conj c) },
  { intros f g hf hg,
    convert fourier_subalgebra.add_mem hf hg,
    exact alg_hom.map_add _ f g, },
  { intros f g hf hg,
    convert fourier_subalgebra.mul_mem hf hg,
    exact alg_hom.map_mul _ f g, }
end

/-- The subalgebra of `C(circle, ℂ)` generated by `z ^ n` for `n ∈ ℤ` is dense. -/
lemma fourier_subalgebra_closure_eq_top : fourier_subalgebra.topological_closure = ⊤ :=
continuous_map.subalgebra_complex_topological_closure_eq_top_of_separates_points
  fourier_subalgebra
  fourier_subalgebra_separates_points
  fourier_subalgebra_conj_invariant

/-- The linear span of the monomials `z ^ n` is dense in `C(circle, ℂ)`. -/
lemma span_fourier_closure_eq_top : (span ℂ (range fourier)).topological_closure = ⊤ :=
begin
  rw ← fourier_subalgebra_coe,
  exact congr_arg subalgebra.to_submodule fourier_subalgebra_closure_eq_top,
end

/-- The family of monomials `λ z, z ^ n`, parametrized by `n : ℤ` and considered as elements of
the `Lp` space of functions on `circle` taking values in `ℂ`. -/
abbreviation fourier_Lp (p : ℝ≥0∞) [fact (1 ≤ p)] (n : ℤ) : Lp ℂ p haar_circle :=
to_Lp p haar_circle ℂ (fourier n)

/-- For each `1 ≤ p < ∞`, the linear span of the monomials `z ^ n` is dense in
`Lp ℂ p haar_circle`. -/
lemma span_fourier_Lp_closure_eq_top {p : ℝ≥0∞} [fact (1 ≤ p)] (hp : p ≠ ∞) :
  (span ℂ (range (fourier_Lp p))).topological_closure = ⊤ :=
begin
  convert (continuous_map.to_Lp_dense_range ℂ hp haar_circle ℂ).topological_closure_map_submodule
    span_fourier_closure_eq_top,
  rw [map_span, range_comp],
  simp
end

/-- For `n ≠ 0`, a rotation by `n⁻¹ * real.pi` negates the monomial `z ^ n`. -/
lemma fourier_add_half_inv_index {n : ℤ} (hn : n ≠ 0) (z : circle) :
  fourier n ((exp_map_circle (n⁻¹ * real.pi) * z)) = - fourier n z :=
begin
  have : ↑n * ((↑n)⁻¹ * ↑real.pi * complex.I) = ↑real.pi * complex.I,
  { have : (n:ℂ) ≠ 0 := by exact_mod_cast hn,
    field_simp,
    ring },
  simp [mul_fpow, ← complex.exp_int_mul, complex.exp_pi_mul_I, this]
end

/-- The monomials `z ^ n` are an orthonormal set with respect to Haar measure on the circle. -/
lemma orthonormal_fourier : orthonormal ℂ (fourier_Lp 2) :=
begin
  rw orthonormal_iff_ite,
  intros i j,
  rw continuous_map.inner_to_Lp haar_circle (fourier i) (fourier j),
  split_ifs,
  { simp [h, probability_measure.measure_univ, ← fourier_neg, ← fourier_add, -fourier_to_fun] },
  simp only [← fourier_add, ← fourier_neg, is_R_or_C.conj_to_complex],
  have hij : -i + j ≠ 0,
  { rw add_comm,
    exact sub_ne_zero.mpr (ne.symm h) },
  exact integral_zero_of_mul_left_eq_neg (is_mul_left_invariant_haar_measure _)
    (fourier_add_half_inv_index hij)
end





---------------------------- POISSON SUMMATION ---------------

--@[derive [add_comm_group, topological_space]]
notation `genBy1` := add_subgroup.gmultiples (1:ℝ)
notation `ℝmodℤ` := quotient_add_group.quotient genBy1

--open_locale tsum


--@[derive has_coe_to_fun]
def Schwarz := {f : ℝ → ℂ // asymptotics.is_O f  (λ x : ℝ, 1/(1+x^2)) (filter.cocompact ℝ) ∧
  times_cont_diff ℝ 2 f }

instance : add_comm_monoid Schwarz := sorry

instance : module ℝ Schwarz := sorry

instance : has_coe Schwarz (ℝ → ℂ) := coe_subtype

instance : has_coe_to_fun Schwarz := ⟨ _ , (λ f, (f : ℝ → ℂ ))⟩

def Fourier_transform : Schwarz →ₗ[ℝ] Schwarz := sorry

@[simp] lemma Fourier_transform_apply (f : Schwarz ) (x : ℝ) :
Fourier_transform f x = ∫ t : ℝ , f t  * complex.exp (2 * real.pi * complex.I * t * x) :=
begin
  sorry,
end


/--  x:ℝ  ↦ F(x) := ∑ f ( x + m  )-/
def automorphic_point_pair_invariant' : Schwarz → (ℝ → ℂ ) :=
 λ f, λ x, ∑' (m:ℤ), f (x+m)

/--  x:ℝ/ℤ   ↦ F(x):= ∑ f ( x + m  )-/
def auto_descend' : Schwarz → (ℝmodℤ → ℂ )  :=
λ f, @quotient.lift _ _ (quotient_add_group.left_rel _) (automorphic_point_pair_invariant' f)
--(add_subgroup.gmultiples (2*real.pi))
begin
  intros a b hab,

  rw automorphic_point_pair_invariant',
  cases hab with n hn,
  simp,
  simp at hn,

  have : b = a+n,
  { rw hn,
    ring, },
  rw this,
  convert (equiv.tsum_eq (equiv.vadd_const n) _ ).symm using 2,
  ext1,
  congr' 1,
  simp,
  ring,
  apply_instance,
end

/--  x,y:ℝ/ℤ   ↦ K(x,y):= ∑ f ( x + m -y  )-/
def auto_descend : Schwarz → (ℝmodℤ × ℝmodℤ → ℂ )  := λ f, λ ⟨x, y⟩ ,
(auto_descend' f) (x-y)


/--  y : ℝ/ℤ   ↦ θ : circle -/
def expm : ℝmodℤ ≃ circle := sorry


def auto_descend'' : Schwarz → ℝmodℤ → circle → ℂ   := λ f, λ x, λ  y,
(auto_descend f) ⟨ x, expm.symm y⟩

/--  θ:circle , y : ℝ/ℤ   ↦ K(θ ,y):= ∑ f ( θ  + m -y  )-/
def auto_descend''' : Schwarz → ℝmodℤ → Lp ℂ 2 haar_circle   :=  sorry
--λ f, λ x, λ  y,
--(auto_descend f) ⟨ x,y⟩

/--  given K, y:ℝ/ℤ , m:ℤ , get: ⟨K(θ ,y), e_m(θ)⟩ -/
def cof : Schwarz → ℝmodℤ → ℤ → ℂ := λ f, λ θ, λ m,
  inner (fourier_Lp 2 m) (auto_descend''' f θ)

open_locale big_operators

lemma real_to_haar_N (f : Schwarz) (M : ℕ) : ∫ x in (set.Icc (-(M:ℝ)) M), f x =
∑ n in (finset.Ico_ℤ (-(M:ℤ)) (M)), ∫ x in set.Icc (0:ℝ) (1:ℝ), f (x + n) :=
begin
  induction M with k hk,
  { simp,
    have : finset.Ico_ℤ 0 0 = ∅ ,
    {
      sorry,
    },
    rw this,
    simp, },
  sorry,
end

instance : compact_space ℝmodℤ := sorry

instance : t2_space ℝmodℤ := sorry

instance : second_countable_topology ℝmodℤ := sorry

variables [measurable_space ℝmodℤ] [borel_space ℝmodℤ]

notation `μ_ℝmodℤ`:=measure_theory.measure.add_haar_measure positive_compacts_univ

lemma something  (μ : measure ℝ) (h : ∀ f : bounded_continuous_function ℝ ℝ ,
∑' (n : ℤ),∫ (t:ℝ), f(t+n) ∂ μ =  ∫ (t : ℝ), f (t)) :
measure.map (quotient_add_group.mk : (ℝ → ℝmodℤ)) μ =
 μ_ℝmodℤ :=
begin
  sorry,
end

/-- Move somewhere ??? algebra.floor? -/
lemma RmodZuniqueRep :
∀ (t : ℝ), ∃! (x : ℝ), ∃ (n : ℤ), x ∈ Ico (0:ℝ) 1 ∧ t = x + n :=
begin
  intro t,
  let n := floor t,
  let x := t-n,
  use x,
  use n,
  split,
  { split,
    { dsimp only [x, n],
      have := floor_le t,
      linarith, },
    { dsimp only [x, n],
      have := lt_floor_add_one t,
      linarith, }, },
  { dsimp only [x, n],
    ring, },
  { intros y hy,
    obtain ⟨nn, hny, hnt⟩ := hy,
    have : (nn:ℝ) = floor t,
    { have : (nn:ℝ) ≤ y+nn ∧ y+nn < nn + 1 ,
      { have := hny.1,
        have := hny.2,
        split; linarith, },
      rw [(floor_eq_iff.mpr this).symm, hnt], },
    dsimp only [x, n],
    rw [← this, hnt],
    ring, },
end

theorem real.volume_preimage_add_left (a : ℝ) (s : set ℝ) :
measure_theory.measure_space.volume (has_add.add a ⁻¹' s) = measure_theory.measure_space.volume s
:= sorry,

theorem disjoint.inter {α : Type*} {s t : set α} (u : set α) (h : disjoint s t) :
disjoint (u ∩ s) (u ∩ t) :=
begin
  apply disjoint.inter_right',
  apply disjoint.inter_left',
  exact h,
end

theorem disjoint.inter' {α : Type*} {s t : set α} (u : set α) (h : disjoint s t) :
disjoint (s ∩ u) (t ∩ u) :=
begin
  apply disjoint.inter_left,
  apply disjoint.inter_right,
  exact h,
end

/--- This was recently added , change finite_measure to is_finite_measure! -/
theorem measure_theory.measure.is_finite_measure_map {α : Type*} {β : Type*} [measurable_space β]
{m : measurable_space α} (μ : measure_theory.measure α) [measure_theory.finite_measure μ]
{f : α → β} (hf : measurable f) :
measure_theory.finite_measure ((measure_theory.measure.map f) μ) := sorry


lemma min_cases {α : Type*} [linear_order α] (a b : α) :
min a b = a ∧ a ≤ b ∨ min a b = b ∧ b < a :=
begin
  by_cases a ≤ b,
  { left,
    exact ⟨min_eq_left h, h⟩ },
  { right,
    push_neg at h,
    exact ⟨min_eq_right (le_of_lt h), h⟩ }
end

lemma max_cases {α : Type*} [linear_order α] (a b : α) :
max a b = b ∧ a ≤ b ∨ max a b = a ∧ b < a :=
begin
  by_cases a ≤ b,
  { left,
    exact ⟨max_eq_right h, h⟩ },
  { right,
    push_neg at h,
    exact ⟨max_eq_left (le_of_lt h), h⟩ }
end

lemma junk0929 (a b c d : set ℝ ) : a = b → c = d → a∪ c = b ∪ d :=
begin
  exact congr_arg2 (λ (a c : set ℝ), a ∪ c),
end

/-- Move elsewhere -/
lemma Ico_translate (a b x : ℝ) : has_add.add x ⁻¹' Ico a b = Ico (a-x) (b-x) :=
begin
  -- compare to set.Ico_add_bij  ??? Turn `=` into `bij_on`?? (When image sets are same `Type`??)
  ext1 y,
  split,
  { intros hy,
    simp only [preimage_const_add_Ico, mem_Ico, sub_neg_eq_add] at hy,
    exact mem_Ico.mpr hy, },
  { intros hy,
    simp only [preimage_const_add_Ico, mem_Ico, sub_neg_eq_add],
    exact mem_Ico.mp hy, },
end


lemma something1
--(S : set ℝ ) (hS : measurable_set S)
--(h : S = Ico 0 1)
--(h : ∀ t, ∃! x:ℝ ,  ∃n:ℤ, x∈ S ∧  t=x+n )
:
measure.map (quotient_add_group.mk : (ℝ → ℝmodℤ)) (measure.restrict volume (Ico (0:ℝ) 1)) =
 μ_ℝmodℤ :=
begin
  have meas1 : measurable (quotient_add_group.mk : (ℝ → ℝmodℤ)),
  { apply continuous.measurable,
    exact continuous_quotient_mk, },
  let S := Ico (0:ℝ) 1,
  have Smeas : measurable_set S := measurable_set_Ico,
  haveI : finite_measure (measure.restrict volume (Ico (0:ℝ) 1)) := ⟨by simp⟩,
  haveI : finite_measure (measure.map (quotient_add_group.mk : (ℝ → ℝmodℤ))
    (measure.restrict volume (Ico (0:ℝ) 1))),
  { refine measure_theory.measure.is_finite_measure_map _ _,
    exact meas1, },

  rw @measure_theory.measure.add_haar_measure_unique ℝmodℤ _ _ _ _ _ _ _ _
    (measure.map (quotient_add_group.mk : (ℝ → ℝmodℤ)) (measure.restrict volume S)) _ _
    (positive_compacts_univ),

  { transitivity (1:ennreal) • μ_ℝmodℤ,
    { congr,
      rw measure_theory.measure.map_apply,
      { simp [positive_compacts_univ], },
      { exact meas1, },
      { exact measurable_set.univ, }, },
    { simp, }, },
  { rw ←measure_theory.measure.map_add_left_eq_self,
    intros x,
    ext1 A hA,
    rw [measure_theory.measure.map_apply, measure_theory.measure.map_apply,
      measure_theory.measure.map_apply],

    {
      -- make this a lemma for the group theory library! ...
      obtain ⟨x0, hx0⟩ := @quotient.exists_rep _
        (quotient_add_group.left_rel genBy1) x,

      obtain ⟨x1, ⟨n, ⟨hx11, hx12⟩ , hn⟩, hx1'⟩ := RmodZuniqueRep x0,

      have xquotx1 : x = quotient_add_group.mk x1,
      { rw ← hx0,
        rw hn,
        refine quotient_add_group.eq.mpr _,
        use -n,
        simp, },
      have is_a_homo : ∀ z y, quotient_add_group.mk (z + y) = quotient_add_group.mk z
        + quotient_add_group.mk y :=
        add_monoid_hom.map_add (quotient_add_group.mk' genBy1),
      have two_quotients : quotient_add_group.mk ⁻¹' (has_add.add x ⁻¹' A) =
        has_add.add x1 ⁻¹' (quotient_add_group.mk ⁻¹' A),
      { ext1 y,
        simp only [mem_preimage],
        rw [xquotx1, is_a_homo x1 y], },
      let A1 := (quotient_add_group.mk ⁻¹' A) ∩ Ico x1 1,
      have A1meas : measurable_set A1 := measurable_set.inter (measurable_set_preimage meas1 hA)
        measurable_set_Ico,
      let A2 := (quotient_add_group.mk ⁻¹' A) ∩ Ico 0 x1,
      have A2meas : measurable_set A2 := measurable_set.inter (measurable_set_preimage meas1 hA)
        measurable_set_Ico,
      have A1A2dis : disjoint A1 A2,
      { dsimp only [A1, A2],
        apply disjoint.inter,
        rw set.Ico_disjoint_Ico,
        cases (min_cases 1 x1); cases (max_cases x1 0); linarith, },
      have A1A2 : (quotient_add_group.mk ⁻¹' A) ∩ Ico 0 1 = A1 ∪ A2,
      { convert set.inter_union_distrib_left using 2,
        rw set.union_comm,
        refine (set.Ico_union_Ico_eq_Ico _ _).symm; linarith, },
      let B1 : set ℝ :=  has_add.add x1 ⁻¹' A1,
      have B1meas : measurable_set B1 := measurable_set_preimage (measurable_const_add _) A1meas,
      let B2 : set ℝ := has_add.add (x1-1) ⁻¹' A2,
      have B2meas : measurable_set B2 := measurable_set_preimage (measurable_const_add _) A2meas,
      have B1B2dis : disjoint B1 B2,
      { have B1sub : B1 ⊆ has_add.add x1 ⁻¹' (Ico x1 1),
        { rw function.surjective.preimage_subset_preimage_iff,
          { exact (quotient_add_group.mk ⁻¹' A).inter_subset_right _, },
          { exact add_left_surjective _, }, },
        have B2sub : B2 ⊆ has_add.add (x1-1) ⁻¹' (Ico 0 x1),
        { rw function.surjective.preimage_subset_preimage_iff,
          { exact (quotient_add_group.mk ⁻¹' A).inter_subset_right _, },
          { exact add_left_surjective _, }, },
        refine set.disjoint_of_subset B1sub B2sub _,
        rw (by convert Ico_translate _ _ x1; ring :
          has_add.add x1 ⁻¹' Ico x1 1 = Ico 0 (1-x1)),
        rw (by convert Ico_translate _ _ (x1-1) using 2; ring :
          has_add.add (x1-1) ⁻¹' Ico 0 x1 = Ico (1-x1) 1),
        rw set.Ico_disjoint_Ico,
        cases (min_cases (1-x1) 1); cases (max_cases 0 (1-x1)); linarith, },
      have B1B2 :  (quotient_add_group.mk ⁻¹' (has_add.add x ⁻¹' A)) ∩ S = B1 ∪ B2,
      { rw two_quotients,
        rw (by rw set.Ico_union_Ico_eq_Ico; linarith : S = Ico 0 (1-x1) ∪ (Ico (1-x1) 1)),
        rw set.inter_distrib_left,

        have B1is : has_add.add x1 ⁻¹' (quotient_add_group.mk ⁻¹' A) ∩ Ico 0 (1 - x1) = B1 :=
          by rw [← (by convert Ico_translate _ _ x1; ring :
            has_add.add x1 ⁻¹' Ico x1 1 = Ico 0 (1-x1)), ← set.preimage_inter],
        have B2is : has_add.add x1 ⁻¹' (quotient_add_group.mk ⁻¹' A) ∩ Ico (1 - x1) 1 = B2,
        {
          rw [(_ : has_add.add x1 ⁻¹' (quotient_add_group.mk ⁻¹' A)
            = has_add.add (x1-1) ⁻¹' (quotient_add_group.mk ⁻¹' A) ),
            ←(by convert Ico_translate _ _ (x1-1) using 2; ring :
            has_add.add (x1-1) ⁻¹' Ico 0 x1 = Ico (1-x1) 1),
             ← set.preimage_inter],

          have : has_add.add (x1 - 1) ⁻¹' (quotient_add_group.mk ⁻¹' A) =
            has_add.add x1 ⁻¹' (has_add.add (-1) ⁻¹' (quotient_add_group.mk ⁻¹' A)),
          { conv_rhs {rw ← set.preimage_comp,},
            rw [comp_add_left, add_comm, sub_eq_add_neg], },
          rw this,

          congr' 1,
          { ext1 y,
            simp only [mem_preimage],
            rw is_a_homo,
            have : @quotient_add_group.mk _ _ genBy1 (-1:ℝ) = 0,
            { refine (quotient_add_group.eq_zero_iff (-1:ℝ)).mpr _,
              simp, },
            rw [this, zero_add], }, },

        exact congr_arg2 (λ (a c : set ℝ), a ∪ c) B1is B2is, },
      rw [measure_theory.measure.restrict_apply', measure_theory.measure.restrict_apply'],
      { rw [A1A2,
          B1B2],
        rw [measure_theory.measure_union, measure_theory.measure_union,
          real.volume_preimage_add_left, real.volume_preimage_add_left],
        { exact A1A2dis, },
        { exact A1meas, },
        { exact A2meas, },
        { exact B1B2dis, },
        { exact B1meas, },
        { exact B2meas, }, },
      { exact Smeas, },
      { exact Smeas, },
    },
    { exact meas1, },
    { exact hA, },
    { exact meas1, },
    { sorry, --  measurable_set (has_add.add x ⁻¹' A)
    },
    { sorry, -- measurable (has_add.add x)
    },
    { exact hA, }, },
end

lemma integral_Union {ι : Type*} [encodable ι] {s : ι → set ℝ } (f : ℝ  → ℂ )
  (hm : ∀ i, measurable_set (s i)) (hd : pairwise (disjoint on s)) (hfi : integrable f  ) :
  (∫ a in (⋃ n, s n), f a ) = ∑' n, ∫ a in s n, f a  :=
sorry




lemma RmodZuniqueRep'
 {x : ℝ} {i j : ℤ } :
x ∈ ( (λ (x : ℝ), -↑i + x) ⁻¹' Ico 0 1)
→
x ∈ ( (λ (x : ℝ), -↑j + x) ⁻¹' Ico 0 1)
→
i = j
 :=
begin
  sorry,
end


theorem floor_eq_on_Ico'' (n : ℤ) (x : ℝ)
(H : floor x = n ) :
x ∈ (λ (x : ℝ), -↑n + x) ⁻¹' Ico 0 1 :=
begin
  simp,
  rw floor_eq_iff at H,
  rw (by ring : (1:ℝ) + n = n + 1),
  exact H,
end


/-- This is the "unfolding" trick -/
lemma real_to_haar2 (f : Schwarz) (g : ℝmodℤ → ℂ) (F: ℝmodℤ→ℂ)
(hFf : ∀ (x:ℝ) , F (x:ℝmodℤ) = ∑' (n:ℤ), f((n:ℝ)+x)) :
∫ (x : ℝ), f x * g (x:ℝmodℤ) = ∫ (x : ℝmodℤ), F(x) * g(x) ∂ μ_ℝmodℤ :=
begin
  rw ← something1,
  {
    rw integral_map,
    {
      symmetry,
      calc
      ∫ (x : ℝ) in Ico 0 1, F (↑x) * g (↑x)
      = ∫ (x : ℝ) in Ico 0 1, (∑' (n:ℤ ), f ((n:ℝ)+x)) * g (↑x) : _
      ... = ∑' (n : ℤ), ∫ (x : ℝ) in Ico 0 1,  f (↑n+x) * g (↑x) : _
      ... = ∑' (n : ℤ), ∫ (x : ℝ) in Ico 0 1,
              (λ x, f (x) * g (↑x)) (has_add.add n x) : _
      ... = ∑' (n : ℤ), ∫ (x : ℝ), f (x) * g (↑x)
              ∂(measure_theory.measure.map (has_add.add (n:ℝ))
              (volume.restrict (Ico (0:ℝ) 1))) : _
      ... = ∑' (n : ℤ), ∫ (x : ℝ) in (has_add.add (-(n:ℝ))) ⁻¹' (Ico 0 1),
              f (x) * g (↑x) : _
      ... = ∫ (x : ℝ) in ⋃ (n : ℤ), (λ x:ℝ, -(n:ℝ)+x) ⁻¹' (Ico 0 1), f x * g x : _
      ... = ∫ (x : ℝ), f x * g x : _,

      { congr' 1,
        ext1,
        rw (_ : F (↑x) = (∑' (n : ℤ), f (↑n+x))),
        convert hFf x, },
      { -- dominated convergence, need to reverse sum (n:ℤ ) int_0^1
        sorry, },
      { congr' 1,
        ext1 n,
        congr' 1,
        ext1 x,
        rw ←  (_ : g (↑(↑n + x)) = g (↑x)),
        congr' 1,
        rw quotient_add_group.eq,
        use -n,
        simp, },
      {
        congr' 1,
        ext1 n,
        rw measure_theory.integral_map,
        { exact measurable_const_add (↑n), },
        sorry,
        -- need ae measurable f * g
      },
      {
        congr' 1, ext1 n,
        congr' 1,

        transitivity (map (has_add.add (n:ℝ)) volume).restrict (has_add.add ↑(-n) ⁻¹' Ico 0 1),

        {
          convert (@measure_theory.measure.restrict_map _ _ _ _ (volume : measure ℝ)
            (has_add.add (n:ℝ)) _ ((has_add.add ↑(-n) ⁻¹' Ico 0 1)) _).symm,

          { rw ← set.preimage_comp ,
            convert ( set.preimage_id).symm,
            ext1 x,
            simp, },

          { exact measurable_const_add ↑n, },

          sorry, -- measurability of Ico
        },



        rw real.map_volume_add_left,
        congr,
        norm_cast,
      },
      {
        symmetry,
        refine integral_Union (λ x, f x * g x) _ _ _,
        { intros n,
          sorry,
          --exact measurable_set_Ico,
          },
        { rintros i j ineqj x ⟨ hx1, hx2⟩ ,
          exact ineqj (RmodZuniqueRep' hx1 hx2), },
        { --  integrable volume
          sorry, }, },
      { congr' 1,
        convert measure.restrict_univ using 2,
        rw set.eq_univ_iff_forall ,
        intros x,
        rw set.mem_Union,
        let n := floor x,
        use n,
        have := floor_eq_on_Ico'',
        refine floor_eq_on_Ico'' _ _ _,
        dsimp only [n],
        refl, }, },
    { -- measurable quotient_add_group.mk
      -- continuous by definition. no content
      sorry,
    },
    {
      -- ae_measurable, no content
      sorry,
    },
  },
  { exact measurable_set_Ico, },
  { exact RmodZuniqueRep, },
end


lemma real_to_haar (f : Schwarz) : ∫ (x : ℝ), f x = ∑' (n : ℤ), ∫ x in set.Icc (0:ℝ) (1:ℝ), f( x + n) :=
begin
  -- need lemma relating tsum to partial sums, same on the other side. then take limits (dominated convergence)

  have :∀ᶠ n in (filter.cofinite), ae_measurable (indicator (set.Icc (n:ℝ) (n+1)) f ),
  {
--    intros n,
   sorry,
  },
  have h2 : ae_measurable f,
  {
    sorry,
  },
  have :=  measure_theory.tendsto_integral_filter_of_dominated_convergence (λ x, complex.abs (f x)) _ this h2 _ _,

  repeat {sorry},
end

-- Schwarz are integrable,
-- they are almost everywhere measurable
-- Multiply by |⬝|=1 and get another Schwarz function.


-- pushforward under expm of rest_Lebesgue = haar
-- map under expm ...
lemma pushforward_is_Haar :
measure_theory.measure.map exp_map_circle (volume.restrict (Icc (0:ℝ) 1))
=
haar_circle
:=
begin

  --  measure_theory.measure.map
  sorry,
end



lemma unfolding_trick (f : Schwarz ) ( y : ℝ ) (m : ℤ ) :
cof f (quotient.mk' y) m = Fourier_transform f (m:ℝ ) * complex.exp (-2 * real.pi * complex.I * m * y) :=
begin
  rw cof,
  simp,
  dsimp [inner],
  have : ∫ (a : ↥circle), complex.conj ((fourier_Lp 2 m) a) * (auto_descend''' f (quotient.mk' y)) a ∂haar_circle
  =
  ∫ (a : ↥circle), complex.conj ((fourier m) a) * (auto_descend'' f (quotient.mk' y)) a ∂haar_circle
  := sorry,
  rw this,
  clear this,
  simp,
  rw auto_descend'',
  rw auto_descend,
  simp,
  dsimp [auto_descend, auto_descend', automorphic_point_pair_invariant'],
  rw real_to_haar,
--  simp,

  sorry,
end

theorem Poisson_summation (f : Schwarz) : ∑' (n:ℤ), f n = ∑' (m:ℤ), (Fourier_transform f) m :=
begin
--  let K := (auto_descend f) ∘ (expm × expm) ,

  sorry,
end

end fourier
