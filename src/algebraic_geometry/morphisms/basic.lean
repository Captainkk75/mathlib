/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import algebraic_geometry.AffineScheme
import algebraic_geometry.pullbacks
import algebraic_geometry.limits

/-!
# Properties of morphisms

We provide the basic framework for talking about properties of morphisms.
The following meta-properties are defined

* `respects_iso`: `P` respects isomorphisms if `P f ‚Üí P (e ‚â´ f)` and `P f ‚Üí P (f ‚â´ e)`, where
  `e` is an isomorphism.
* `stable_under_composition`: `P` is stable under composition if `P f ‚Üí P g ‚Üí P (f ‚â´ g)`.
* `stable_under_base_change`: `P` is stable under base change if `P (Y ‚ü∂ S) ‚Üí P (X √ó[S] Y ‚ü∂ X)`.

Special support is also provided for morphism properties defined for `X ‚ü∂ Y` with `Y` affine
(`affine_target_morphism_property`). A morphism `f : X ‚ü∂ Y` is locally `P`
(`target_affine_locally P`) if `P (f ‚à£_ U)` for each affine open set `U ‚äÜ Y`. Such a property `P` is
called local (`P.is_local`) if
1. `P` respects iso.
2. If `P` holds for some `f : X ‚ü∂ Y`, `P` holds for `f ‚à£_ D (r)` for all `r : Œì(Y)`.
3. If `P` holds for `f ‚à£_ D (r)` for each `r` in a spanning set `s` of `Œì(Y)`, then `P` holds for
  `f`.

If `P` is local, then given a `f : X ‚ü∂ Y`, then TFAE:
1. `f` is locally `P`.
2. `P` holds for all `f ‚à£_ U·µ¢` for all affine covers `{ U·µ¢ }` of `Y`.
3. `P` holds for all `f ‚à£_ U·µ¢` for some affine cover `{ U·µ¢ }` of `Y`.
4. locally `P` holds for all `f ‚à£_ U·µ¢` for all open covers `{ U·µ¢ }` of `Y`.
5. locally `P` holds for all `f ‚à£_ U·µ¢` for some open cover `{ U·µ¢ }` of `Y`.

Also, to check that "locally `P`" is stable under base change, it suffices to check that
  `P (Y ‚ü∂ S) ‚Üí P (X √ó[S] Y ‚ü∂ X)` for affine `S` and `X`.

-/

universe u

open topological_space category_theory category_theory.limits opposite

noncomputable theory

namespace algebraic_geometry

def morphism_property := ‚àÄ ‚¶ÉX Y : Scheme‚¶Ñ (f : X ‚ü∂ Y), Prop

def affine_target_morphism_property := ‚àÄ ‚¶ÉX Y : Scheme‚¶Ñ (f : X ‚ü∂ Y) [is_affine Y], Prop

def affine_target_morphism_property.to_property (P : affine_target_morphism_property) :
  morphism_property :=
Œª X Y f, ‚àÉ h, @@P f h

lemma affine_target_morphism_property.to_property_apply (P : affine_target_morphism_property)
  {X Y : Scheme} (f : X ‚ü∂ Y) [is_affine Y] :
  P.to_property f ‚Üî P f := by { delta affine_target_morphism_property.to_property, simp [*] }

def respects_iso (P : morphism_property) :=
  (‚àÄ {X Y Z} (e : X ‚âÖ Y) (f : Y ‚ü∂ Z), P f ‚Üí P (e.hom ‚â´ f)) ‚àß
  (‚àÄ {X Y Z} (e : Y ‚âÖ Z) (f : X ‚ü∂ Y), P f ‚Üí P (f ‚â´ e.hom))

def stable_under_composition (P : morphism_property) :=
  ‚àÄ ‚¶ÉX Y Z‚¶Ñ (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), P f ‚Üí P g ‚Üí (P (f ‚â´ g))

def stable_under_base_change
  (P : morphism_property) : Prop :=
‚àÄ ‚¶ÉX Y S : Scheme‚¶Ñ (f : X ‚ü∂ S) (g : Y ‚ü∂ S), P g ‚Üí P (pullback.fst : pullback f g ‚ü∂ X)

lemma stable_under_composition.respects_iso {P : morphism_property}
  (hP : stable_under_composition P) (hP' : ‚àÄ {X Y} (e : X ‚âÖ Y), P e.hom) : respects_iso P :=
‚ü®Œª X Y Z e f hf, hP _ _ (hP' e) hf, Œª X Y Z e f hf, hP _ _ hf (hP' e)‚ü©

lemma respects_iso.cancel_left_is_iso {P : morphism_property}
  (hP : respects_iso P) {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [is_iso f] :
    P (f ‚â´ g) ‚Üî P g :=
‚ü®Œª h, by simpa using hP.1 (as_iso f).symm (f ‚â´ g) h, hP.1 (as_iso f) g‚ü©

lemma respects_iso.cancel_right_is_iso {P : morphism_property}
  (hP : respects_iso P) {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [is_iso g] :
    P (f ‚â´ g) ‚Üî P f :=
‚ü®Œª h, by simpa using hP.2 (as_iso g).symm (f ‚â´ g) h, hP.2 (as_iso g) f‚ü©

def affine_target_morphism_property.respects_iso (P : affine_target_morphism_property) : Prop :=
  (‚àÄ {X Y Z} (e : X ‚âÖ Y) (f : Y ‚ü∂ Z) [is_affine Z], by exactI P f ‚Üí P (e.hom ‚â´ f)) ‚àß
  (‚àÄ {X Y Z} (e : Y ‚âÖ Z) (f : X ‚ü∂ Y) [h : is_affine Y],
    by exactI P f ‚Üí @@P (f ‚â´ e.hom) (is_affine_of_iso e.inv))

lemma affine_target_morphism_property.respects_iso_iff (P : affine_target_morphism_property) :
  P.respects_iso ‚Üî respects_iso P.to_property :=
begin
  delta respects_iso affine_target_morphism_property.respects_iso,
  rw and_congr; apply forall‚ÇÖ_congr,
  { intros X Y Z e f, exact ‚ü®Œª H ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, ‚ü®h‚ÇÅ, @H h‚ÇÅ h‚ÇÇ‚ü©, Œª H h‚ÇÅ h‚ÇÇ, (H ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©).some_spec‚ü© },
  { intros X Y Z e f, exact ‚ü®Œª H ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    by exactI ‚ü®is_affine_of_iso e.inv, H h‚ÇÇ‚ü©, Œª H h‚ÇÅ h‚ÇÇ, (H ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©).some_spec‚ü© },
end

lemma affine_target_morphism_property.respects_iso.to_property
  {P : affine_target_morphism_property} (hP : P.respects_iso) :
    respects_iso P.to_property :=
P.respects_iso_iff.mp hP

lemma affine_target_morphism_property.respects_iso.cancel_left_is_iso
  {P : affine_target_morphism_property} (hP : P.respects_iso) {X Y Z : Scheme} (f : X ‚ü∂ Y)
    (g : Y ‚ü∂ Z) [is_iso f] [is_affine Z] : P (f ‚â´ g) ‚Üî P g :=
by rw [‚Üê P.to_property_apply, ‚Üê P.to_property_apply, (P.respects_iso_iff.mp hP).cancel_left_is_iso]

lemma affine_target_morphism_property.respects_iso.cancel_right_is_iso
  {P : affine_target_morphism_property} (hP : P.respects_iso) {X Y Z : Scheme} (f : X ‚ü∂ Y)
    (g : Y ‚ü∂ Z) [is_iso g] [is_affine Z] [is_affine Y] : P (f ‚â´ g) ‚Üî P f :=
by rw [‚Üê P.to_property_apply, ‚Üê P.to_property_apply, (P.respects_iso_iff.mp hP).cancel_right_is_iso]

lemma stable_under_base_change.symmetry {P : morphism_property}
  (hP : stable_under_base_change P) (hP' : respects_iso P) {X Y S : Scheme} (f : X ‚ü∂ S)
  (g : Y ‚ü∂ S) (H : P f) : P (pullback.snd : pullback f g ‚ü∂ Y) :=
begin
  rw [‚Üê pullback_symmetry_hom_comp_fst, hP'.cancel_left_is_iso],
  apply hP,
  exact H
end

lemma stable_under_base_change.base_change_obj {P : morphism_property}
  (hP : stable_under_base_change P) (hP' : respects_iso P) {S S' : Scheme} (f : S' ‚ü∂ S)
  (X : over S) (H : P X.hom) : P ((base_change f).obj X).hom :=
hP.symmetry hP' X.hom f H

def pullback.congr {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    pullback f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ :=
as_iso (pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simpa using e‚ÇÅ) (by simpa using e‚ÇÇ))

@[simp, reassoc]
lemma pullback.congr_hom_fst {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congr e‚ÇÅ e‚ÇÇ).hom ‚â´ pullback.fst = pullback.fst :=
by { delta pullback.congr, simp }

@[simp, reassoc]
lemma pullback.congr_hom_snd {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congr e‚ÇÅ e‚ÇÇ).hom ‚â´ pullback.snd = pullback.snd :=
by { delta pullback.congr, simp }

@[simp, reassoc]
lemma pullback.congr_inv_fst {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congr e‚ÇÅ e‚ÇÇ).inv ‚â´ pullback.fst = pullback.fst :=
by rw [iso.inv_comp_eq, pullback.congr_hom_fst]

@[simp, reassoc]
lemma pullback.congr_inv_snd {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congr e‚ÇÅ e‚ÇÇ).inv ‚â´ pullback.snd = pullback.snd :=
by rw [iso.inv_comp_eq, pullback.congr_hom_snd]

lemma stable_under_base_change.base_change_map {P : morphism_property}
  (hP : stable_under_base_change P) (hP' : respects_iso P) {S S' : Scheme} (f : S' ‚ü∂ S)
  {X Y : over S} (g : X ‚ü∂ Y) (H : P g.left) : P ((base_change f).map g).left :=
begin
  let e := pullback_right_pullback_fst_iso Y.hom f g.left ‚â™‚â´
    pullback.congr (g.w.trans (category.comp_id _)) rfl,
  have : e.inv ‚â´ pullback.snd = ((base_change f).map g).left,
  { apply pullback.hom_ext; dsimp; simp },
  rw [‚Üê this, hP'.cancel_left_is_iso],
  apply hP.symmetry hP',
  exact H
end

lemma stable_under_base_change.pullback_map {P : morphism_property}
  (hP : stable_under_base_change P) (hP' : respects_iso P)
  (hP'' : stable_under_composition P) {S X X' Y Y' : Scheme}
  {f : X ‚ü∂ S} {g : Y ‚ü∂ S} {f' : X' ‚ü∂ S} {g' : Y' ‚ü∂ S} {i‚ÇÅ : X ‚ü∂ X'} {i‚ÇÇ : Y ‚ü∂ Y'}
  (h‚ÇÅ : P i‚ÇÅ) (h‚ÇÇ : P i‚ÇÇ) (e‚ÇÅ : f = i‚ÇÅ ‚â´ f') (e‚ÇÇ : g = i‚ÇÇ ‚â´ g') :
    P (pullback.map f g f' g' i‚ÇÅ i‚ÇÇ (ùüô _)
      ((category.comp_id _).trans e‚ÇÅ) ((category.comp_id _).trans e‚ÇÇ)) :=
begin
  have : pullback.map f g f' g' i‚ÇÅ i‚ÇÇ (ùüô _)
    ((category.comp_id _).trans e‚ÇÅ) ((category.comp_id _).trans e‚ÇÇ) =
      ((pullback_symmetry _ _).hom ‚â´
      ((base_change _).map (over.hom_mk _ e‚ÇÇ.symm : over.mk g ‚ü∂ over.mk g')).left) ‚â´
      (pullback_symmetry _ _).hom ‚â´
      ((base_change g').map (over.hom_mk _ e‚ÇÅ.symm : over.mk f ‚ü∂ over.mk f')).left,
  { apply pullback.hom_ext; dsimp; simp },
  rw this,
  apply hP''; rw hP'.cancel_left_is_iso,
  exacts [hP.base_change_map hP' _ (over.hom_mk _ e‚ÇÇ.symm : over.mk g ‚ü∂ over.mk g') h‚ÇÇ,
    hP.base_change_map hP' _ (over.hom_mk _ e‚ÇÅ.symm : over.mk f ‚ü∂ over.mk f') h‚ÇÅ],
end

lemma congr_property_morphism_restrict_iff (P : morphism_property) (hP : respects_iso P)
  {X Y : Scheme} (f : X ‚ü∂ Y) {U V : opens Y.carrier} (e : U = V) :
  P (f ‚à£_ U) ‚Üî P (f ‚à£_ V) :=
by subst e

lemma property_iff_of_is_open_immersion (P : morphism_property) (hP : respects_iso P)
  {X Y U : Scheme} (f : X ‚ü∂ Y) (g : U ‚ü∂ Y) [hg : is_open_immersion g] :
  P (pullback.snd : pullback f g ‚ü∂ _) ‚Üî P (f ‚à£_ ‚ü®set.range g.1.base, hg.base_open.open_range‚ü©) :=
begin
  let V : opens Y.carrier := ‚ü®set.range g.1.base, hg.base_open.open_range‚ü©,
  let e := is_open_immersion.iso_of_range_eq g (Y.of_restrict V.open_embedding)
    (by exact subtype.range_coe.symm),
  let t : pullback f g ‚ü∂ pullback f (Y.of_restrict V.open_embedding) :=
    pullback.map _ _ _ _ (ùüô _) e.hom (ùüô _) (by rw [category.comp_id, category.id_comp])
      (by rw [category.comp_id, is_open_immersion.iso_of_range_eq_hom, is_open_immersion.lift_fac]),
  have : t ‚â´ (pullback_restrict_iso_restrict f V).hom ‚â´ f ‚à£_ V ‚â´ e.inv = pullback.snd,
  { rw [‚Üê cancel_mono g, is_open_immersion.iso_of_range_eq_inv, category.assoc, category.assoc,
      category.assoc, is_open_immersion.lift_fac, ‚Üê pullback.condition, morphism_restrict_Œπ,
      pullback_restrict_iso_restrict_hom_restrict_assoc,
      pullback.lift_fst_assoc, category.comp_id] },
  rw [‚Üê this, hP.cancel_left_is_iso, hP.cancel_left_is_iso, hP.cancel_right_is_iso],
end

lemma property_restrict_restrict_iff (P : morphism_property) (hP : respects_iso P)
  {X Y : Scheme} (f : X ‚ü∂ Y) (U : opens Y.carrier) (V : opens U) :
  P (f ‚à£_ U ‚à£_ V) ‚Üî P (f ‚à£_ (U.open_embedding.is_open_map.functor.obj V)) :=
begin
  let : (f ‚à£_ U ‚à£_ V) = ((pullback_restrict_iso_restrict (f ‚à£_ U) V).inv ‚â´
    (pullback_symmetry _ _).hom ‚â´ pullback.map _ _ _ _ (ùüô _)
      ((pullback_restrict_iso_restrict f U).inv ‚â´ (pullback_symmetry _ _).hom) (ùüô _)
    ((category.comp_id _).trans (category.id_comp _).symm) (by simpa) ‚â´
    (pullback_right_pullback_fst_iso _ _ _).hom ‚â´ (pullback_symmetry _ _).hom) ‚â´ pullback.snd,
  { simpa },
  rw [this, hP.cancel_left_is_iso, property_iff_of_is_open_immersion _ hP],
  apply congr_property_morphism_restrict_iff P hP,
  ext1,
  dsimp,
  rw [coe_comp, set.range_comp],
  congr,
  exact subtype.range_coe,
end

lemma property_restrict_restrict_basic_open_iff (P : morphism_property) (hP : respects_iso P)
  {X Y : Scheme} (f : X ‚ü∂ Y) (U : opens Y.carrier) (r : Y.presheaf.obj (op U)) :
  P (f ‚à£_ U ‚à£_ (Y.restrict _).basic_open
    (Y.presheaf.map (eq_to_hom U.open_embedding_obj_top).op r)) ‚Üî P (f ‚à£_ Y.basic_open r) :=
begin
  rw property_restrict_restrict_iff _ hP,
  apply congr_property_morphism_restrict_iff _ hP,
  have e := Scheme.preimage_basic_open (Y.of_restrict U.open_embedding) r,
  erw [Scheme.of_restrict_coe_c_app, opens.adjunction_counit_app_self, eq_to_hom_op] at e,
  rw [‚Üê (Y.restrict U.open_embedding).basic_open_res_eq _
    (eq_to_hom U.inclusion_map_eq_top).op, ‚Üê comp_apply],
  erw ‚Üê Y.presheaf.map_comp,
  rw [eq_to_hom_op, eq_to_hom_op, eq_to_hom_map, eq_to_hom_trans],
  erw ‚Üê e,
  ext1, dsimp [opens.map, opens.inclusion],
  rw [set.image_preimage_eq_inter_range, set.inter_eq_left_iff_subset, subtype.range_coe],
  exact Y.basic_open_subset r
end

def target_affine_locally (P : affine_target_morphism_property) : morphism_property :=
  Œª {X Y : Scheme} (f : X ‚ü∂ Y), ‚àÄ (U : Y.affine_opens), @@P (f ‚à£_ U) U.prop

lemma target_affine_locally_respects_iso {P : affine_target_morphism_property}
  (hP : P.respects_iso) : respects_iso (target_affine_locally P) :=
begin
  split,
  { introv H U,
    rw [morphism_restrict_comp, hP.cancel_left_is_iso],
    exact H U },
  { introv H,
    rintro ‚ü®U, hU‚ü©, dsimp,
    haveI : is_affine _ := hU,
    haveI : is_affine _ := hU.map_is_iso e.hom,
    rw [morphism_restrict_comp, hP.cancel_right_is_iso],
    exact H ‚ü®(opens.map e.hom.val.base).obj U, hU.map_is_iso e.hom‚ü© }
end

structure affine_target_morphism_property.is_local (P : affine_target_morphism_property) : Prop :=
(respects_iso : P.respects_iso)
(to_basic_open : ‚àÄ {X Y : Scheme} [is_affine Y] (f : X ‚ü∂ Y) (r : Y.presheaf.obj $ op ‚ä§),
  by exactI P f ‚Üí
    @@P (f ‚à£_ (Y.basic_open r)) ((top_is_affine_open Y).basic_open_is_affine _))
(of_basic_open_cover : ‚àÄ {X Y : Scheme} [is_affine Y] (f : X ‚ü∂ Y)
  (s : finset (Y.presheaf.obj $ op ‚ä§)) (hs : ideal.span (s : set (Y.presheaf.obj $ op ‚ä§)) = ‚ä§),
  by exactI (‚àÄ (r : s), @@P (f ‚à£_ (Y.basic_open r.1))
    ((top_is_affine_open Y).basic_open_is_affine _)) ‚Üí P f)

lemma target_affine_locally_of_open_cover {P : affine_target_morphism_property}
  (hP : P.is_local)
  {X Y : Scheme} (f : X ‚ü∂ Y) (ùí∞ : Y.open_cover) [‚àÄ i, is_affine (ùí∞.obj i)]
  (hùí∞ : ‚àÄ i, P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i)) :
    target_affine_locally P f :=
begin
  classical,
  let S := Œª i, (‚ü®‚ü®set.range (ùí∞.map i).1.base, (ùí∞.is_open i).base_open.open_range‚ü©,
    range_is_affine_open_of_open_immersion (ùí∞.map i)‚ü© : Y.affine_opens),
  apply of_affine_open_cover (Œª U, @@P (f ‚à£_ U.1) U.2) _ _ (set.range S); dsimp only,
  { rw set.eq_univ_iff_forall,
    simp only [set.mem_Union],
    intro x,
    exact ‚ü®‚ü®_, ‚ü®ùí∞.f x, rfl‚ü©‚ü©, ùí∞.covers x‚ü© },
  { rintro ‚ü®_, i, rfl‚ü©,
    simp_rw ‚Üê P.to_property_apply at ‚ä¢ hùí∞,
    exact (property_iff_of_is_open_immersion _ hP.1.to_property _ _).mp (hùí∞ i) },
  { intros U r h,
    haveI : is_affine _ := U.2,
    have := hP.2 (f ‚à£_ U.1),
    replace this := this (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op r) h,
    rw ‚Üê P.to_property_apply at this ‚ä¢,
    exact (property_restrict_restrict_basic_open_iff _ hP.1.to_property _ _ r).mp this },
  { intros U s hs H,
    haveI : is_affine _ := U.2,
    apply hP.3 (f ‚à£_ U.1) (s.image (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op)),
    { apply_fun ideal.comap (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top.symm).op) at hs,
      rw ideal.comap_top at hs,
      rw ‚Üê hs,
      simp only [eq_to_hom_op, eq_to_hom_map, finset.coe_image],
      have : ‚àÄ {R S : CommRing} (e : S = R) (s : set S),
        (by exactI ideal.span (eq_to_hom e '' s) = ideal.comap (eq_to_hom e.symm) (ideal.span s)),
      { intros, subst e, simpa },
      apply this },
    { rintro ‚ü®r, hr‚ü©,
      obtain ‚ü®r, hr', rfl‚ü© := finset.mem_image.mp hr,
      simp_rw ‚Üê P.to_property_apply at ‚ä¢ H,
      exact (property_restrict_restrict_basic_open_iff _ hP.1.to_property f _ r).mpr
        (H ‚ü®r, hr'‚ü©) } }
end

lemma affine_target_morphism_property.is_local.affine_open_cover_tfae
  {P : affine_target_morphism_property}
  (hP : P.is_local) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
  tfae [target_affine_locally P f,
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)], ‚àÄ (i : ùí∞.J),
      by exactI P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)] (i : ùí∞.J),
      by exactI P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_affine U] [is_open_immersion g],
      by exactI P (pullback.snd : pullback f g ‚ü∂ U)] :=
begin
  tfae_have : 1 ‚Üí 4,
  { intros H U g h‚ÇÅ h‚ÇÇ,
    resetI,
    replace H := H ‚ü®‚ü®_, h‚ÇÇ.base_open.open_range‚ü©,
      range_is_affine_open_of_open_immersion g‚ü©,
    rw ‚Üê P.to_property_apply at H ‚ä¢,
    rwa property_iff_of_is_open_immersion _ hP.1.to_property },
  tfae_have : 4 ‚Üí 3,
  { intros H ùí∞ hùí∞ i,
    resetI,
    apply H },
  tfae_have : 3 ‚Üí 2,
  { exact Œª H, ‚ü®Y.affine_cover, infer_instance, H Y.affine_cover‚ü© },
  tfae_have : 2 ‚Üí 1,
  { rintro ‚ü®ùí∞, hùí∞, H‚ü©, exactI target_affine_locally_of_open_cover hP f ùí∞ H },
  tfae_finish
end

@[simps J obj map]
def Scheme.open_cover_of_supr_eq_top {s : Type*} (X : Scheme) (U : s ‚Üí opens X.carrier)
  (hU : (‚®Ü i, U i) = ‚ä§) : X.open_cover :=
{ J := s,
  obj := Œª i, X.restrict (U i).open_embedding,
  map := Œª i, X.of_restrict (U i).open_embedding,
  f := Œª x, begin
    have : x ‚àà ‚®Ü i, U i := hU.symm ‚ñ∏ (show x ‚àà (‚ä§ : opens X.carrier), by triv),
    exact (opens.mem_supr.mp this).some,
  end,
  covers := Œª x, begin
    erw subtype.range_coe,
    have : x ‚àà ‚®Ü i, U i := hU.symm ‚ñ∏ (show x ‚àà (‚ä§ : opens X.carrier), by triv),
    exact (opens.mem_supr.mp this).some_spec,
  end }

lemma affine_target_morphism_property.is_local_of_open_cover_imply
  (P : affine_target_morphism_property) (hP : P.respects_iso)
  (H : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y),
    (‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)], ‚àÄ (i : ùí∞.J),
      by exactI P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí
    (‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_affine U] [is_open_immersion g],
      by exactI P (pullback.snd : pullback f g ‚ü∂ U))) : P.is_local :=
begin
  refine ‚ü®hP, _, _‚ü©,
  { introv h,
    resetI,
    haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine r,
    delta morphism_restrict,
    rw hP.cancel_left_is_iso,
    refine @@H f ‚ü®Scheme.open_cover_of_is_iso (ùüô Y), _, _‚ü© (Y.of_restrict _) _inst _,
    { intro i, dsimp, apply_instance },
    { intro i, dsimp,
      rwa [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition, hP.cancel_left_is_iso] } },
  { introv hs hs',
    resetI,
    replace hs := ((top_is_affine_open Y).basic_open_union_eq_self_iff _).mpr hs,
    have := H f ‚ü®Y.open_cover_of_supr_eq_top _ hs, _, _‚ü© (ùüô _),
    rwa [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition, hP.cancel_left_is_iso] at this,
    { intro i, exact (top_is_affine_open Y).basic_open_is_affine _ },
    { rintro (i : s),
      specialize hs' i,
      haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine i.1,
      delta morphism_restrict at hs',
      rwa hP.cancel_left_is_iso at hs' } }
end

lemma affine_target_morphism_property.is_local.open_cover_tfae
  {P : affine_target_morphism_property}
  (hP : P.is_local) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
  tfae [target_affine_locally P f,
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y), ‚àÄ (i : ùí∞.J),
      target_affine_locally P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) (i : ùí∞.J),
      target_affine_locally P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ (U : opens Y.carrier), target_affine_locally P (f ‚à£_ U),
    ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_open_immersion g],
      target_affine_locally P (pullback.snd : pullback f g ‚ü∂ U)] :=
begin
  tfae_have : 2 ‚Üí 1,
  { rintros ‚ü®ùí∞, hùí∞‚ü©,
    rw (hP.affine_open_cover_tfae f).out 0 1,
    refine ‚ü®ùí∞.bind (Œª _, Scheme.affine_cover _), _, _‚ü©,
    { intro i, dsimp [Scheme.open_cover.bind], apply_instance },
    { intro i,
      specialize hùí∞ i.1,
      rw (hP.affine_open_cover_tfae (pullback.snd : pullback f (ùí∞.map i.fst) ‚ü∂ _)).out 0 2
        at hùí∞,
      specialize hùí∞ (Scheme.affine_cover _) i.2,
      let e : pullback f ((ùí∞.obj i.fst).affine_cover.map i.snd ‚â´ ùí∞.map i.fst) ‚ü∂
        pullback (pullback.snd : pullback f (ùí∞.map i.fst) ‚ü∂ _)
          ((ùí∞.obj i.fst).affine_cover.map i.snd),
      { refine (pullback_symmetry _ _).hom ‚â´ _,
        refine (pullback_right_pullback_fst_iso _ _ _).inv ‚â´ _,
        refine (pullback_symmetry _ _).hom ‚â´ _,
        refine pullback.map _ _ _ _ (pullback_symmetry _ _).hom (ùüô _) (ùüô _) _ _; simp },
      rw ‚Üê hP.1.cancel_left_is_iso e at hùí∞,
      convert hùí∞,
      simp } },
  tfae_have : 1 ‚Üí 4,
  { intros H U V,
    rw [‚Üê P.to_property_apply, property_restrict_restrict_iff _ hP.1.to_property],
    convert H ‚ü®_, V.2.image_is_open_immersion (Y.of_restrict _)‚ü©,
    rw ‚Üê P.to_property_apply,
    refl },
  tfae_have : 4 ‚Üí 3,
  { intros H ùí∞ i,
    have := H ‚ü®_, (ùí∞.is_open i).base_open.open_range‚ü©,
    rw property_iff_of_is_open_immersion _ (target_affine_locally_respects_iso hP.1),
    exact H ‚ü®_, (ùí∞.is_open i).base_open.open_range‚ü© },
  tfae_have : 3 ‚Üí 2,
  { exact Œª H, ‚ü®Y.affine_cover, H Y.affine_cover‚ü© },
  tfae_have : 4 ‚Üí 5,
  { intros H U g hg,
    resetI,
    rw property_iff_of_is_open_immersion _ (target_affine_locally_respects_iso hP.1),
    apply H },
  tfae_have : 5 ‚Üí 4,
  { intros H U,
    erw (target_affine_locally_respects_iso hP.1).cancel_left_is_iso,
    apply H },
  tfae_finish
end

lemma affine_target_morphism_property.is_local.affine_open_cover_iff
  {P : affine_target_morphism_property} (hP : P.is_local)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.open_cover.{u} Y) [hùí∞ : ‚àÄ i, is_affine (ùí∞.obj i)] :
  target_affine_locally P f ‚Üî ‚àÄ i, @@P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) (hùí∞ i) :=
‚ü®Œª H, let h := ((hP.affine_open_cover_tfae f).out 0 2).mp H in h ùí∞,
  Œª H, let h := ((hP.affine_open_cover_tfae f).out 1 0).mp in h ‚ü®ùí∞, infer_instance, H‚ü©‚ü©

lemma affine_target_morphism_property.is_local.open_cover_iff
  {P : affine_target_morphism_property} (hP : P.is_local)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.open_cover.{u} Y) :
  target_affine_locally P f ‚Üî
    ‚àÄ i, target_affine_locally P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) :=
‚ü®Œª H, let h := ((hP.open_cover_tfae f).out 0 2).mp H in h ùí∞,
  Œª H, let h := ((hP.open_cover_tfae f).out 1 0).mp in h ‚ü®ùí∞, H‚ü©‚ü©

universe v

/-- An isomorphism `X ‚ü∂ Y` is an open cover of `Y`. -/
 @[simps J obj map]
 def open_cover_of_is_iso {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [is_iso f] :
   Y.open_cover :=
 { J := punit.{v+1},
   obj := Œª _, X,
   map := Œª _, f,
   f := Œª _, punit.star,
   covers := Œª x, by { rw set.range_iff_surjective.mpr, { trivial }, rw ‚Üê Top.epi_iff_surjective,
     apply_instance } }

lemma affine_target_morphism_property.is_local.affine_target_iff
  {P : affine_target_morphism_property} (hP : P.is_local)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [is_affine Y] :
  target_affine_locally P f ‚Üî P f :=
begin
  rw hP.affine_open_cover_iff f _,
  swap, { exact open_cover_of_is_iso (ùüô Y) },
  swap, { intro _, dsimp, apply_instance },
  transitivity (P (pullback.snd : pullback f (ùüô _) ‚ü∂ _)),
  { exact ‚ü®Œª H, H punit.star, Œª H _, H‚ü© },
  rw [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition, hP.1.cancel_left_is_iso],
end

-- @[simps]
-- def Scheme.open_cover.add {X : Scheme} (ùí∞ : X.open_cover) {Y : Scheme} (f : Y ‚ü∂ X)
--   [is_open_immersion f] : X.open_cover :=
-- { J := option ùí∞.J,
--   obj := Œª i, option.rec Y ùí∞.obj i,
--   map := Œª i, option.rec f ùí∞.map i,
--   f := Œª x, some (ùí∞.f x),
--   covers := ùí∞.covers,
--   is_open := by rintro (_|_); dsimp; apply_instance }

def affine_target_morphism_property.stable_under_base_change
  (P : affine_target_morphism_property) : Prop :=
‚àÄ ‚¶ÉX Y S : Scheme‚¶Ñ [is_affine S] [is_affine X] (f : X ‚ü∂ S) (g : Y ‚ü∂ S),
  by exactI P g ‚Üí P (pullback.fst : pullback f g ‚ü∂ X)

lemma affine_target_morphism_property.is_local.affine_pullback_snd_of_left
  {P : affine_target_morphism_property} (hP : P.is_local) (hP' : P.stable_under_base_change)
  {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [is_affine S] (H : P g) :
  target_affine_locally P (pullback.fst : pullback f g ‚ü∂ X) :=
begin
  rw (hP.affine_open_cover_tfae (pullback.fst : pullback f g ‚ü∂ X)).out 0 1,
  use [X.affine_cover, infer_instance],
  intro i,
  let e := pullback_symmetry _ _ ‚â™‚â´ pullback_right_pullback_fst_iso f g (X.affine_cover.map i),
  have : e.hom ‚â´ pullback.fst = pullback.snd := by simp,
  rw [‚Üê this, hP.1.cancel_left_is_iso],
  apply hP'; assumption,
end

lemma affine_target_morphism_property.is_local.stable_under_base_change
  {P : affine_target_morphism_property} (hP : P.is_local) (hP' : P.stable_under_base_change) :
  stable_under_base_change (target_affine_locally P) :=
begin
  introv X H,
  rw (hP.open_cover_tfae (pullback.fst : pullback f g ‚ü∂ X)).out 0 1,
  use S.affine_cover.pullback_cover f,
  intro i,
  rw (hP.affine_open_cover_tfae g).out 0 3 at H,
  let e : pullback (pullback.fst : pullback f g ‚ü∂ _) ((S.affine_cover.pullback_cover f).map i) ‚âÖ
    _,
  { refine pullback_symmetry _ _ ‚â™‚â´ pullback_right_pullback_fst_iso f g _ ‚â™‚â´
      _ ‚â™‚â´
      (pullback_right_pullback_fst_iso (S.affine_cover.map i) g
        (pullback.snd : pullback f (S.affine_cover.map i) ‚ü∂ _)).symm,
    exact as_iso (pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _)
      (by simpa using pullback.condition) (by simp)) },
  have : e.hom ‚â´ pullback.fst = pullback.snd := by simp,
  rw [‚Üê this, (target_affine_locally_respects_iso hP.1).cancel_left_is_iso],
  apply hP.affine_pullback_snd_of_left hP',
  rw [‚Üê pullback_symmetry_hom_comp_snd, hP.1.cancel_left_is_iso],
  apply H
end

end algebraic_geometry

open category_theory category_theory.limits opposite topological_space

namespace category_theory.limits.pullback

variables {C : Type*} [category C]

def pullback.congr {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    pullback f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ :=
as_iso (pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simpa using e‚ÇÅ) (by simpa using e‚ÇÇ))

@[simp, reassoc]
lemma pullback.congr_hom_fst {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congr e‚ÇÅ e‚ÇÇ).hom ‚â´ pullback.fst = pullback.fst :=
by { delta pullback.congr, simp }

@[simp, reassoc]
lemma pullback.congr_hom_snd {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congr e‚ÇÅ e‚ÇÇ).hom ‚â´ pullback.snd = pullback.snd :=
by { delta pullback.congr, simp }

@[simp, reassoc]
lemma pullback.congr_inv_fst {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congr e‚ÇÅ e‚ÇÇ).inv ‚â´ pullback.fst = pullback.fst :=
by rw [iso.inv_comp_eq, pullback.congr_hom_fst]

@[simp, reassoc]
lemma pullback.congr_inv_snd {C : Type*} [category C] {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (e‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (e‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congr e‚ÇÅ e‚ÇÇ).inv ‚â´ pullback.snd = pullback.snd :=
by rw [iso.inv_comp_eq, pullback.congr_hom_snd]

section

variables {X Y : C} (f : X ‚ü∂ Y) [has_pullback f f]

def diagonal : X ‚ü∂ pullback f f :=
pullback.lift (ùüô _) (ùüô _) rfl

@[simp, reassoc] lemma diagonal_fst : diagonal f ‚â´ pullback.fst = ùüô _ :=
pullback.lift_fst _ _ _

@[simp, reassoc] lemma diagonal_snd : diagonal f ‚â´ pullback.snd = ùüô _ :=
pullback.lift_snd _ _ _

instance : split_mono (diagonal f) :=
‚ü®pullback.fst, diagonal_fst f‚ü©

instance : split_epi (pullback.fst : pullback f f ‚ü∂ X) :=
‚ü®diagonal f, diagonal_fst f‚ü©

instance : split_epi (pullback.snd : pullback f f ‚ü∂ X) :=
‚ü®diagonal f, diagonal_snd f‚ü©

instance [mono f] : is_iso (diagonal f) :=
begin
  rw (is_iso.inv_eq_of_inv_hom_id (diagonal_fst f)).symm,
  apply_instance
end

end

variables [has_pullbacks C] {X Y U V‚ÇÅ V‚ÇÇ : C} (f : X ‚ü∂ Y) (i : U ‚ü∂ Y)
variables (i‚ÇÅ : V‚ÇÅ ‚ü∂ pullback f i) (i‚ÇÇ : V‚ÇÇ ‚ü∂ pullback f i)

@[simp, reassoc]
lemma pullback_diagonal_map_snd_fst_fst :
  (pullback.snd : pullback (diagonal f) (map (i‚ÇÅ ‚â´ snd) (i‚ÇÇ ‚â´ snd) f f (i‚ÇÅ ‚â´ fst) (i‚ÇÇ ‚â´ fst) i
    (by simp [condition]) (by simp [condition])) ‚ü∂ _) ‚â´ fst ‚â´ i‚ÇÅ ‚â´ fst = pullback.fst :=
begin
  conv_rhs { rw ‚Üê category.comp_id pullback.fst },
  rw [‚Üê diagonal_fst f, pullback.condition_assoc, pullback.lift_fst]
end

@[simp, reassoc]
lemma pullback_diagonal_map_snd_snd_fst :
  (pullback.snd : pullback (diagonal f) (map (i‚ÇÅ ‚â´ snd) (i‚ÇÇ ‚â´ snd) f f (i‚ÇÅ ‚â´ fst) (i‚ÇÇ ‚â´ fst) i
    (by simp [condition]) (by simp [condition])) ‚ü∂ _) ‚â´ snd ‚â´ i‚ÇÇ ‚â´ fst = pullback.fst :=
begin
  conv_rhs { rw ‚Üê category.comp_id pullback.fst },
  rw [‚Üê diagonal_snd f, pullback.condition_assoc, pullback.lift_snd]
end

/--
This iso witnesses the fact that
given `f : X ‚ü∂ Y`, `i : U ‚ü∂ Y`, and `i‚ÇÅ : V‚ÇÅ ‚ü∂ X √ó[Y] U`, `i‚ÇÇ : V‚ÇÇ ‚ü∂ X √ó[Y] U`, the diagram

V‚ÇÅ √ó[X √ó[Y] U] V‚ÇÇ ‚ü∂ V‚ÇÅ √ó[U] V‚ÇÇ
        |                 |
        |                 |
        ‚Üì                 ‚Üì
        X         ‚ü∂  X √ó[Y] X

is a pullback square.
-/
def pullback_diagonal_map_iso :
  pullback (diagonal f) (map (i‚ÇÅ ‚â´ snd) (i‚ÇÇ ‚â´ snd) f f (i‚ÇÅ ‚â´ fst) (i‚ÇÇ ‚â´ fst) i
    (by simp [condition]) (by simp [condition])) ‚âÖ pullback i‚ÇÅ i‚ÇÇ :=
{ hom := pullback.lift (pullback.snd ‚â´ pullback.fst) (pullback.snd ‚â´ pullback.snd)
    begin
      ext; simp only [category.assoc, pullback.condition, pullback_diagonal_map_snd_fst_fst,
        pullback_diagonal_map_snd_snd_fst],
    end,
  inv := pullback.lift (pullback.fst ‚â´ i‚ÇÅ ‚â´ pullback.fst) (pullback.map _ _ _ _ (ùüô _) (ùüô _)
      pullback.snd (category.id_comp _).symm (category.id_comp _).symm)
    begin
      ext; simp only [diagonal_fst, diagonal_snd, category.comp_id, pullback.condition_assoc,
        category.assoc, lift_fst, lift_fst_assoc, lift_snd, lift_snd_assoc],
    end,
  hom_inv_id' := by ext; simp only [category.id_comp, category.assoc, lift_fst_assoc,
    pullback_diagonal_map_snd_fst_fst, lift_fst, lift_snd, category.comp_id],
  inv_hom_id' := by ext; simp }
.

@[simp, reassoc]
lemma pullback_diagonal_map_iso_hom_fst :
  (pullback_diagonal_map_iso f i i‚ÇÅ i‚ÇÇ).hom ‚â´ pullback.fst = pullback.snd ‚â´ pullback.fst :=
by { delta pullback_diagonal_map_iso, simp }

@[simp, reassoc]
lemma pullback_diagonal_map_iso_hom_snd :
  (pullback_diagonal_map_iso f i i‚ÇÅ i‚ÇÇ).hom ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd :=
by { delta pullback_diagonal_map_iso, simp }

@[simp, reassoc]
lemma pullback_diagonal_map_iso_inv_fst :
  (pullback_diagonal_map_iso f i i‚ÇÅ i‚ÇÇ).inv ‚â´ pullback.fst = pullback.fst ‚â´ i‚ÇÅ ‚â´ pullback.fst :=
by { delta pullback_diagonal_map_iso, simp }

@[simp, reassoc]
lemma pullback_diagonal_map_iso_inv_snd_fst :
  (pullback_diagonal_map_iso f i i‚ÇÅ i‚ÇÇ).inv ‚â´ pullback.snd ‚â´ pullback.fst = pullback.fst :=
by { delta pullback_diagonal_map_iso, simp }

@[simp, reassoc]
lemma pullback_diagonal_map_iso_inv_snd_snd :
  (pullback_diagonal_map_iso f i i‚ÇÅ i‚ÇÇ).inv ‚â´ pullback.snd ‚â´ pullback.snd = pullback.snd :=
by { delta pullback_diagonal_map_iso, simp }

/-- The canonical map `X √ó[T] Y ‚ü∂ X √ó[S] Y`. -/
abbreviation map_desc {X Y S T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) :
  pullback f g ‚ü∂ pullback (f ‚â´ i) (g ‚â´ i) :=
pullback.map f g (f ‚â´ i) (g ‚â´ i) (ùüô _) (ùüô _) i (category.id_comp _).symm (category.id_comp _).symm

/--
This iso witnesses the fact that
given `f : X ‚ü∂ T`, `g : Y ‚ü∂ T`, and `i : T ‚ü∂ S`, the diagram

X √ó[T] Y ‚ü∂ X √ó[S] Y
   |            |
   |            |
   ‚Üì            ‚Üì
   T     ‚ü∂  T √ó[S] T

is a pullback square.
-/
def pullback_diagonal_map_id_iso {X Y S T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) :
  pullback (diagonal i) (pullback.map (f ‚â´ i) (g ‚â´ i) i i f g (ùüô _)
    (category.comp_id _) (category.comp_id _)) ‚âÖ pullback f g :=
begin
  refine (as_iso $ pullback.map _ _ _ _ (ùüô _) (pullback.congr_hom _ _).hom (ùüô _) _ _) ‚â™‚â´
    pullback_diagonal_map_iso i (ùüô _) (f ‚â´ inv pullback.fst) (g ‚â´ inv pullback.fst) ‚â™‚â´
      (as_iso $ pullback.map _ _ _ _ (ùüô _) (ùüô _) pullback.fst _ _),
  { rw [‚Üê category.comp_id pullback.snd, ‚Üê condition, category.assoc, is_iso.inv_hom_id_assoc] },
  { rw [‚Üê category.comp_id pullback.snd, ‚Üê condition, category.assoc, is_iso.inv_hom_id_assoc] },
  { rw [category.comp_id, category.id_comp] },
  { ext; simp },
  { apply_instance },
  { rw [category.assoc, category.id_comp, is_iso.inv_hom_id, category.comp_id] },
  { rw [category.assoc, category.id_comp, is_iso.inv_hom_id, category.comp_id] },
  { apply_instance },
end

@[simp, reassoc]
lemma pullback_diagonal_map_id_iso_hom_fst {X Y S T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) :
  (pullback_diagonal_map_id_iso f g i).hom ‚â´ pullback.fst = pullback.snd ‚â´ pullback.fst :=
by { delta pullback_diagonal_map_id_iso, simp }

@[simp, reassoc]
lemma pullback_diagonal_map_id_iso_hom_snd {X Y S T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) :
  (pullback_diagonal_map_id_iso f g i).hom ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd :=
by { delta pullback_diagonal_map_id_iso, simp }

@[simp, reassoc]
lemma pullback_diagonal_map_id_iso_inv_fst {X Y S T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) :
  (pullback_diagonal_map_id_iso f g i).inv ‚â´ pullback.fst = pullback.fst ‚â´ f :=
begin
  rw [iso.inv_comp_eq, ‚Üê category.comp_id pullback.fst, ‚Üê diagonal_fst i, pullback.condition_assoc],
  simp,
end

@[simp, reassoc]
lemma pullback_diagonal_map_id_iso_inv_snd_fst {X Y S T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) :
  (pullback_diagonal_map_id_iso f g i).inv ‚â´ pullback.snd ‚â´ pullback.fst = pullback.fst :=
by { rw iso.inv_comp_eq, simp }

@[simp, reassoc]
lemma pullback_diagonal_map_id_iso_inv_snd_snd {X Y S T : C} (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) :
  (pullback_diagonal_map_id_iso f g i).inv ‚â´ pullback.snd ‚â´ pullback.snd = pullback.snd :=
by { rw iso.inv_comp_eq, simp }

lemma diagonal_comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  diagonal (f ‚â´ g) = diagonal f ‚â´ (pullback_diagonal_map_id_iso f f g).inv ‚â´ pullback.snd :=
by ext; simp

def diagonal_obj_pullback_fst_iso {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  pullback (pullback.fst : pullback f g ‚ü∂ _) (pullback.fst : pullback f g ‚ü∂ _) ‚âÖ
    pullback (pullback.snd ‚â´ g : pullback g g ‚ü∂ _) f :=
pullback_right_pullback_fst_iso _ _ _ ‚â™‚â´ pullback.congr pullback.condition rfl ‚â™‚â´
  pullback_assoc _ _ _ _ ‚â™‚â´ pullback_symmetry _ _ ‚â™‚â´ pullback.congr pullback.condition rfl

@[simp, reassoc] lemma diagonal_obj_pullback_fst_iso_hom_fst_fst {X Y Z : C} (f : X ‚ü∂ Z)
  (g : Y ‚ü∂ Z) :
  (diagonal_obj_pullback_fst_iso f g).hom ‚â´ pullback.fst ‚â´ pullback.fst =
    pullback.fst ‚â´ pullback.snd :=
by { delta diagonal_obj_pullback_fst_iso, simp }

@[simp, reassoc] lemma diagonal_obj_pullback_fst_iso_hom_fst_snd {X Y Z : C} (f : X ‚ü∂ Z)
  (g : Y ‚ü∂ Z) :
  (diagonal_obj_pullback_fst_iso f g).hom ‚â´ pullback.fst ‚â´ pullback.snd =
    pullback.snd ‚â´ pullback.snd :=
by { delta diagonal_obj_pullback_fst_iso, simp }

@[simp, reassoc] lemma diagonal_obj_pullback_fst_iso_hom_snd {X Y Z : C} (f : X ‚ü∂ Z)
  (g : Y ‚ü∂ Z) :
  (diagonal_obj_pullback_fst_iso f g).hom ‚â´ pullback.snd = pullback.fst ‚â´ pullback.fst :=
by { delta diagonal_obj_pullback_fst_iso, simp }

@[simp, reassoc] lemma diagonal_obj_pullback_fst_iso_inv_fst_fst {X Y Z : C} (f : X ‚ü∂ Z)
  (g : Y ‚ü∂ Z) :
  (diagonal_obj_pullback_fst_iso f g).inv ‚â´ pullback.fst ‚â´ pullback.fst =
    pullback.snd :=
by { delta diagonal_obj_pullback_fst_iso, simp }

@[simp, reassoc] lemma diagonal_obj_pullback_fst_iso_inv_fst_snd {X Y Z : C} (f : X ‚ü∂ Z)
  (g : Y ‚ü∂ Z) :
  (diagonal_obj_pullback_fst_iso f g).inv ‚â´ pullback.fst ‚â´ pullback.snd =
    pullback.fst ‚â´ pullback.fst :=
by { delta diagonal_obj_pullback_fst_iso, simp }

@[simp, reassoc] lemma diagonal_obj_pullback_fst_iso_inv_snd_fst {X Y Z : C} (f : X ‚ü∂ Z)
  (g : Y ‚ü∂ Z) :
  (diagonal_obj_pullback_fst_iso f g).inv ‚â´ pullback.snd ‚â´ pullback.fst = pullback.snd :=
by { delta diagonal_obj_pullback_fst_iso, simp }

@[simp, reassoc] lemma diagonal_obj_pullback_fst_iso_inv_snd_snd {X Y Z : C} (f : X ‚ü∂ Z)
  (g : Y ‚ü∂ Z) :
  (diagonal_obj_pullback_fst_iso f g).inv ‚â´ pullback.snd ‚â´ pullback.snd =
    pullback.fst ‚â´ pullback.snd :=
by { delta diagonal_obj_pullback_fst_iso, simp }

lemma diagonal_pullback_fst {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  diagonal (pullback.fst : pullback f g ‚ü∂ _) =
    (pullback_symmetry _ _).hom ‚â´ ((base_change f).map
      (over.hom_mk (diagonal g) (by simp) : over.mk g ‚ü∂ over.mk (pullback.snd ‚â´ g))).left ‚â´
    (diagonal_obj_pullback_fst_iso f g).inv :=
by ext; simp

/--
Given the following diagram with `S ‚ü∂ S'` a monomorphism,

    X  ‚ü∂ X'
      ‚Üò      ‚Üò
        S  ‚ü∂ S'
      ‚Üó      ‚Üó
    Y  ‚ü∂ Y'

This iso witnesses the fact that

      X √ó[S] Y ‚ü∂ (X' √ó[S'] Y') √ó[X'] X
          |                  |
          |                  |
          ‚Üì                  ‚Üì
(X' √ó[S'] Y') √ó[X'] X ‚ü∂ X' √ó[S'] Y'

is a pullback square. The diagonal map of this square is `pullback.map`.

-/
@[simps]
def pullback_fst_fst_iso {X Y S X' Y' S' : C} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) (f' : X' ‚ü∂ S')
  (g' : Y' ‚ü∂ S') (i‚ÇÅ : X ‚ü∂ X') (i‚ÇÇ : Y ‚ü∂ Y') (i‚ÇÉ : S ‚ü∂ S') (e‚ÇÅ : f ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ f')
  (e‚ÇÇ : g ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g') [mono i‚ÇÉ] :
    pullback (pullback.fst : pullback (pullback.fst : pullback f' g' ‚ü∂ _) i‚ÇÅ ‚ü∂ _)
      (pullback.fst : pullback (pullback.snd : pullback f' g' ‚ü∂ _) i‚ÇÇ ‚ü∂ _) ‚âÖ pullback f g :=
{ hom := pullback.lift (pullback.fst ‚â´ pullback.snd) (pullback.snd ‚â´ pullback.snd)
    begin
      rw [‚Üê cancel_mono i‚ÇÉ, category.assoc, category.assoc, category.assoc, category.assoc, e‚ÇÅ, e‚ÇÇ,
        ‚Üê pullback.condition_assoc, pullback.condition_assoc, pullback.condition,
        pullback.condition_assoc]
    end,
  inv := pullback.lift
    (pullback.lift (pullback.map _ _ _ _ _ _ _ e‚ÇÅ e‚ÇÇ) pullback.fst (pullback.lift_fst _ _ _))
    (pullback.lift (pullback.map _ _ _ _ _ _ _ e‚ÇÅ e‚ÇÇ) pullback.snd (pullback.lift_snd _ _ _))
    begin
      rw [pullback.lift_fst, pullback.lift_fst]
    end,
  hom_inv_id' := by ext; simp only [category.assoc, category.id_comp, lift_fst, lift_snd,
    lift_fst_assoc, lift_snd_assoc, condition, ‚Üê condition_assoc],
  inv_hom_id' := by ext; simp only [category.assoc, category.id_comp, lift_fst, lift_snd,
    lift_fst_assoc, lift_snd_assoc], }

lemma pullback_map_eq_pullback_fst_fst_iso_inv {X Y S X' Y' S' : C} (f : X ‚ü∂ S) (g : Y ‚ü∂ S)
  (f' : X' ‚ü∂ S')
  (g' : Y' ‚ü∂ S') (i‚ÇÅ : X ‚ü∂ X') (i‚ÇÇ : Y ‚ü∂ Y') (i‚ÇÉ : S ‚ü∂ S') (e‚ÇÅ : f ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ f')
  (e‚ÇÇ : g ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g') [mono i‚ÇÉ] :
  pullback.map f g f' g' i‚ÇÅ i‚ÇÇ i‚ÇÉ e‚ÇÅ e‚ÇÇ =
    (pullback_fst_fst_iso f g f' g' i‚ÇÅ i‚ÇÇ i‚ÇÉ e‚ÇÅ e‚ÇÇ).inv ‚â´ pullback.snd ‚â´ pullback.fst :=
begin
  ext; simp only [category.assoc, category.id_comp, lift_fst, lift_snd, lift_fst_assoc,
    lift_snd_assoc, pullback_fst_fst_iso_inv, ‚Üê pullback.condition, ‚Üê pullback.condition_assoc],
end

end category_theory.limits.pullback

open category_theory.limits

namespace algebraic_geometry

instance {X Y S X' Y' S' : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S)
  (f' : X' ‚ü∂ S')
  (g' : Y' ‚ü∂ S') (i‚ÇÅ : X ‚ü∂ X') (i‚ÇÇ : Y ‚ü∂ Y') (i‚ÇÉ : S ‚ü∂ S') (e‚ÇÅ : f ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ f')
  (e‚ÇÇ : g ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g') [is_open_immersion i‚ÇÅ] [is_open_immersion i‚ÇÇ] [mono i‚ÇÉ] :
  is_open_immersion (pullback.map f g f' g' i‚ÇÅ i‚ÇÇ i‚ÇÉ e‚ÇÅ e‚ÇÇ) :=
begin
  rw pullback.pullback_map_eq_pullback_fst_fst_iso_inv,
  apply_instance
end

lemma is_open_immersion.range_pullback_map {X Y S X' Y' S' : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S)
  (f' : X' ‚ü∂ S')
  (g' : Y' ‚ü∂ S') (i‚ÇÅ : X ‚ü∂ X') (i‚ÇÇ : Y ‚ü∂ Y') (i‚ÇÉ : S ‚ü∂ S') (e‚ÇÅ : f ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ f')
  (e‚ÇÇ : g ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g') [is_open_immersion i‚ÇÅ] [is_open_immersion i‚ÇÇ] [mono i‚ÇÉ] :
  set.range (pullback.map f g f' g' i‚ÇÅ i‚ÇÇ i‚ÇÉ e‚ÇÅ e‚ÇÇ).1.base =
    (pullback.fst : pullback f' g' ‚ü∂ _).1.base ‚Åª¬π' (set.range i‚ÇÅ.1.base) ‚à©
    (pullback.snd : pullback f' g' ‚ü∂ _).1.base ‚Åª¬π' (set.range i‚ÇÇ.1.base) :=
begin
  rw [pullback.pullback_map_eq_pullback_fst_fst_iso_inv, Scheme.comp_val_base, coe_comp,
    set.range_comp, set.range_iff_surjective.mpr, set.image_univ, Scheme.comp_val_base, coe_comp,
    set.range_comp, is_open_immersion.range_pullback_snd_of_left, opens.map_obj, subtype.coe_mk,
    set.image_preimage_eq_inter_range, is_open_immersion.range_pullback_fst_of_right,
    is_open_immersion.range_pullback_fst_of_right],
  refl,
  rw ‚Üê Top.epi_iff_surjective, apply_instance,
end

def diagonal_is (P : morphism_property) : morphism_property :=
Œª X Y f, P (pullback.diagonal f)

lemma diagonal_is_respects_iso  (P : morphism_property)
  (hP : respects_iso P) : respects_iso (diagonal_is P) :=
begin
  split,
  { introv H,
    delta diagonal_is at *,
    rwa [pullback.diagonal_comp, hP.cancel_left_is_iso, hP.cancel_left_is_iso,
      ‚Üê hP.cancel_right_is_iso _ _, ‚Üê pullback.condition, hP.cancel_left_is_iso],
    apply_instance },
  { introv H,
    delta diagonal_is at *,
    rwa [pullback.diagonal_comp, hP.cancel_right_is_iso] }
end

lemma diagonal_is_stable_under_composition  (P : morphism_property)
  (hP : stable_under_base_change P) (hP' : respects_iso P) (hP'' : stable_under_composition P) :
  stable_under_composition (diagonal_is P) :=
begin
  introv X h‚ÇÅ h‚ÇÇ,
  delta diagonal_is at *,
  rw pullback.diagonal_comp,
  apply hP'', { assumption },
  rw hP'.cancel_left_is_iso,
  apply hP.symmetry hP',
  assumption
end

lemma diagonal_is_stable_under_base_change  (P : morphism_property)
  (hP : stable_under_base_change P) (hP' : respects_iso P) :
  stable_under_base_change (diagonal_is P) :=
begin
  introv X h,
  delta diagonal_is at *,
  rw [pullback.diagonal_pullback_fst, hP'.cancel_left_is_iso, hP'.cancel_right_is_iso],
  convert hP.base_change_map hP' f _ _; simp; assumption
end

/-- Given an open cover `{ Y·µ¢ }` of `Y`, then `X √ó[Z] Y` is covered by `X √ó[Z] Y·µ¢`. -/
@[simps J obj map]
def Scheme.pullback.open_cover_of_left_right {X Y Z : Scheme} (ùí∞X : X.open_cover) (ùí∞Y : Y.open_cover)
  (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (pullback f g).open_cover :=
begin
  fapply ((Scheme.pullback.open_cover_of_left ùí∞X f g).bind
    (Œª x, Scheme.pullback.open_cover_of_right ùí∞Y (ùí∞X.map x ‚â´ f) g)).copy
    (ùí∞X.J √ó ùí∞Y.J)
    (Œª ij, pullback (ùí∞X.map ij.1 ‚â´ f) (ùí∞Y.map ij.2 ‚â´ g))
    (Œª ij, pullback.map _ _ _ _ (ùí∞X.map ij.1) (ùí∞Y.map ij.2) (ùüô _)
      (category.comp_id _) (category.comp_id _))
    (equiv.sigma_equiv_prod _ _).symm
    (Œª _, iso.refl _),
  rintro ‚ü®i, j‚ü©,
  apply pullback.hom_ext; simpa,
end

lemma diagonal_is_target_affine_locally_of_open_cover (P : affine_target_morphism_property)
  (hP : P.is_local)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y)
  (ùí∞ : Scheme.open_cover.{u} Y)
  [‚àÄ i, is_affine (ùí∞.obj i)] (ùí∞' : Œ† i, Scheme.open_cover.{u} (pullback f (ùí∞.map i)))
  [‚àÄ i j, is_affine ((ùí∞' i).obj j)]
  (hùí∞' : ‚àÄ i j k, P (pullback.map_desc ((ùí∞' i).map j) ((ùí∞' i).map k) pullback.snd)) :
    diagonal_is (target_affine_locally P) f :=
begin
  refine (hP.affine_open_cover_iff _ _).mpr _,
  { exact ((Scheme.pullback.open_cover_of_base ùí∞ f f).bind (Œª i,
      Scheme.pullback.open_cover_of_left_right.{u u} (ùí∞' i) (ùí∞' i) pullback.snd pullback.snd)) },
  { intro i,
    dsimp at *,
    apply_instance },
  { rintro ‚ü®i, j, k‚ü©,
    dsimp,
    convert (hP.1.cancel_left_is_iso
     (pullback.pullback_diagonal_map_iso _ _ ((ùí∞' i).map j) ((ùí∞' i).map k)).inv pullback.snd).mp _,
    swap 3,
    { convert hùí∞' i j k, apply pullback.hom_ext; simp, },
    all_goals
    { apply pullback.hom_ext; simp only [category.assoc, pullback.lift_fst, pullback.lift_snd,
      pullback.lift_fst_assoc, pullback.lift_snd_assoc] } }
end

lemma is_open_immersion.range_pullback_one {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S)
  [is_open_immersion f] [is_open_immersion g] :
    set.range (pullback.fst ‚â´ f : pullback f g ‚ü∂ S).1.base =
      set.range f.1.base ‚à© set.range g.1.base :=
begin
  rw [Scheme.comp_val_base, coe_comp, set.range_comp,
    is_open_immersion.range_pullback_fst_of_right, opens.map_obj, subtype.coe_mk,
    set.image_preimage_eq_inter_range, set.inter_comm],
end

def diagonal_is.affine_property (P : affine_target_morphism_property) :
  affine_target_morphism_property :=
Œª X Y f hf, ‚àÄ {U‚ÇÅ U‚ÇÇ : Scheme} (f‚ÇÅ : U‚ÇÅ ‚ü∂ X) (f‚ÇÇ : U‚ÇÇ ‚ü∂ X) [is_affine U‚ÇÅ] [is_affine U‚ÇÇ]
  [is_open_immersion f‚ÇÅ] [is_open_immersion f‚ÇÇ],
  by exactI P (pullback.map_desc f‚ÇÅ f‚ÇÇ f)

/-- The canonical map `X √ó[T] Y ‚ü∂ X √ó[S] Y`. -/
abbreviation pullback.map_desc_comp {C : Type*} [category C] [has_pullbacks C] {X Y S T S' : C}
  (f : X ‚ü∂ T) (g : Y ‚ü∂ T) (i : T ‚ü∂ S) (i' : S ‚ü∂ S') :
  pullback.map_desc f g (i ‚â´ i') = pullback.map_desc f g i ‚â´ pullback.map_desc _ _ i' ‚â´
    (pullback.congr (category.assoc _ _ _) (category.assoc _ _ _)).hom :=
by { ext; simp, }


lemma diagonal_is.affine_property_respects_iso (P : affine_target_morphism_property)
  (hP : P.respects_iso) :
  (diagonal_is.affine_property P).respects_iso :=
begin
  delta diagonal_is.affine_property,
  split,
  { introv H _ _,
    resetI,
    rw [pullback.map_desc_comp, hP.cancel_left_is_iso, hP.cancel_right_is_iso],
    apply H },
  { introv H _ _,
    resetI,
    rw [pullback.map_desc_comp, hP.cancel_right_is_iso],
    apply H }
end

lemma diagonal_is_affine_property_of_diagonal_is (P : affine_target_morphism_property)
  (hP : P.is_local) {X Y U : Scheme.{u}} (f : X ‚ü∂ Y) (g : U ‚ü∂ Y)
  [is_affine U] [is_open_immersion g] (H : diagonal_is (target_affine_locally P) f) :
    diagonal_is.affine_property P (pullback.snd : pullback f g ‚ü∂ _) :=
begin
  rintros U V f‚ÇÅ f‚ÇÇ _ _ _ _,
  resetI,
  replace H := ((hP.affine_open_cover_tfae (pullback.diagonal f)).out 0 3).mp H,
  let g‚ÇÅ := pullback.map (f‚ÇÅ ‚â´ pullback.snd)
    (f‚ÇÇ ‚â´ pullback.snd) f f
    (f‚ÇÅ ‚â´ pullback.fst)
    (f‚ÇÇ ‚â´ pullback.fst) g
    (by rw [category.assoc, category.assoc, pullback.condition])
    (by rw [category.assoc, category.assoc, pullback.condition]),
  let g‚ÇÇ : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ pullback f g := pullback.fst ‚â´ f‚ÇÅ,
  specialize H g‚ÇÅ,
  rw ‚Üê hP.1.cancel_left_is_iso (pullback.pullback_diagonal_map_iso f _ f‚ÇÅ f‚ÇÇ).hom,
  convert H,
  { apply pullback.hom_ext; simp only [category.assoc, pullback.lift_fst, pullback.lift_snd,
    pullback.lift_fst_assoc, pullback.lift_snd_assoc, category.comp_id,
    pullback.pullback_diagonal_map_iso_hom_fst, pullback.pullback_diagonal_map_iso_hom_snd], }
end

lemma diagonal_is_affine_property.affine_open_cover_tfae (P : affine_target_morphism_property)
  (hP : P.is_local) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
  tfae [diagonal_is (target_affine_locally P) f,
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)], by exactI
      ‚àÄ (i : ùí∞.J), diagonal_is.affine_property P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _),
    ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)] (i : ùí∞.J), by exactI
      diagonal_is.affine_property P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _),
    ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_affine U] [is_open_immersion g], by exactI
      diagonal_is.affine_property P (pullback.snd : pullback f g ‚ü∂ _),
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)]
      (ùí∞' : Œ† i, Scheme.open_cover.{u} (pullback f (ùí∞.map i))) [‚àÄ i j, is_affine ((ùí∞' i).obj j)],
    by exactI ‚àÄ i j k, P (pullback.map_desc ((ùí∞' i).map j) ((ùí∞' i).map k) pullback.snd)] :=
begin
  tfae_have : 1 ‚Üí 4,
  { introv H hU hg, resetI, apply diagonal_is_affine_property_of_diagonal_is; assumption },
  tfae_have : 4 ‚Üí 3,
  { introv H hùí∞, resetI, apply H },
  tfae_have : 3 ‚Üí 2,
  { exact Œª H, ‚ü®Y.affine_cover, infer_instance, H Y.affine_cover‚ü© },
  tfae_have : 2 ‚Üí 5,
  { rintro ‚ü®ùí∞, hùí∞, H‚ü©,
    resetI,
    refine ‚ü®ùí∞, infer_instance, Œª _, Scheme.affine_cover _, infer_instance, _‚ü©,
    intros i j k,
    apply H },
  tfae_have : 5 ‚Üí 1,
  { rintro ‚ü®ùí∞, _, ùí∞', _, H‚ü©,
    exactI diagonal_is_target_affine_locally_of_open_cover P hP f ùí∞ ùí∞' H, },
  tfae_finish
end

lemma diagonal_is_affine_property.is_local (P : affine_target_morphism_property)
  (hP : P.is_local) : (diagonal_is.affine_property P).is_local :=
affine_target_morphism_property.is_local_of_open_cover_imply
  (diagonal_is.affine_property P)
  (diagonal_is.affine_property_respects_iso P hP.1)
  (Œª _ _ f, ((diagonal_is_affine_property.affine_open_cover_tfae P hP f).out 1 3).mp)

lemma diagonal_is_eq_diagonal_is_affine_property (P : affine_target_morphism_property)
  (hP : P.is_local) :
    diagonal_is (target_affine_locally P) = target_affine_locally (diagonal_is.affine_property P) :=
begin
  ext _ _ f,
  exact ((diagonal_is_affine_property.affine_open_cover_tfae P hP f).out 0 1).trans
    ( ((diagonal_is_affine_property.is_local P hP).affine_open_cover_tfae f).out 1 0),
end

end algebraic_geometry
