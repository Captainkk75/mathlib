/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import algebraic_geometry.morphisms.basic

/-!
# Quasi-compact morphisms

A morphism of schemes is quasi-compact if the preimages of quasi-compact open sets are
quasi-compact.

It suffices to check that preimages of affine open sets are compact
(`quasi_compact_iff_forall_affine`).

We show that this property is local, and is stable under compositions and base-changes.

-/

noncomputable theory

open category_theory category_theory.limits opposite topological_space

universe u

namespace algebraic_geometry

variables {X Y : Scheme.{u}} (f : X ‚ü∂ Y)

/--
A morphism is `quasi-compact` if the underlying map of topological spaces is, i.e. if the preimages
of quasi-compact open sets are quasi-compact.
-/
@[mk_iff]
class quasi_compact (f : X ‚ü∂ Y) : Prop :=
(is_compact_preimage : ‚àÄ U : set Y.carrier, is_open U ‚Üí is_compact U ‚Üí is_compact (f.1.base ‚Åª¬π' U))

def quasi_compact.affine_property : affine_target_morphism_property :=
Œª X Y f hf, compact_space X.carrier

@[simp] lemma quasi_compact_affine_property_to_property {X Y : Scheme} (f : X ‚ü∂ Y) :
  affine_target_morphism_property.to_property quasi_compact.affine_property f ‚Üî
    is_affine Y ‚àß compact_space X.carrier :=
by { delta affine_target_morphism_property.to_property quasi_compact.affine_property, simp }

@[priority 900]
instance quasi_compact_of_is_iso {X Y : Scheme} (f : X ‚ü∂ Y) [is_iso f] : quasi_compact f :=
begin
  constructor,
  intros U hU hU',
  convert hU'.image (inv f.1.base).continuous_to_fun using 1,
  rw set.image_eq_preimage_of_inverse,
  delta function.left_inverse,
  exacts [is_iso.inv_hom_id_apply f.1.base, is_iso.hom_inv_id_apply f.1.base]
end

instance quasi_compact_comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z)
  [quasi_compact f] [quasi_compact g] : quasi_compact (f ‚â´ g) :=
begin
  constructor,
  intros U hU hU',
  rw [Scheme.comp_val_base, coe_comp, set.preimage_comp],
  apply quasi_compact.is_compact_preimage,
  { exact continuous.is_open_preimage (by continuity) _ hU },
  apply quasi_compact.is_compact_preimage; assumption
end

/-- If `Œ±` has a basis consisting of compact opens, then an open set in `Œ±` is compact open iff
  it is a finite union of some elements in the basis -/
lemma is_compact_open_iff_eq_finset_Union_of_is_topological_basis {Œ± : Type*} [topological_space Œ±]
  {Œπ : Type*} (b : Œπ ‚Üí set Œ±) (hb : is_topological_basis (set.range b))
  (hb' : ‚àÄ i, is_compact (b i)) (U : set Œ±) :
  is_compact U ‚àß is_open U ‚Üî ‚àÉ (s : finset Œπ), U = ‚ãÉ i : s, b i :=
begin
  classical,
  split,
  { rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    obtain ‚ü®Œ≤, f, e, hf‚ü© := hb.open_eq_Union h‚ÇÇ,
    choose f' hf' using hf,
    have : b ‚àò f' = f := funext hf', subst this,
    obtain ‚ü®t, ht‚ü© := h‚ÇÅ.elim_finite_subcover (b ‚àò f')
      (Œª i, hb.is_open (set.mem_range_self _)) (by rw e),
    use t.image f',
    apply le_antisymm,
    { refine set.subset.trans ht _,
      simp only [set.Union_subset_iff, coe_coe],
      intros i hi,
      exact set.subset_Union (Œª i : t.image f', b i) ‚ü®_, finset.mem_image_of_mem _ hi‚ü© },
    { apply set.Union_subset,
      rintro ‚ü®i, hi‚ü©,
      obtain ‚ü®j, hj, rfl‚ü© := finset.mem_image.mp hi,
      rw e,
      exact set.subset_Union (b ‚àò f') j } },
  { rintro ‚ü®s, rfl‚ü©,
    split,
    { convert @finset.compact_bUnion _ _ _ s.attach _ _,
      { ext y, simp },
      { exact Œª i _, hb' i } },
    { apply is_open_Union, rintro i, exact hb.is_open (set.mem_range_self _) } },
end


/-- If `Œ±` has a basis consisting of compact opens, then an open set in `Œ±` is compact open iff
  it is a finite union of some elements in the basis -/
lemma is_compact_open_iff_eq_finset_Union_of_opens_is_basis {Œ± : Type*} [topological_space Œ±]
  {Œπ : Type*} (b : Œπ ‚Üí opens Œ±) (hb : opens.is_basis (set.range b))
  (hb' : ‚àÄ i, is_compact (b i : set Œ±)) (U : set Œ±) :
  is_compact U ‚àß is_open U ‚Üî ‚àÉ (s : finset Œπ), U = ‚ãÉ i : s, b i :=
begin
  apply is_compact_open_iff_eq_finset_Union_of_is_topological_basis
    (Œª i : Œπ, (b i).1),
  { convert hb, ext, simp },
  { exact hb' }
end

lemma is_compact_open_iff_eq_finset_affine_union {X : Scheme} (U : set X.carrier) :
  is_compact U ‚àß is_open U ‚Üî ‚àÉ (s : finset X.affine_opens), U = ‚ãÉ (i : s), i :=
begin
  apply is_compact_open_iff_eq_finset_Union_of_opens_is_basis
    (coe : X.affine_opens ‚Üí opens X.carrier),
  { rw subtype.range_coe, exact is_basis_affine_open X },
  { intro i, exact i.2.is_compact }
end

lemma is_compact_open_iff_eq_basic_open_union {X : Scheme} [is_affine X] (U : set X.carrier) :
  is_compact U ‚àß is_open U ‚Üî
    ‚àÉ (s : finset (X.presheaf.obj (op ‚ä§))), U = ‚ãÉ (i : s), X.basic_open i.1 :=
begin
  apply is_compact_open_iff_eq_finset_Union_of_opens_is_basis,
  { exact is_basis_basic_open X },
  { intro i, exact ((top_is_affine_open _).basic_open_is_affine _).is_compact }
end

lemma quasi_compact_iff_forall_affine : quasi_compact f ‚Üî
  ‚àÄ U : opens Y.carrier, is_affine_open U ‚Üí is_compact (f.1.base ‚Åª¬π' (U : set Y.carrier)) :=
begin
  rw quasi_compact_iff,
  refine ‚ü®Œª H U hU, H U U.prop hU.is_compact, _‚ü©,
  intros H U hU hU',
  obtain ‚ü®S, rfl‚ü© := (is_compact_open_iff_eq_finset_affine_union U).mp ‚ü®hU', hU‚ü©,
  simp only [set.preimage_Union, subtype.val_eq_coe],
  convert S.compact_bUnion (Œª i _, H i i.prop) using 1,
  exact set.Union_subtype _ _
end

lemma quasi_compact_iff_affine_property :
  quasi_compact f ‚Üî target_affine_locally quasi_compact.affine_property f :=
begin
  rw quasi_compact_iff_forall_affine,
  transitivity (‚àÄ U : Y.affine_opens, is_compact (f.1.base ‚Åª¬π' (U : set Y.carrier))),
  { exact ‚ü®Œª h U, h U U.prop, Œª h U hU, h ‚ü®U, hU‚ü©‚ü© },
  apply forall_congr,
  exact Œª _, is_compact_iff_compact_space,
end

lemma quasi_compact_eq_affine_property :
  @quasi_compact = target_affine_locally quasi_compact.affine_property :=
by { ext, exact quasi_compact_iff_affine_property _ }

lemma is_compact_basic_open (X : Scheme) {U : opens X.carrier} (hU : is_compact (U : set X.carrier))
  (f : X.presheaf.obj (op U)) : is_compact (X.basic_open f : set X.carrier) :=
begin
  classical,
  refine ((is_compact_open_iff_eq_finset_affine_union _).mpr _).1,
  obtain ‚ü®s, hs‚ü© := (is_compact_open_iff_eq_finset_affine_union _).mp ‚ü®hU, U.prop‚ü©,
  let g : s ‚Üí X.affine_opens,
  { intro V,
    use V.1 ‚à© X.basic_open f,
    have : V.1.1 ‚ü∂ U,
    { apply hom_of_le, change _ ‚äÜ (U : set X.carrier), rw hs, exact set.subset_Union _ V },
    erw ‚Üê X.to_LocallyRingedSpace.to_RingedSpace.basic_open_res this.op,
    exact is_affine_open.basic_open_is_affine V.1.prop _ },
  use s.attach.image g,
  refine (set.inter_eq_right_iff_subset.mpr (RingedSpace.basic_open_subset _ _)).symm.trans _,
  rw [hs, set.Union_inter],
  apply le_antisymm; apply set.Union_subset,
  { intro i,
    refine set.subset.trans _
      (set.subset_Union _ (‚ü®_, finset.mem_image_of_mem g (s.mem_attach i)‚ü© : s.attach.image g)),
    exact set.subset.rfl },
  { rintro ‚ü®i, hi‚ü©,
    obtain ‚ü®j : s, hj, rfl‚ü© := finset.mem_image.mp hi,
    refine set.subset.trans _ (set.subset_Union _ j),
    exact set.subset.rfl }
end

lemma quasi_compact_affine_property_is_local :
  affine_target_morphism_property.is_local quasi_compact.affine_property :=
begin
  split,
  { split; intros X Y Z _ _ _ H,
    exacts [@@homeomorph.compact_space _ _ H (Top.homeo_of_iso (as_iso e.inv.1.base)), H] },
  { introv H,
    delta quasi_compact.affine_property at H ‚ä¢,
    change compact_space ((opens.map f.val.base).obj (Y.basic_open r)),
    rw Scheme.preimage_basic_open f r,
    erw ‚Üê is_compact_iff_compact_space,
    rw ‚Üê is_compact_univ_iff at H,
    exact is_compact_basic_open X H _ },
  { rintros X Y H f S hS hS',
    resetI,
    rw ‚Üê is_affine_open.basic_open_union_eq_self_iff at hS,
    delta quasi_compact.affine_property,
    rw ‚Üê is_compact_univ_iff,
    change is_compact ((opens.map f.val.base).obj ‚ä§).1,
    rw ‚Üê hS,
    dsimp [opens.map],
    simp only [opens.supr_s, set.preimage_Union, subtype.val_eq_coe],
    exacts [compact_Union (Œª i, is_compact_iff_compact_space.mpr (hS' i)), top_is_affine_open _] }
end

lemma Scheme.open_cover.Union_range {X : Scheme} (ùí∞ : X.open_cover) :
  (‚ãÉ i, set.range (ùí∞.map i).1.base) = set.univ :=
begin
  rw set.eq_univ_iff_forall,
  intros x,
  rw set.mem_Union,
  exact ‚ü®ùí∞.f x, ùí∞.covers x‚ü©
end

lemma Scheme.open_cover.compact_space {X : Scheme} (ùí∞ : X.open_cover) [fintype ùí∞.J]
  [H : ‚àÄ i, compact_space (ùí∞.obj i).carrier] : compact_space X.carrier :=
begin
  rw [‚Üê is_compact_univ_iff, ‚Üê ùí∞.Union_range],
  apply compact_Union,
  intro i,
  rw is_compact_iff_compact_space,
  exact @@homeomorph.compact_space _ _ (H i)
    (Top.homeo_of_iso (as_iso (is_open_immersion.iso_of_range_eq (ùí∞.map i)
    (X.of_restrict (opens.open_embedding ‚ü®_, (ùí∞.is_open i).base_open.open_range‚ü©))
    subtype.range_coe.symm).hom.1.base))
end

lemma quasi_compact_affine_property_stable_under_base_change :
  affine_target_morphism_property.stable_under_base_change quasi_compact.affine_property :=
begin
  introv X H,
  delta quasi_compact.affine_property at H ‚ä¢,
  resetI,
  apply_with Scheme.open_cover.compact_space { instances := ff },
  swap 3,
  { exact Scheme.pullback.open_cover_of_right Y.affine_cover.finite_subcover f g },
  { change fintype Y.affine_cover.finite_subcover.J,
    apply_instance },
  { intro i,
    haveI : is_affine (Y.affine_cover.finite_subcover.obj i),
    { dsimp, apply_instance },
    change compact_space (pullback f _).carrier,
    apply_instance }
end

lemma quasi_compact.affine_open_cover_tfae {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
  tfae [quasi_compact f,
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)],
      ‚àÄ (i : ùí∞.J), compact_space (pullback f (ùí∞.map i)).carrier,
    ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)] (i : ùí∞.J),
      compact_space (pullback f (ùí∞.map i)).carrier,
    ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_affine U] [is_open_immersion g],
      compact_space (pullback f g).carrier,
    ‚àÉ {Œπ : Type u} (U : Œπ ‚Üí opens Y.carrier) (hU : supr U = ‚ä§) (hU' : ‚àÄ i, is_affine_open (U i)),
      ‚àÄ i, compact_space (f.1.base ‚Åª¬π' (U i).1)] :=
quasi_compact_eq_affine_property.symm ‚ñ∏
  quasi_compact_affine_property_is_local.affine_open_cover_tfae f

lemma quasi_compact.open_cover_tfae {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
  tfae [quasi_compact f,
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y), ‚àÄ (i : ùí∞.J),
      quasi_compact (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) (i : ùí∞.J),
      quasi_compact (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ (U : opens Y.carrier), quasi_compact (f ‚à£_ U),
    ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_open_immersion g],
      quasi_compact (pullback.snd : pullback f g ‚ü∂ _),
    ‚àÉ {Œπ : Type u} (U : Œπ ‚Üí opens Y.carrier) (hU : supr U = ‚ä§), ‚àÄ i, quasi_compact (f ‚à£_ (U i))] :=
quasi_compact_eq_affine_property.symm ‚ñ∏
  quasi_compact_affine_property_is_local.open_cover_tfae f

lemma quasi_compact_over_affine_iff {X Y : Scheme} (f : X ‚ü∂ Y) [is_affine Y] :
  quasi_compact f ‚Üî compact_space X.carrier :=
quasi_compact_eq_affine_property.symm ‚ñ∏
  quasi_compact_affine_property_is_local.affine_target_iff f

lemma compact_space_iff_quasi_compact (X : Scheme) :
  compact_space X.carrier ‚Üî quasi_compact (terminal.from X) :=
(quasi_compact_over_affine_iff _).symm

lemma quasi_compact.affine_open_cover_iff {X Y : Scheme.{u}} (ùí∞ : Scheme.open_cover.{u} Y)
  [‚àÄ i, is_affine (ùí∞.obj i)] (f : X ‚ü∂ Y) :
  quasi_compact f ‚Üî ‚àÄ i, compact_space (pullback f (ùí∞.map i)).carrier :=
quasi_compact_eq_affine_property.symm ‚ñ∏
  quasi_compact_affine_property_is_local.affine_open_cover_iff f ùí∞

lemma quasi_compact.open_cover_iff {X Y : Scheme.{u}} (ùí∞ : Scheme.open_cover.{u} Y)
  [‚àÄ i, is_affine (ùí∞.obj i)] (f : X ‚ü∂ Y) :
  quasi_compact f ‚Üî ‚àÄ i, quasi_compact (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) :=
quasi_compact_eq_affine_property.symm ‚ñ∏
  quasi_compact_affine_property_is_local.open_cover_iff f ùí∞

lemma quasi_compact_stable_under_base_change :
  stable_under_base_change @quasi_compact :=
quasi_compact_eq_affine_property.symm ‚ñ∏
  quasi_compact_affine_property_is_local.stable_under_base_change
    quasi_compact_affine_property_stable_under_base_change

lemma quasi_compact_respects_iso : respects_iso @quasi_compact :=
quasi_compact_eq_affine_property.symm ‚ñ∏
  target_affine_locally_respects_iso quasi_compact_affine_property_is_local.1

lemma quasi_compact_stable_under_composition :
  stable_under_composition @quasi_compact :=
Œª _ _ _ _ _ _ _, by exactI infer_instance

instance {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [quasi_compact g] :
  quasi_compact (pullback.fst : pullback f g ‚ü∂ X) :=
quasi_compact_stable_under_base_change f g infer_instance

instance {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [quasi_compact f] :
  quasi_compact (pullback.snd : pullback f g ‚ü∂ Y) :=
quasi_compact_stable_under_base_change.symmetry quasi_compact_respects_iso f g infer_instance

lemma exists_power_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open (X : Scheme)
  {U : opens X.carrier} (hU : is_affine_open U) (x f : X.presheaf.obj (op U))
  (H : X.presheaf.map (hom_of_le $ X.basic_open_subset f : X.basic_open f ‚ü∂ U).op x = 0) :
  ‚àÉ n : ‚Ñï, f ^ n * x = 0 :=
begin
  rw ‚Üê map_zero (X.presheaf.map (hom_of_le $ X.basic_open_subset f : X.basic_open f ‚ü∂ U).op) at H,
  have := (is_localization_basic_open hU f).3,
  obtain ‚ü®‚ü®_, n, rfl‚ü©, e‚ü© := this.mp H,
  exact ‚ü®n, by simpa [mul_comm x] using e‚ü©,
end

lemma exists_power_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact (X : Scheme)
  {U : opens X.carrier} (hU : is_compact U.1) (x f : X.presheaf.obj (op U))
  (H : X.presheaf.map (hom_of_le $ X.basic_open_subset f : X.basic_open f ‚ü∂ U).op x = 0) :
  ‚àÉ n : ‚Ñï, f ^ n * x = 0 :=
begin
  obtain ‚ü®s, hs‚ü© := (is_compact_open_iff_eq_finset_affine_union U.1).mp ‚ü®hU, U.2‚ü©,
  replace hs : U = supr (Œª i : s, (i : opens X.carrier)),
  { ext1, simpa using hs, },
  have h‚ÇÅ : ‚àÄ i : s, i.1.1 ‚â§ U,
  { intro i, change (i : opens X.carrier) ‚â§ U, rw hs, exact le_supr _ _ },
  have H' := Œª (i : s), exists_power_mul_eq_zero_of_res_basic_open_eq_zero_of_is_affine_open X i.1.2
    (X.presheaf.map (hom_of_le (h‚ÇÅ i)).op x) (X.presheaf.map (hom_of_le (h‚ÇÅ i)).op f) _,
  swap,
  { convert congr_arg (X.presheaf.map (hom_of_le _).op) H,
    { simp only [‚Üê comp_apply, ‚Üê functor.map_comp], congr },
    { rw map_zero },
    { rw X.basic_open_res, exact set.inter_subset_right _ _ } },
  choose n hn using H',
  use s.attach.sup n,
  suffices : ‚àÄ (i : s), X.presheaf.map (hom_of_le (h‚ÇÅ i)).op (f ^ (s.attach.sup n) * x) = 0,
  { subst hs,
    apply X.sheaf.eq_of_locally_eq (Œª (i : s), (i : opens X.carrier)),
    intro i,
    rw map_zero,
    apply this },
  intro i,
  replace hn := congr_arg
    (Œª x, X.presheaf.map (hom_of_le (h‚ÇÅ i)).op (f ^ (s.attach.sup n - n i)) * x) (hn i),
  dsimp at hn,
  simp only [‚Üê map_mul, ‚Üê map_pow] at hn,
  rwa [mul_zero, ‚Üê mul_assoc, ‚Üê pow_add, tsub_add_cancel_of_le] at hn,
  apply finset.le_sup (s.mem_attach i)
end

lemma supr_insert {Œ± Œ≤ : Type*} (x : Œ±) (s : set Œ±) (f : Œ± ‚Üí Œ≤) [complete_lattice Œ≤] :
  (‚®Ü a : insert x s, f a) = (‚®Ü a : s, f a) ‚äî f x :=
begin
  apply le_antisymm,
  { suffices : ‚àÄ (a : s), f a ‚â§ (‚®Ü a : s, f a) ‚äî f x,
    { simpa using this },
    intros a,
    exact le_trans (le_supr (Œª x : s, f x) a : _) le_sup_left },
  { simp only [supr_le_iff, set_coe.forall, sup_le_iff], split,
    { intros a ha, exact le_supr (Œª a : insert x s, f a) ‚ü®_, set.mem_insert_of_mem _ ha‚ü© },
    { exact le_supr (Œª a : insert x s, f a) ‚ü®_, set.mem_insert _ _‚ü© } }
end

lemma supr_finset_insert {Œ± Œ≤ : Type*} (x : Œ±) (s : finset Œ±) (f : Œ± ‚Üí Œ≤) [complete_lattice Œ≤]
  [decidable_eq Œ±] : (‚®Ü a : insert x s, f a) = (‚®Ü a : s, f a) ‚äî f x :=
begin
  convert supr_insert x s f using 1,
  rw ‚Üê finset.coe_insert,
  refl
end

lemma compact_open_induction_on (P : opens X.carrier ‚Üí Prop)
  (h‚ÇÅ : P ‚ä•)
  (h‚ÇÇ : ‚àÄ (S : opens X.carrier) (hS : is_compact S.1) (U : X.affine_opens), P S ‚Üí P (S ‚äî U)) :
  ‚àÄ (S : opens X.carrier) (hS : is_compact S.1), P S :=
begin
  classical,
  intros S hS,
  obtain ‚ü®s, hs‚ü© := (is_compact_open_iff_eq_finset_affine_union S.1).mp ‚ü®hS, S.2‚ü©,
  replace hs : S = supr (Œª i : s, (i : opens X.carrier)) := by { ext1, simpa using hs },
  subst hs,
  induction s using finset.induction with x s h‚ÇÉ h‚ÇÑ,
  { convert h‚ÇÅ, rw supr_eq_bot, rintro ‚ü®_, h‚ü©, exact h.elim },
  { have : is_compact (‚®Ü i : s, (i : opens X.carrier)).1,
    { refine ((is_compact_open_iff_eq_finset_affine_union _).mpr _).1, use s, simp },
    convert h‚ÇÇ _ this x (h‚ÇÑ this), simp only [coe_coe], rw supr_finset_insert, refl }
end

end algebraic_geometry
