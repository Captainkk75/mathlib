import category_theory.monoidal.CommMon_
import algebra.homology.single
import category_theory.limits.shapes.biproducts
import data.finset.nat_antidiagonal
import category_theory.monoidal.functorial
import algebra.category.Module.monoidal
import algebra.category.Module.abelian

open category_theory
open category_theory.limits

universes v u

noncomputable theory

variables {C : Type u} [category.{0} C] [has_zero_object C] [preadditive C] [has_finite_biproducts C] [monoidal_category C]

open_locale big_operators

def left_distributor {J : Type} [decidable_eq J] [fintype J] (X : C) (f : J ‚Üí C) :
  X ‚äó (‚®Å f) ‚âÖ ‚®Å (Œª j, X ‚äó f j) :=
{ hom := ‚àë j : J, (ùüô X ‚äó biproduct.œÄ f j) ‚â´ biproduct.Œπ _ j,
  inv := ‚àë j : J, biproduct.œÄ _ j ‚â´ (ùüô X ‚äó biproduct.Œπ f j),
  hom_inv_id' := sorry,
  inv_hom_id' := sorry, }

def right_distributor {J : Type} [decidable_eq J] [fintype J] (X : C) (f : J ‚Üí C) :
  (‚®Å f) ‚äó X ‚âÖ ‚®Å (Œª j, f j ‚äó X) :=
{ hom := ‚àë j : J, (biproduct.œÄ f j ‚äó ùüô X) ‚â´ biproduct.Œπ _ j,
  inv := ‚àë j : J, biproduct.œÄ _ j ‚â´ (biproduct.Œπ f j ‚äó ùüô X),
  hom_inv_id' := sorry,
  inv_hom_id' := sorry, }

namespace cochain_complex

def antidiagonal (i : ‚Ñï) := { p : ‚Ñï √ó ‚Ñï // p.1 + p.2 = i }
instance (i : ‚Ñï) : fintype (antidiagonal i) := sorry

def tensor_d (X Y : cochain_complex C ‚Ñï) (i j : ‚Ñï) (p : antidiagonal i) (q : antidiagonal j) :
  X.X p.1.1 ‚äó Y.X p.1.2 ‚ü∂ X.X q.1.1 ‚äó Y.X q.1.2 :=
if h : p.1.1 = q.1.1 then
  (-1 : ‚Ñ§)^p.1.1 ‚Ä¢ eq_to_hom (congr_arg X.X h) ‚äó Y.d p.1.2 q.1.2
else if h : p.1.2 = q.1.2 then
  X.d p.1.1 q.1.1 ‚äó eq_to_hom (congr_arg Y.X h)
else
  0

def tensor_obj (X Y : cochain_complex C ‚Ñï) : cochain_complex C ‚Ñï :=
{ X := Œª i, ‚®Å (Œª p : antidiagonal i, X.X p.1.1 ‚äó Y.X p.1.2),
  d := Œª i j, biproduct.matrix (tensor_d X Y i j),
  shape' := sorry,
  d_comp_d' := sorry, }

def tensor_hom {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : cochain_complex C ‚Ñï} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
  tensor_obj X‚ÇÅ Y‚ÇÅ ‚ü∂ tensor_obj X‚ÇÇ Y‚ÇÇ :=
{ f := Œª i, biproduct.map (Œª p, f.f p.1.1 ‚äó g.f p.1.2),
  comm' := sorry, }

def tensor_unit : cochain_complex C ‚Ñï := (cochain_complex.single‚ÇÄ C).obj (ùüô_ C)

def associator_hom_aux (X Y Z : cochain_complex C ‚Ñï) (i : ‚Ñï)
  (p q : antidiagonal i) (j : antidiagonal p.1.1) (k : antidiagonal q.1.2) :
    (X.X j.1.1 ‚äó Y.X j.1.2) ‚äó Z.X p.1.2 ‚ü∂ X.X q.1.1 ‚äó (Y.X k.1.1 ‚äó Z.X k.1.2) :=
if h : j.1.1 = q.1.1 ‚àß j.1.2 = k.1.1 ‚àß p.1.2 = k.1.2 then
  (Œ±_ _ _ _).hom ‚â´
    (eq_to_hom (congr_arg X.X h.1) ‚äó eq_to_hom (congr_arg Y.X h.2.1) ‚äó
      eq_to_hom (congr_arg Z.X h.2.2))
else
  0

def associator_hom (X Y Z : cochain_complex C ‚Ñï) :
  tensor_obj (tensor_obj X Y) Z ‚ü∂ tensor_obj X (tensor_obj Y Z) :=
{ f := Œª i, biproduct.matrix (Œª p q,
  (right_distributor _ _).hom ‚â´ biproduct.matrix (associator_hom_aux X Y Z i p q) ‚â´
    (left_distributor _ _).inv),
  comm' := sorry }

def associator_inv_aux (X Y Z : cochain_complex C ‚Ñï) (i : ‚Ñï)
  (p q : antidiagonal i) (j : antidiagonal p.1.2) (k : antidiagonal q.1.1) :
    X.X p.1.1 ‚äó (Y.X j.1.1 ‚äó Z.X j.1.2) ‚ü∂ (X.X k.1.1 ‚äó Y.X k.1.2) ‚äó Z.X q.1.2 :=
if h : p.1.1 = k.1.1 ‚àß j.1.1 = k.1.2 ‚àß j.1.2 = q.1.2 then
  (eq_to_hom (congr_arg X.X h.1) ‚äó eq_to_hom (congr_arg Y.X h.2.1) ‚äó
      eq_to_hom (congr_arg Z.X h.2.2)) ‚â´ (Œ±_ _ _ _).inv
else
  0

def associator_inv (X Y Z : cochain_complex C ‚Ñï) :
  tensor_obj X (tensor_obj Y Z) ‚ü∂ tensor_obj (tensor_obj X Y) Z :=
{ f := Œª i, biproduct.matrix (Œª p q,
  (left_distributor _ _).hom ‚â´ biproduct.matrix (associator_inv_aux X Y Z i p q) ‚â´
    (right_distributor _ _).inv),
  comm' := sorry }

def associator (X Y Z : cochain_complex C ‚Ñï) :
  tensor_obj (tensor_obj X Y) Z ‚âÖ tensor_obj X (tensor_obj Y Z) :=
{ hom := associator_hom X Y Z,
  inv := associator_inv X Y Z,
  hom_inv_id' := sorry,
  inv_hom_id' := sorry, }

-- TODO there is still data to construct here
def left_unitor (X : cochain_complex C ‚Ñï) :
  tensor_obj tensor_unit X ‚âÖ X := sorry

-- TODO there is still data to construct here
def right_unitor (X : cochain_complex C ‚Ñï) :
  tensor_obj X tensor_unit ‚âÖ X := sorry

end cochain_complex

instance : monoidal_category (cochain_complex C ‚Ñï) :=
{ tensor_obj := Œª X Y, cochain_complex.tensor_obj X Y,
  tensor_hom := Œª X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f g, cochain_complex.tensor_hom f g,
  tensor_unit := cochain_complex.tensor_unit,
  associator := cochain_complex.associator,
  left_unitor := cochain_complex.left_unitor,
  right_unitor := cochain_complex.right_unitor,
  tensor_id' := sorry,
  tensor_comp' := sorry,
  associator_naturality' := sorry,
  left_unitor_naturality' := sorry,
  right_unitor_naturality' := sorry,
  pentagon' := sorry,
  triangle' := sorry, }

variables [braided_category C]

instance : braided_category (cochain_complex C ‚Ñï) :=
sorry

namespace graded_object

def tensor_obj (X Y : graded_object ‚Ñï C) : graded_object ‚Ñï C :=
sorry

def tensor_hom {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : graded_object ‚Ñï C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
  tensor_obj X‚ÇÅ Y‚ÇÅ ‚ü∂ tensor_obj X‚ÇÇ Y‚ÇÇ :=
sorry

def tensor_unit : graded_object ‚Ñï C := sorry

def associator_hom (X Y Z : graded_object ‚Ñï C) :
  tensor_obj (tensor_obj X Y) Z ‚ü∂ tensor_obj X (tensor_obj Y Z) :=
sorry

def associator_inv (X Y Z : graded_object ‚Ñï C) :
  tensor_obj X (tensor_obj Y Z) ‚ü∂ tensor_obj (tensor_obj X Y) Z :=
sorry

def associator (X Y Z : graded_object ‚Ñï C) :
  tensor_obj (tensor_obj X Y) Z ‚âÖ tensor_obj X (tensor_obj Y Z) :=
{ hom := associator_hom X Y Z,
  inv := associator_inv X Y Z,
  hom_inv_id' := sorry,
  inv_hom_id' := sorry, }

def left_unitor (X : graded_object ‚Ñï C) :
  tensor_obj tensor_unit X ‚âÖ X := sorry

def right_unitor (X : graded_object ‚Ñï C) :
  tensor_obj X tensor_unit ‚âÖ X := sorry

end graded_object

instance : monoidal_category (graded_object ‚Ñï C) :=
{ tensor_obj := Œª X Y, graded_object.tensor_obj X Y,
  tensor_hom := Œª X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ f g, graded_object.tensor_hom f g,
  tensor_unit := graded_object.tensor_unit,
  associator := graded_object.associator,
  left_unitor := graded_object.left_unitor,
  right_unitor := graded_object.right_unitor,
  tensor_id' := sorry,
  tensor_comp' := sorry,
  associator_naturality' := sorry,
  left_unitor_naturality' := sorry,
  right_unitor_naturality' := sorry,
  pentagon' := sorry,
  triangle' := sorry, }

instance : braided_category (graded_object ‚Ñï C) :=
sorry

variables [has_equalizers C] [has_images C] [has_image_maps C] [has_cokernels C]

instance : lax_monoidal (graded_homology_functor C (complex_shape.up ‚Ñï)).obj :=
sorry

variables (C)

def graded_homology_lax_monoidal_functor : lax_monoidal_functor (cochain_complex C ‚Ñï) (graded_object ‚Ñï C) :=
lax_monoidal_functor.of (graded_homology_functor C (complex_shape.up ‚Ñï)).obj

def graded_homology_lax_braided_functor : lax_braided_functor (cochain_complex C ‚Ñï) (graded_object ‚Ñï C) :=
sorry

def CDGA_challenge : CommMon_ (cochain_complex C ‚Ñï) ‚•§ CommMon_ (graded_object ‚Ñï C) :=
(graded_homology_lax_braided_functor C).map_CommMon

variables (R : Type) [comm_ring R]

def CDGA_challenge' : CommMon_ (cochain_complex (Module.{0} R) ‚Ñï) ‚•§ CommMon_ (graded_object ‚Ñï (Module.{0} R)) :=
CDGA_challenge _
