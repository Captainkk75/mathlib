/-
Copyright (c) 2021 Aaron Anderson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson
-/

import group_theory.perm.cycle_type
import group_theory.perm.fin

/-!
# Alternating Groups

The alternating group on a finite type `α` is the subgroup of the permutation group `perm α`
consisting of the even permutations.

## Main definitions

* `alternating_group α` is the alternating group on `α`, defined as a `subgroup (perm α)`.

## Main results
* `two_mul_card_alternating_group` shows that the alternating group is half as large as
  the permutation group it is a subgroup of.

* `closure_three_cycles_eq_alternating` shows that the alternating group is
  generated by three-cycles.

## Tags
alternating group permutation


## TODO
* Show that `alternating_group α` is simple if and only if `fintype.card α ≠ 4`.

-/

open equiv equiv.perm subgroup fintype
variables (α : Type*) [fintype α] [decidable_eq α]

lemma is_simple_group_iff_normal_closure {G : Type*} [group G] [nt : nontrivial G] :
  is_simple_group G ↔ ∀ g : G, g = 1 ∨ subgroup.normal_closure ({g} : set G) = ⊤ :=
begin
  split,
  { intros h g,
    haveI := h,
    refine (subgroup.normal_closure_normal : (subgroup.normal_closure
      ({g} : set G)).normal).eq_bot_or_eq_top.imp (λ h, _) id,
    rw [← subgroup.mem_bot, ← h],
    exact subgroup.subset_normal_closure (set.mem_singleton g) },
  { intro h,
    refine ⟨exists_pair_ne _, λ H Hn, _⟩,
    haveI : H.normal := Hn,
    by_cases Hb : H = ⊥,
    { exact or.intro_left _ Hb },
    right,
    rw subgroup.eq_bot_iff_forall at Hb,
    push_neg at Hb,
    obtain ⟨g, hgH, hg1⟩ := Hb,
    rw [eq_top_iff, ← (h g).resolve_left hg1],
    refine subgroup.normal_closure_le_normal _,
    rw [set.singleton_subset_iff, set_like.mem_coe],
    exact hgH }
end

namespace subgroup

lemma is_simple_group_iff {G : Type*} [group G] {S : subgroup G} :
  is_simple_group S ↔ S ≠ ⊥ ∧
    ∀ (g : G) (hg : g ∈ S), g = 1 ∨ normal_closure ({⟨g, hg⟩} : set S) = ⊤ :=
begin
  sorry
end

end subgroup

/-- The alternating group on a finite type, realized as a subgroup of `equiv.perm`.
  For $A_n$, use `alternating_group (fin n)`. -/
@[derive fintype] def alternating_group : subgroup (perm α) :=
sign.ker

instance [subsingleton α] : unique (alternating_group α) :=
⟨⟨1⟩, λ ⟨p, hp⟩, subtype.eq (subsingleton.elim p _)⟩

variables {α}

lemma alternating_group_eq_sign_ker : alternating_group α = sign.ker := rfl

namespace equiv.perm

@[simp]
lemma mem_alternating_group {f : perm α} :
  f ∈ alternating_group α ↔ sign f = 1 :=
sign.mem_ker

lemma is_three_cycle.mem_alternating_group {f : perm α} (h : is_three_cycle f) :
  f ∈ alternating_group α :=
mem_alternating_group.2 h.sign

lemma prod_list_swap_mem_alternating_group_iff_even_length {l : list (perm α)}
  (hl : ∀ g ∈ l, is_swap g) :
  l.prod ∈ alternating_group α ↔ even l.length :=
begin
  rw [mem_alternating_group, sign_prod_list_swap hl, ← units.coe_eq_one, units.coe_pow,
    units.coe_neg_one, nat.neg_one_pow_eq_one_iff_even],
  dec_trivial
end

end equiv.perm

lemma two_mul_card_alternating_group [nontrivial α] :
  2 * card (alternating_group α) = card (perm α) :=
begin
  let := (quotient_group.quotient_ker_equiv_of_surjective _ (sign_surjective α)).to_equiv,
  rw [←fintype.card_units_int, ←fintype.card_congr this],
  exact (subgroup.card_eq_card_quotient_mul_card_subgroup _).symm,
end

instance alternating_group_normal : (alternating_group α).normal := sign.normal_ker

namespace equiv.perm

@[simp]
theorem closure_three_cycles_eq_alternating :
  closure {σ : perm α | is_three_cycle σ} = alternating_group α :=
closure_eq_of_le _ (λ σ hσ, mem_alternating_group.2 hσ.sign) $ λ σ hσ, begin
  suffices hind : ∀ (n : ℕ) (l : list (perm α)) (hl : ∀ g, g ∈ l → is_swap g)
    (hn : l.length = 2 * n), l.prod ∈ closure {σ : perm α | is_three_cycle σ},
  { obtain ⟨l, rfl, hl⟩ := trunc_swap_factors σ,
    obtain ⟨n, hn⟩ := (prod_list_swap_mem_alternating_group_iff_even_length hl).1 hσ,
    exact hind n l hl hn },
  intro n,
  induction n with n ih; intros l hl hn,
  { simp [list.length_eq_zero.1 hn, one_mem] },
  rw [nat.mul_succ] at hn,
  obtain ⟨a, l, rfl⟩ := l.exists_of_length_succ hn,
  rw [list.length_cons, nat.succ_inj'] at hn,
  obtain ⟨b, l, rfl⟩ := l.exists_of_length_succ hn,
  rw [list.prod_cons, list.prod_cons, ← mul_assoc],
  rw [list.length_cons, nat.succ_inj'] at hn,
  exact mul_mem _ (is_swap.mul_mem_closure_three_cycles (hl a (list.mem_cons_self a _))
    (hl b (list.mem_cons_of_mem a (l.mem_cons_self b))))
    (ih _ (λ g hg, hl g (list.mem_cons_of_mem _ (list.mem_cons_of_mem _ hg))) hn),
end

end equiv.perm

namespace alternating_group

open equiv.perm

lemma nontrivial_of_three_le_card (h3 : 3 ≤ card α) : nontrivial (alternating_group α) :=
begin
  haveI := fintype.one_lt_card_iff_nontrivial.1 (lt_trans dec_trivial h3),
  rw ← fintype.one_lt_card_iff_nontrivial,
  refine lt_of_mul_lt_mul_left _ (le_of_lt nat.prime_two.pos),
  rw [two_mul_card_alternating_group, card_perm, ← nat.succ_le_iff],
  exact le_trans h3 (card α).self_le_factorial,
end

lemma is_conj_of {σ τ : alternating_group α}
  (hc : is_conj (σ : perm α) (τ : perm α)) (hσ : (σ : perm α).support.card + 2 ≤ fintype.card α) :
    is_conj σ τ :=
begin
  obtain ⟨σ, hσ⟩ := σ,
  obtain ⟨τ, hτ⟩ := τ,
  obtain ⟨π, hπ⟩ := is_conj_iff.1 hc,
  rw [subtype.coe_mk, subtype.coe_mk] at hπ,
  cases int.units_eq_one_or (sign π) with h h,
  { exact is_conj_iff.2 ⟨⟨π, mem_alternating_group.2 h⟩, subtype.val_injective (by simp [← hπ])⟩ },
  { have h2 : 2 ≤ σ.supportᶜ.card,
    { rw [finset.card_compl, nat.le_sub_left_iff_add_le σ.support.card_le_univ],
      exact hσ },
    obtain ⟨a, ha, b, hb, ab⟩ := finset.one_lt_card.1 h2,
    refine is_conj_iff.2 ⟨⟨π * swap a b, _⟩, subtype.val_injective _⟩,
    { rw [mem_alternating_group, monoid_hom.map_mul, h, sign_swap ab, int.units_mul_self] },
    { simp only [←hπ, coe_mk, subgroup.coe_mul, subtype.val_eq_coe],
      have hd : disjoint (swap a b) σ,
      { rw [disjoint_iff_disjoint_support, support_swap ab, finset.disjoint_insert_left,
          finset.singleton_disjoint],
        exact ⟨finset.mem_compl.1 ha, finset.mem_compl.1 hb⟩ },
      rw [mul_assoc π _ σ, disjoint.mul_comm hd],
      simp [mul_assoc] } }
end

lemma is_three_cycle_is_conj (h5 : 5 ≤ fintype.card α)
  {σ τ : alternating_group α}
  (hσ : is_three_cycle (σ : perm α)) (hτ : is_three_cycle (τ : perm α)) :
  is_conj σ τ :=
alternating_group.is_conj_of (hσ.is_conj hτ) (by { rw hσ.card_support, exact h5 })

lemma closure_three_cycles :
  closure {σ : alternating_group α | is_three_cycle (σ : perm α)} = ⊤ :=
begin
  have h : closure {σ : (perm α) | is_three_cycle σ} =
    (closure {σ : alternating_group α | is_three_cycle (σ : perm α)}).map
      (alternating_group α).subtype,
  { rw [monoid_hom.map_closure, subgroup.coe_subtype],
    apply congr rfl,
    ext,
    rw [set.mem_image],
    split,
    { intro hx,
      exact ⟨⟨x, is_three_cycle.mem_alternating_group hx⟩, hx, rfl⟩ },
    { rintro ⟨⟨x, hx⟩, hx', rfl⟩,
      exact hx' } },
  rw closure_three_cycles_eq_alternating at h,
  ext ⟨x, hx⟩,
  simp only [iff_true, mem_top],
  rw [h, subgroup.mem_map] at hx,
  obtain ⟨a, ha, rfl⟩ := hx,
  convert ha,
  simp,
end

lemma normal_subgroup_eq_top_of_exists_three_cycle_mem
  (h5 : 5 ≤ fintype.card α)
  {S : subgroup (alternating_group α)} (hn : S.normal)
  (he : ∃ σ : S, is_three_cycle (σ : perm α)) : S = ⊤ :=
begin
  obtain ⟨⟨σ, hσS⟩, hσ⟩ := he,
  rw [eq_top_iff, ← alternating_group.closure_three_cycles, closure_le],
  refine set.subset.trans (λ τ hτ, _) (group.conjugates_subset_normal hσS),
  exact alternating_group.is_three_cycle_is_conj h5 hσ hτ,
end

def good (σ : perm α) : Prop :=
  ∃ f : perm α, is_three_cycle f ∧ f ∈ closure ((λ g, g * σ * g⁻¹) '' alternating_group α)

lemma normal_closure_eq_top_of_good (h5 : 5 ≤ fintype.card α)
  {g : alternating_group α} (hg : good (g : perm α)) :
  normal_closure ({g} : set (alternating_group α)) = ⊤ :=
begin
  obtain ⟨f, hf1, hf2⟩ := hg,
  apply normal_subgroup_eq_top_of_exists_three_cycle_mem h5 subgroup.normal_closure_normal,
  refine ⟨⟨⟨f, hf1.mem_alternating_group⟩, _⟩, hf1⟩,
  rw [← coe_mk _ f hf1.mem_alternating_group, ← subgroup.coe_subtype] at hf2,
  have h : (λ (g_1 : perm α), g_1 * ↑g * g_1⁻¹) '' ↑(alternating_group α) ⊆
    (alternating_group α).subtype '' (group.conjugates_of_set {g}),
  { intro x,
    simp only [subgroup.coe_subtype, set.mem_image, set_like.mem_coe],
    rintros ⟨y, hy, rfl⟩,
    refine ⟨⟨y, hy⟩ * g * ⟨y, hy⟩⁻¹, group.conj_mem_conjugates_of_set
      (group.subset_conjugates_of_set (set.mem_singleton _)), _⟩,
    simp },
  have h := closure_mono h hf2,
  rw [← monoid_hom.map_closure, mem_map] at h,
  obtain ⟨x, hx, hxf⟩ := h,
  rwa [subtype.coe_injective hxf] at hx,
end

section extend_domain

variables {β : Type*} [fintype β] {p : β → Prop} [decidable_pred p] [decidable_eq β]

lemma _root_.equiv.perm.is_three_cycle.extend_domain {g : perm α}
  (h : is_three_cycle g) (f : α ≃ subtype p) :
  is_three_cycle (g.extend_domain f) :=
by rw [is_three_cycle, cycle_type_extend_domain, h.cycle_type]


lemma good_of_good_commutator {g1 g2 : perm α} (a b : α) (hab : a ≠ b) (hg1ab : g1 a ≠ b)
  (ha : a ∈ g1.support) (hb : b ∈ g1.support)
  (hd : disjoint g1 g2)
  (hgood : good (g1 * ((swap a b) * (swap a (g1 a))) * g1⁻¹ * ((swap a b) * (swap a (g1 a))) ⁻¹)) :
  good (g1 * g2) :=
begin
  refine le_trans hgood _,
  rw [closure_le],
  rintro _ ⟨g, hg, rfl⟩,
  dsimp,
  let g3 := (swap a b) * (swap a (g1 a)),
  have hd' : disjoint g2 g3,
  { rw disjoint_iff_disjoint_support at *,
    refine finset.disjoint_of_subset_right _ hd.symm,
    refine le_trans (support_mul_le _ _) _,
    simp only [hab, finset.le_eq_subset, finset.sup_eq_union, finset.insert_union, ne.def,
      not_false_iff, support_swap, finset.insert_subset],
    refine ⟨ha, finset.union_subset (finset.singleton_subset_iff.2 hb) _⟩,
    rw [swap_comm, support_swap (mem_support.1 ha), finset.insert_subset,
      finset.singleton_subset_iff, apply_mem_support],
    exact ⟨ha, ha⟩ },
  have h : g1 * g3 * g1⁻¹ * g3⁻¹ = (g1 * g2) * g3 * (g1 * g2)⁻¹ * g3⁻¹,
  { rw [mul_inv_rev g1, mul_assoc g1 g2, mul_assoc g1 (g2 * g3), hd'.mul_comm, mul_assoc g3,
      ← mul_assoc g2, mul_inv_self, one_mul],
    simp only [mul_assoc] },
  rw [h, set_like.mem_coe, mul_assoc (g1 * g2), mul_assoc (g1 * g2), ← conj_mul],
  refine mul_mem _ (subset_closure ⟨g, hg, rfl⟩) _,
  rw [← inv_mem_iff],
  simp only [mul_inv_rev, inv_inv],
  refine subset_closure ⟨g * g3, _, _⟩,
  { rw set_like.mem_coe at *,
    refine mul_mem _ hg (is_three_cycle_swap_mul_swap_same hab _ hg1ab.symm).mem_alternating_group,
    exact (mem_support.1 ha).symm },
  { rw hd.mul_comm,
    simp only [mul_assoc, mul_inv_rev] }
end

lemma foo {g1 g2 : perm α} {g3 : perm β}
  (f : α ≃ subtype p) (h : g2 ∈ alternating_group α) (hd : ∀ x ∈ g3.support, ¬ p x)
  (h : good (g1 * g2 * g1⁻¹ * g2⁻¹)) :
  good ((g1.extend_domain f) * g3) :=
begin
  have hd : disjoint (g2.extend_domain f) g3 := sorry,
  have h' : (g1.extend_domain f * g3) * (g2.extend_domain f) * (g1.extend_domain f * g3)⁻¹ *
    (g2.extend_domain f)⁻¹ = (g1 * g2 * g1⁻¹ * g2⁻¹).extend_domain f,
  { rw [mul_assoc (g1.extend_domain f), mul_assoc (g1.extend_domain f), mul_inv_rev, ← hd.mul_comm,
      mul_assoc _ g3, ← mul_assoc g3, mul_inv_self, one_mul],
    simp only [extend_domain_mul, extend_domain_inv, mul_assoc] },
  obtain ⟨t, ht, ht'⟩ := h,
  refine ⟨t.extend_domain f, ht.extend_domain f, _⟩,
  rw [mul_assoc (g1.extend_domain f * g3), mul_assoc (g1.extend_domain f * g3)] at h',
  have h : t.extend_domain f ∈ (closure ((λ (g : perm α), g * (g1 * g2 * g1⁻¹ * g2⁻¹) * g⁻¹) '' ↑(alternating_group α))).map
    (⟨λ g, extend_domain g f, extend_domain_one f, λ a b, (extend_domain_mul f a b).symm⟩ : monoid_hom _ _) :=
    mem_map.2 ⟨_, ht', rfl⟩,
  rw monoid_hom.map_closure at h,
  refine (closure_mono _) h,
  intro x,
  simp only [and_imp, set.mem_image, mem_alternating_group, exists_exists_and_eq_and,
    set_like.mem_coe, monoid_hom.coe_mk, exists_imp_distrib],
  rintro y hy rfl,
  refine ⟨y.extend_domain f, sorry, _⟩,
  sorry,
end

end extend_domain

lemma good_of_good_of_is_conj {f : perm α} (g : perm α) (hg : good g) (fg : is_conj f g) :
  good f :=
begin
  rw good at *,
  obtain ⟨g', rfl⟩ := is_conj_iff.1 fg,
  have h : (alternating_group α).map (mul_aut.conj g').to_monoid_hom = alternating_group α,
  { rw [alternating_group],
    have h : function.surjective ((mul_aut.conj g').to_monoid_hom) :=
      (mul_aut.conj g').surjective,
    conv_rhs { rw ← map_comap_eq_self_of_surjective h sign.ker },
    rw monoid_hom.comap_ker,
    refine congr rfl (congr rfl _),
    ext,
    simp only [sign_inv, mul_equiv.coe_to_monoid_hom, mul_aut.conj_apply, sign_mul,
      function.comp_app, monoid_hom.coe_comp, units.coe_mul],
    rw [mul_comm, ← mul_assoc, ← units.coe_mul, int.units_mul_self, units.coe_one, one_mul] },
  have hg' := map_mono hg,
  rw [h, monoid_hom.map_closure, set.image_image] at hg',
  refine le_trans hg' (le_of_eq (congr rfl _)),
end

lemma good_of_four_le_mem_cycle_type (h5 : 5 ≤ fintype.card α)
  {g : perm α} {n : ℕ} (hn : 4 ≤ n) (h : n ∈ g.cycle_type) :
  good g :=
begin
  sorry,
end

lemma good_of_two_le_cycle_type_count_three
  {g : perm α} (h : 2 ≤ g.cycle_type.count 3) :
  good g :=
begin
  sorry,
end

theorem alternating_group.is_simple_group (h5 : 5 ≤ fintype.card α) :
  is_simple_group (alternating_group α) :=
begin
  rw subgroup.is_simple_group_iff,
  refine ⟨λ con, _, _⟩,
  { have h := alternating_group.nontrivial_of_three_le_card (le_trans dec_trivial h5),
    rw [con, nontrivial_iff_exists_ne_one] at h,
    obtain ⟨g, hg, g1⟩ := h,
    exact g1 (mem_bot.1 hg) },
  intros g hg,
  by_cases h4 : ∃ n, n ∈ cycle_type g ∧ 4 ≤ n,
  { right,
    obtain ⟨n, h, hn⟩ := h4,
    exact normal_closure_eq_top_of_good (apply good_of_four_le_mem_cycle_type h5 n hn h) },
  push_neg at h4,
  by_cases h23 : 2 ≤ g.cycle_type.count 3,
  { right,
    apply good_of_two_le_cycle_type_count_three },
  by_cases h3 : 3 ∈ g.cycle_type,
  { right,
    sorry },
  have he : 2 ∣ g.cycle_type.length := sorry,
end

end alternating_group
