import ring_theory.localization
import ring_theory.graded_algebra.basic

open_locale  big_operators

section clear_denominator

variables (R : Type*) [comm_ring R] (f : R) [decidable_eq (localization.away f)]

def clear_denominator (s : finset (localization.away f)) :
  ‚àÉ (n : ‚Ñï), ‚àÄ (x : localization.away f), x ‚àà s ‚Üí
    x * (localization.mk (f^n) 1 : localization.away f) ‚àà
    (Œª y : R, (localization.mk y 1 : localization.away f)) '' set.univ :=
begin
  induction s using finset.induction_on with a s a_nin_s ih,
  { refine ‚ü®0, Œª x rid, _‚ü©, exfalso, erw set.mem_empty_eq x at rid, exact rid, },
  { obtain ‚ü®n, hn‚ü© := ih,
    have : ‚àÉ (m : ‚Ñï) (x : R), a = localization.mk x ‚ü®f^m, ‚ü®m, rfl‚ü©‚ü©,
    { induction a using localization.induction_on with data,
      obtain ‚ü®a, ‚ü®b, ‚ü®m, rfl‚ü©‚ü©‚ü© := data,
      refine ‚ü®m, a, _‚ü©, refl, },
    obtain ‚ü®m, x, rfl‚ü© := this,
    refine ‚ü®n + m, Œª y hy, _‚ü©,
    rw finset.mem_insert at hy,
    rcases hy,
    { erw [hy, localization.mk_mul],
      have : (localization.mk (x * f ^ (n + m)) (‚ü®f ^ m, _‚ü© * 1) : localization.away f) =
        localization.mk (x * f ^ n) 1,
      { rw [localization.mk_eq_mk', is_localization.eq], use 1,
        erw [mul_one, mul_one, mul_one, mul_one, pow_add, mul_assoc],
        refl },
      erw [this, set.mem_image],
      refine ‚ü®_, set.mem_univ _, rfl‚ü©, },
    { specialize hn y hy,
      erw set.mem_image at hn,
      obtain ‚ü®y', _, eq1‚ü© := hn,
      have : (localization.mk (f ^ (n + m)) 1 : localization.away f) =
        localization.mk (f ^ n) 1 * localization.mk (f^m) 1,
      { rw [localization.mk_mul], congr, rw pow_add, rw mul_one, },
      erw [this, ‚Üêmul_assoc, ‚Üêeq1, localization.mk_mul, mul_one],
      refine ‚ü®_, set.mem_univ _, rfl‚ü©, } }
end

lemma localization.mk_pow (m n : ‚Ñï) (hm : 0 < m) (Œ± : R) :
  (localization.mk Œ± ‚ü®f^n, ‚ü®n, rfl‚ü©‚ü© : localization.away f)^m
  = (localization.mk (Œ± ^ m) ‚ü®f^(m * n), ‚ü®_, rfl‚ü©‚ü©) :=
begin
  induction m with m ih,
  { exfalso, apply lt_irrefl 0 hm, },
  { by_cases ineq : m = 0,
    { rw [ineq, pow_one, pow_one, one_mul], },
    { replace ineq : 0 < m,
      { by_contra,
        rw not_lt at h,
        have ineq2 := lt_of_le_of_ne h ineq,
        linarith, },
      { specialize ih ineq,
        rw [pow_succ, ih, pow_succ, nat.succ_mul, localization.mk_mul],
        congr',

        rw [subtype.ext_iff_val, show ‚àÄ (a b : submonoid.powers f), (a * b).1 = a.1 * b.1,
          from Œª _ _, rfl],
        dsimp only,
        rw [mul_comm, pow_add], }, }, },
end

end clear_denominator


section homogeneous_induction

variables {Œπ R A: Type*} [linear_ordered_cancel_add_comm_monoid Œπ]
variables [comm_ring R] [comm_ring A] [algebra R A]
variables (ùíú : Œπ ‚Üí submodule R A) [graded_algebra ùíú]
variable [Œ† (i : Œπ) (x : ùíú i), decidable (x ‚â† 0)]

@[elab_as_eliminator]
lemma set_like.homogeneous_induction {P : A ‚Üí Prop}
  (a : A)
  (h_zero : P 0)
  (h_hom : ‚àÄ (a : set_like.homogeneous_submonoid ùíú), P a.1)
  (h_add : ‚àÄ (a b : A), P a ‚Üí P b ‚Üí P (a + b))
  : P a :=
begin
  erw ‚Üêgraded_algebra.sum_support_decompose ùíú a,
  suffices : ‚àÄ (i : graded_algebra.support ùíú a), P (graded_algebra.decompose ùíú a i.1 : A),
  { induction (graded_algebra.support ùíú a) using finset.induction_on with x s hx ih,
    erw finset.sum_empty, exact h_zero,

    erw finset.sum_insert hx, apply h_add _ _ _ ih,
    refine h_hom ‚ü®(graded_algebra.decompose ùíú a x), ‚ü®x, submodule.coe_mem _‚ü©‚ü©, },

  rintros ‚ü®i, hi‚ü©,
  refine h_hom ‚ü®(graded_algebra.decompose ùíú a i), ‚ü®i, submodule.coe_mem _‚ü©‚ü©,
end


end homogeneous_induction


section mem_span

universe u
variables (R : Type u) [comm_ring R]

lemma ideal.mem_span.smul_mem (s : set R) (r a : R) (ha : a ‚àà s) : r ‚Ä¢ a ‚àà ideal.span s :=
begin
  rw ideal.mem_span,
  intros J hs,
  apply ideal.mul_mem_left,
  exact hs ha,
end

end mem_span

section

variables {R A: Type*}
variables [comm_ring R] [comm_ring A] [algebra R A] [nontrivial A]

variables (ùíú : ‚Ñï ‚Üí submodule R A)
variables [graded_algebra ùíú] [Œ† (i : ‚Ñï) (x : ùíú i), decidable (x ‚â† 0)]

lemma graded_algebra.proj_hom_mul (a b : A) (i j : ‚Ñï) (a_hom : a ‚àà ùíú i)
  (hb : graded_algebra.proj ùíú j b ‚â† 0) :
  graded_algebra.proj ùíú (i + j) (a * b) = a * graded_algebra.proj ùíú j b :=
begin
  by_cases INEQ : a = 0,
  rw [INEQ, zero_mul, zero_mul, linear_map.map_zero],

  rw [graded_algebra.proj_apply, alg_equiv.map_mul, direct_sum.coe_mul_apply_submodule ùíú,
    ‚Üêgraded_algebra.support, ‚Üêgraded_algebra.support],

  have set_eq1 : graded_algebra.support ùíú a = {i},
    { ext1, split; intros hx,
      { erw graded_algebra.mem_support_iff at hx,
        erw finset.mem_singleton,
        contrapose hx,
        erw [not_not, graded_algebra.proj_apply, graded_algebra.decompose_of_mem_ne],
        exact a_hom,
        symmetry,
        exact hx, },
      { rw finset.mem_singleton at hx,
        rw [hx, graded_algebra.mem_support_iff, graded_algebra.proj_apply,
          graded_algebra.decompose_of_mem_same],
        exact INEQ,
        exact a_hom, }, },
    erw [set_eq1],
    have set_eq2 : finset.filter
          (Œª z : ‚Ñï √ó ‚Ñï, z.1 + z.2 = i + j)
          (finset.product
            {i}
            (graded_algebra.support ùíú b)) =
      {(i, j)},
    { ext1 x, rcases x with ‚ü®n1, n2‚ü©,
      split; intros ha,
      { erw finset.mem_filter at ha,
        rcases ha with ‚ü®ha1, ha3‚ü©,
        erw finset.mem_product at ha1,
        rcases ha1 with ‚ü®ha1, ha2‚ü©,
        dsimp only at ha1 ha2 ha3,
        erw finset.mem_singleton at ha1,
        erw finset.mem_singleton,
        ext; dsimp only,
        { exact ha1, },
        { erw ha1 at ha3,
          linarith, }, },
      { erw [finset.mem_singleton, prod.ext_iff] at ha,
        rcases ha with ‚ü®ha1, ha2‚ü©,
        dsimp only at ha1 ha2,
        erw [ha1, ha2, finset.mem_filter, finset.mem_product, finset.mem_singleton],
        refine ‚ü®‚ü®rfl, _‚ü©, rfl‚ü©,
        dsimp only,
        erw graded_algebra.mem_support_iff,
        exact hb, }, },
    erw [set_eq2, finset.sum_singleton],
    dsimp only,
    erw [graded_algebra.decompose_of_mem_same ùíú, ‚Üêgraded_algebra.proj_apply],
    exact a_hom,
end

end
