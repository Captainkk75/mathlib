/-
Copyright (c) 2021 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang, Eric Wieser
-/

import ring_theory.ideal.basic
import ring_theory.ideal.operations
import linear_algebra.finsupp
import ring_theory.graded_algebra.basic

/-!

# Homogeneous ideal of a graded algebra

This file defines homogeneous ideals of `graded_algebra A` where `A : ι → submodule R R`and
operations on them:
* `mul`, `inf`, `Inf` of homogeneous ideals are homogeneous;
* `⊤`, `⊥`, i.e. the trivial ring and `R` are homogeneous;
* `radical` of a homogeneous ideal is homogeneous.
-/

noncomputable theory


variables (R : Type*) [comm_ring R] {ι : Type*} [deq : decidable_eq ι]
variables (A : ι → submodule R R)

open_locale direct_sum pointwise big_operators
open set direct_sum set_like

section defs

/--A homogeneous ideal is an `I : ideal R` such that `I` is generated by
homogeneous elements in `I`.-/
def is_homogeneous_ideal' (I : ideal R) : Prop :=
  I = ideal.span {x | x ∈ I ∧ is_homogeneous A x}

/-- Given any ideal `I : R`, there is a homogeneous ideal generated by
the homogeneous elements of `I`-/
def homogeneous_ideal_of_ideal (I : ideal R) :
  ideal R := ideal.span (set_of (is_homogeneous A) ∩ I)

lemma homogeneous_ideal_of_ideal_le_ideal
  (I : ideal R) :
  homogeneous_ideal_of_ideal R A I ≤ I :=
begin
  rw homogeneous_ideal_of_ideal,
  conv_rhs { rw ←ideal.span_eq I },
  apply ideal.span_mono, exact (set_of (is_homogeneous A)).inter_subset_right ↑I,
end

variables [add_comm_monoid ι] [ga : graded_algebra A]
include ga
/--A homogeneous ideal is an `I : ideal R` such that `I` is generated by a set of
homogeneous elements.-/
def is_homogeneous_ideal (I : ideal R) : Prop :=
  ∃ S : set (homogeneous_submonoid A), I = ideal.span (coe '' S)

/--Equivalently, an `I : ideal R` is homogeneous iff for every element `r : I` and `i : ι`, the
degree `i` component of `r` is in `I`.-/
def is_homogeneous_ideal'' (I : ideal R) : Prop :=
  ∀ r : R, r ∈ I → ∀ i : ι, graded_algebra.proj A i r ∈ I

lemma is_homogeneous_ideal_iff_is_homogeneous_ideal'
  (I : ideal R) : is_homogeneous_ideal R A I ↔ is_homogeneous_ideal' R A I :=
⟨λ hI, begin
  obtain ⟨S, hS⟩ := hI,
  rw [is_homogeneous_ideal'], ext r, split; intro hr,
  { rw hS at hr,
    suffices : coe '' S ⊆ {x | x ∈ I ∧ is_homogeneous A x},
    exact (ideal.span_mono this) hr,
    intros s hs, split, rw hS,
    refine ideal.subset_span hs,
    obtain ⟨⟨s', homs'⟩, hs₁, hs₂⟩ := hs,
    convert homs', rw ←hs₂, refl },
  { obtain ⟨l, hl⟩ := (finsupp.mem_span_iff_total R _ _).mp hr,
    rw ←hl, apply ideal.sum_mem, rintros ⟨x, hx₁, hx₂⟩ hx₃,
    simp only [linear_map.id_coe, id.def, finsupp.mem_support_iff, linear_map.coe_smul_right,
      ne.def, smul_eq_mul, subtype.coe_mk] at hx₁ hx₂ hx₃ ⊢,
    exact ideal.mul_mem_left _ _ hx₁, }
end, λ hI, begin
  rw is_homogeneous_ideal' at hI,
  rw is_homogeneous_ideal,
  use { x : homogeneous_submonoid A | ↑x ∈ I },
  rw hI, congr, ext r, split; intros hr,
  { rcases hr with ⟨r_mem, ⟨i, r_eq⟩⟩,
    use r, exact ⟨i, r_eq⟩, refine ⟨_, rfl⟩,
    simp only [mem_set_of_eq, subtype.coe_mk], convert ←r_mem, },
  { rcases hr with ⟨⟨r', hr'⟩, hr₁, hr₂⟩,
    simp only [mem_set_of_eq, subtype.coe_mk] at hr₁,
    rw ←hr₂, rw ←hI at hr₁, refine ⟨hr₁, hr'⟩, }
end⟩

private lemma is_homogeneous_ideal.mul_homogeneous_element
  [Π (i : ι) (x : A i), decidable (x ≠ 0)]
  {I : ideal R} (HI : is_homogeneous_ideal R A I) (r x : R)
  (hx₁ : is_homogeneous A x) (hx₂ : x ∈ I) (j : ι) :
  graded_algebra.proj A j (r * x) ∈ I :=
begin
  rw [←graded_algebra.sum_support_decompose A r, finset.sum_mul, linear_map.map_sum],
  apply ideal.sum_mem,
  intros k hk,
  obtain ⟨i, hi⟩ := hx₁,
  have mem₁ : (graded_algebra.proj A k) r * x ∈ A (k + i) := graded_monoid.mul_mem
   (by { rw [graded_algebra.proj_apply], exact submodule.coe_mem _, }) hi,
  by_cases k + i = j,
  { rw ←h, rw graded_algebra.proj_apply at ⊢ mem₁,
    rw graded_algebra.decompose_of_mem A mem₁, simp only [of_eq_same, submodule.coe_mk],
    apply I.mul_mem_left _ hx₂, },
  { rw [graded_algebra.proj_apply, graded_algebra.decompose_of_mem_ne],
    exact I.zero_mem, exact mem₁, intro rid, apply h rid, }
end

lemma is_homogeneous_ideal.mem_iff [Π (i : ι) (x : A i), decidable (x ≠ 0)]
  (I : ideal R) (hI : is_homogeneous_ideal R A I) (r : R) :
  r ∈ I ↔ ∀ i : ι, graded_algebra.proj A i r ∈ I :=
⟨λ hr i, begin
  have hI' := hI,
  rw [is_homogeneous_ideal_iff_is_homogeneous_ideal', is_homogeneous_ideal', ideal.span,
    finsupp.span_eq_range_total] at hI', rw hI' at hr,
  obtain ⟨s, rfl⟩ := hr,
  rw [finsupp.total_apply, finsupp.sum, linear_map.map_sum],
  apply ideal.sum_mem, rintros ⟨a, ha₁, ⟨j, ha₂⟩⟩ ha₃,
  rw [smul_eq_mul],
  apply is_homogeneous_ideal.mul_homogeneous_element, exact hI, use j, exact ha₂, exact ha₁,
end, λ hr, begin
  rw ←graded_algebra.sum_support_decompose A r,
  apply ideal.sum_mem, intros c _, apply hr,
end⟩

private lemma is_homogeneous_ideal.homogeneous_component [Π (i : ι) (x : A i), decidable (x ≠ 0)]
  {I : ideal R} (HI : is_homogeneous_ideal R A I) (x : R) (hx : x ∈ I) (i : ι) :
  graded_algebra.proj A i x ∈ I :=
begin
  have HI' := HI,
  rw [is_homogeneous_ideal_iff_is_homogeneous_ideal', is_homogeneous_ideal', ideal.span,
      finsupp.span_eq_range_total] at HI',
  rw HI' at hx,
  obtain ⟨s, rfl⟩ := hx,
  rw [finsupp.total_apply, finsupp.sum, linear_map.map_sum],
  apply ideal.sum_mem,
  rintros ⟨j, ⟨hj₁, hj₂⟩⟩ hj₃,
  simp only [algebra.id.smul_eq_mul, subtype.coe_mk, smul_eq_mul],
  apply is_homogeneous_ideal.mul_homogeneous_element, exact HI, exact hj₂, exact hj₁,
end

lemma is_homogeneous_ideal_iff_is_homogeneous_ideal'' [Π (i : ι) (x : A i), decidable (x ≠ 0)]
  (I : ideal R) :
  is_homogeneous_ideal R A I ↔ is_homogeneous_ideal'' R A I :=
⟨λ HI, begin
  intros x hx i,
  apply is_homogeneous_ideal.homogeneous_component R A HI x hx,
end, λ HI, begin
  rw [is_homogeneous_ideal_iff_is_homogeneous_ideal', is_homogeneous_ideal'],
  ext, split; intro hx,
  { rw ←graded_algebra.sum_support_decompose A x,
    refine ideal.sum_mem _ _,
    intros j hj, specialize HI x hx j,
    rw ideal.mem_span, intros J HJ,
    refine HJ _,
    simp only [mem_set_of_eq],
    refine ⟨HI, _⟩, refine ⟨j, _⟩, exact submodule.coe_mem _, },
  { rw [ideal.mem_span] at hx,
    apply hx,
    intros y hy,
    exact hy.1,  },
end⟩

/--The three definitions above are all equivalent.-/
lemma is_homogeneous_ideal.equivalent [Π (i : ι) (x : A i), decidable (x ≠ 0)] (I : ideal R) :
  tfae [is_homogeneous_ideal R A I, is_homogeneous_ideal' R A I, is_homogeneous_ideal'' R A I] :=
begin
  tfae_have : 1↔2, exact is_homogeneous_ideal_iff_is_homogeneous_ideal' R A I,
  tfae_have : 1↔3, exact is_homogeneous_ideal_iff_is_homogeneous_ideal'' R A I,
  tfae_finish,
end

lemma is_homogeneous_ideal.homogeneous_ideal_of_ideal (I : ideal R) :
  is_homogeneous_ideal R A (homogeneous_ideal_of_ideal R A I) :=
begin
  use ({x | ↑x ∈ I}),
  rw homogeneous_ideal_of_ideal, congr, ext, split; intro hx;
  simp only [mem_inter_eq, mem_set_of_eq, set_like.mem_coe] at hx ⊢,
  use x, exact hx.1, refine ⟨hx.2, rfl⟩,
  obtain ⟨y, hy₁, hy₂⟩ := hx, simp only [mem_set_of_eq] at hy₁, split, rw ←hy₂,
  rcases y with ⟨y, ⟨i, hy₃⟩⟩, use i, refine hy₃,
  rw ←hy₂, refine hy₁,
end

end defs

section homogeneous_ideal

section defs

variables [add_comm_monoid ι] [graded_algebra A]
include deq

/--We collect all homogeneous ideal into a type.-/
def homogeneous_ideal : Type* := { I : ideal R // is_homogeneous_ideal R A I }

instance homogeneous_ideal.inhabited : inhabited (homogeneous_ideal R A) :=
{ default := ⟨⊥, begin use ∅, unfold_coes, rw [set.image_empty, ideal.span_empty], end⟩ }

instance homogeneous_ideal.has_bot : has_bot (homogeneous_ideal R A) :=
{ bot := ⟨⊥, begin use ∅, unfold_coes, rw [set.image_empty, ideal.span_empty], end⟩ }

instance homogeneous_ideal.has_top [Π (i : ι) (x : A i), decidable (x ≠ 0)] :
  has_top (homogeneous_ideal R A) :=
{ top := ⟨⊤, begin
  rw is_homogeneous_ideal_iff_is_homogeneous_ideal'',
  intros r _ i, simp only [submodule.mem_top],
end⟩ }

@[simp] lemma homogeneous_ideal.eq_top_iff [Π (i : ι) (x : A i), decidable (x ≠ 0)]
  (I : homogeneous_ideal R A) : I = ⊤ ↔ I.1 = ⊤ :=
⟨λ h, begin
  unfold has_top.top at h,
  rw h, refl,
end, λ h, begin
  have h' : I.val = (⊤ : homogeneous_ideal R A).val,
  unfold has_top.top, rw h, refl,
  apply subtype.val_injective h',
end⟩

instance homogeneous_ideal.has_le : has_le (homogeneous_ideal R A) :=
{ le := λ I J, I.1 ≤ J.1 }

instance homogeneous_ideal.order : preorder (homogeneous_ideal R A) :=
{ le_refl := λ I, by {unfold has_le.le, exact le_refl I.1, },
  le_trans := λ I J K HIJ HJK,
    by {unfold has_le.le at HIJ HJK ⊢, exact @le_trans _ _ I.1 J.1 K.1 HIJ HJK, },
  ..(homogeneous_ideal.has_le R A)}

instance homogeneous_ideal.has_mem : has_mem R (homogeneous_ideal R A) :=
{ mem := λ r I, r ∈ I.1 }

end defs

section operations

variables [add_comm_monoid ι] [graded_algebra A]
include deq

instance homogeneous_ideal.has_mul :
  has_mul (homogeneous_ideal R A) :=
{ mul := λ I J, begin
    obtain ⟨I, HI⟩ := I,
    obtain ⟨J, HJ⟩ := J,
    choose s₁ hI using HI,
    choose s₂ hJ using HJ,
    refine ⟨I * J, ⟨s₁ * s₂, _⟩⟩,
    rw [hI, hJ, ideal.span_mul_span'],
    apply congr_arg,
    ext, split; intro hx,
    { rw set.mem_mul at hx,
      obtain ⟨y1, y2, h1, h2, h3⟩ := hx,
      rw set.mem_image at h1, obtain ⟨z1, h1⟩ := h1,
      have hy1 : y1 ∈ set_like.homogeneous_submonoid A,
      rw ←h1.2, exact z1.2,
      rw set.mem_image at h2, obtain ⟨z2, h2⟩ := h2,
      have hy2 : y2 ∈ set_like.homogeneous_submonoid A,
      rw ←h2.2, exact z2.2,

      use y1 * y2, apply submonoid.mul_mem,
      exact hy1, exact hy2,
      refine ⟨_, h3⟩, rw set.mem_mul, use y1, assumption,
      use y2, assumption, tidy, },
    { rw set.mem_image at hx,
      obtain ⟨y, hy1, hy⟩ := hx,
      rw set.mem_mul at hy1 ⊢,
      obtain ⟨z1, z2, hz1, hz2, hz3⟩ := hy1,
      use z1, use z2, split, rw set.mem_image, use z1, refine ⟨hz1, rfl⟩,
      split, rw set.mem_image, use z2, refine ⟨hz2, rfl⟩, tidy, }
  end }

instance homogeneous_ideal.has_sup : has_sup (homogeneous_ideal R A) :=
{ sup := λ I J, begin
   obtain ⟨I, HI⟩ := I,
    obtain ⟨J, HJ⟩ := J,
    choose s₁ hI using HI,
    choose s₂ hJ using HJ,
    refine ⟨I ⊔ J, ⟨s₁ ∪ s₂, _⟩⟩,
    unfold_coes,
    rw [set.image_union, ideal.span, hI, hJ],
    exact (submodule.span_union _ _).symm,
end }

instance homogeneous_ideal.has_add : has_add (homogeneous_ideal R A) := ⟨(⊔)⟩

private lemma homogeneous_ideal.subset_inf
  (I : homogeneous_ideal R A) (J : homogeneous_ideal R A) :
  ideal.span {x | x ∈ I.1 ⊓ J.1 ∧ is_homogeneous A x} ≤ I.1 ⊓ J.1 :=
begin
  intros x hx,
  { split,
    { simp only [set_like.mem_coe],
      have HI := I.2,
      rw [is_homogeneous_ideal_iff_is_homogeneous_ideal', is_homogeneous_ideal'] at HI,
      rw [HI, ideal.mem_span], intros K HK,
      replace HK := ideal.span_mono HK,
      rw [ideal.span_eq] at HK,
      have eq₁ : ideal.span {x | x ∈ I.1 ⊓ J.1 ∧ is_homogeneous A x}
        ≤ ideal.span {x | x ∈ I ∧ is_homogeneous A x},
      { apply ideal.span_mono, rintros y ⟨⟨hy₁, _⟩, hy₂⟩, refine ⟨hy₁, hy₂⟩, },
      refine HK _, refine eq₁ hx, },
    { simp only [set_like.mem_coe],
      have HJ := J.2,
      rw [is_homogeneous_ideal_iff_is_homogeneous_ideal', is_homogeneous_ideal'] at HJ,
      rw [HJ, ideal.mem_span], intros K HK,
      replace HK := ideal.span_mono HK,
      rw [ideal.span_eq] at HK,
      have eq₁ : ideal.span {x | x ∈ I.1 ⊓ J.1 ∧ is_homogeneous A x}
        ≤ ideal.span {x | x ∈ J ∧ is_homogeneous A x},
      { apply ideal.span_mono, rintros y ⟨⟨_, hy₁⟩, hy₂⟩, refine ⟨hy₁, hy₂⟩, },
      refine HK _, refine eq₁ hx, }, },
end

private lemma homogeneous_ideal.inf_subset
  [Π (i : ι) (x : (λ (i : ι), ↥(A i)) i), decidable (x ≠ 0)]
  (I : homogeneous_ideal R A) (J : homogeneous_ideal R A) :
  I.1 ⊓ J.1 ≤ ideal.span {x | x ∈ I.1 ⊓ J.1 ∧ is_homogeneous A x} :=
begin
  rintro x ⟨hxi, hxj⟩,
  have hx : ∀ i, graded_algebra.proj A i x ∈ I.1 ⊓ J.1,
  { intro j, split; refine (is_homogeneous_ideal.mem_iff R A _ _ x).mp _ _,
    exact I.2,
    assumption, exact J.2, assumption, },

  rw [←graded_algebra.sum_support_decompose A x],
  refine ideal.sum_mem _ _,
  intros i hi, refine ideal.subset_span _, refine ⟨hx _, _⟩, refine ⟨i, _⟩,
  exact submodule.coe_mem _,
end

instance homogeneous_ideal.has_inf
  [Π (i : ι) (x : (λ (i : ι), ↥(A i)) i), decidable (x ≠ 0)] : has_inf (homogeneous_ideal R A) :=
{ inf := λ I J, begin
  refine ⟨I.1 ⊓ J.1, _⟩,
  rw [is_homogeneous_ideal_iff_is_homogeneous_ideal', is_homogeneous_ideal'],
  exact le_antisymm (homogeneous_ideal.inf_subset R A I J) (homogeneous_ideal.subset_inf R A I J),
end }

instance homogeneous_ideal.has_Inf [Π (i : ι) (x : A i), decidable (x ≠ 0)] :
  has_Inf (homogeneous_ideal R A) :=
{ Inf := λ ℐ, begin
  use Inf (set.image (λ x : homogeneous_ideal R A, x.val) ℐ),
  rw is_homogeneous_ideal_iff_is_homogeneous_ideal'',
  intros x Hx i, simp only [submodule.mem_Inf] at Hx ⊢,
  intros J HJ, simp only [set.mem_image, subtype.val_eq_coe] at HJ,
  obtain ⟨K, HK₁, HK₂⟩ := HJ, rw ←HK₂,
  have HK₃ := K.2,
  rw is_homogeneous_ideal_iff_is_homogeneous_ideal'' at HK₃,
  apply HK₃, apply Hx, simp only [set.mem_image, subtype.val_eq_coe], use K, exact ⟨HK₁, rfl⟩,
end }

end operations

end homogeneous_ideal
