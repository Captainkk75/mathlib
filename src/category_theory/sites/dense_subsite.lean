/-
Copyright (c) 2021 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import category_theory.sites.sheaf
import category_theory.sites.cover_preserving

/-!
# Dense subsites

We define `cover_dense` functors between sites as functors such that
1. For each object in `D`, there exists a covering sieve in `D` that factors through images of `G`.
2. For each map `f : G(X) ‚ü∂ G(Y)` in `D`, there exists a covering sieve `{ g·µ¢ }` in `C` such that
   each `G(g·µ¢) ‚â´ f` has a preimage wrt `G`.

## Main results

- `category_theory.factor_cover_sieve_exists`: If `G : C ‚•§ D` is cover-preserving and cover-dense,
then given any finite family of morphisms `{ f·µ¢ : X ‚ü∂ G(Y·µ¢) }`, there exists a covering sieve of
`X` that is generated by `{ g‚±º : G(Z‚±º) ‚ü∂ X }` such that each `g‚±º ‚â´ f·µ¢` has a preimage wrt `G`.
- `category_theory.compatible_preserving_of_dense_and_cover_preserving`: If a functor is faithful,
cover-preserving and cover-dense, then it is compatible-preserving.

## References

* [Elephant]: *Sketches of an Elephant*, ‚Ñ±. T. Johnstone: C2.2.
* https://ncatlab.org/nlab/show/dense+sub-site
* https://ncatlab.org/nlab/show/comparison+lemma

-/

universes v‚ÇÅ u‚ÇÅ u‚ÇÇ

namespace category_theory
section cover_dense
variables {C : Type*} [category C] {D : Type*} [category D] {E : Type*} [category E]
variables (J : grothendieck_topology C) (K : grothendieck_topology D)
variables {L : grothendieck_topology E}

/-- A structure that witnesses the fact that `f` factors through an image object of `G`. -/
@[nolint has_inhabited_instance]
structure factors_through_image_obj (G : C ‚•§ D) {V U : D} (f : V ‚ü∂ U) :=
(obj : C) (lift : V ‚ü∂ G.obj obj) (map : G.obj obj ‚ü∂ U) (fac : f = lift ‚â´ map)

/-- All the arrows in the presieve factors through an image object of `G`. -/
@[nolint has_inhabited_instance]
def all_factors_through_image_obj (G : C ‚•§ D) {U : D} (R : presieve U) :=
‚àÄ ‚¶ÉV‚¶Ñ {f : V ‚ü∂ U} (hf : R f), factors_through_image_obj G f

/--
A structure that witnesses the fact that `f` factors through an image object `G(W)` of `G`,
and that the map `G(W) ‚â´ f·µ¢` has a preimage wrt `G` for each `f·µ¢ ‚àà O`.
-/
@[nolint has_inhabited_instance]
structure factors_through_image_obj_and_map (G : C ‚•§ D) {V : D} {U : D} (f : V ‚ü∂ U)
  (O : finset (structured_arrow U G)) extends factors_through_image_obj G f :=
(premap : ‚àÄ (f : O), obj ‚ü∂ f.val.right)
(map_fac : ‚àÄ (f : O), G.map (premap f) = map ‚â´ f.val.hom)

/--
All the arrows in the presieve factors through an image object of `G`, and the composition of the
factor map with `f·µ¢` all has a preimage wrt `G` for each `f·µ¢ ‚àà O`.
-/
@[nolint has_inhabited_instance]
def all_factors_through_image_obj_and_map (G : C ‚•§ D) {U : D} (R : presieve U) (O) :=
‚àÄ ‚¶ÉV‚¶Ñ {f : V ‚ü∂ U} (hf : R f), factors_through_image_obj_and_map G f O

/-- Forgets the additional information about maps. -/
def all_through_both_to_through_obj {G : C ‚•§ D} {U} {R : presieve U} {O}
  (H : all_factors_through_image_obj_and_map G R O) : all_factors_through_image_obj G R :=
Œª V f hf, (H hf).to_factors_through_image_obj

lemma factors_through_image_obj_and_map.map_fac' {G : C ‚•§ D} {V : D} {U : D} {f : V ‚ü∂ U}
  {O : finset (structured_arrow U G)} (H : factors_through_image_obj_and_map G f O) (f' : O) :
  H.lift ‚â´ G.map (H.premap f') = f ‚â´ f'.val.hom :=
begin
  rw [H.map_fac f', ‚Üê category.assoc],
  congr,
  exact H.fac.symm
end

/--
A helper function that helps constructing a `factors_through_image_obj_and_map` from
`factors_through_image_obj`.
-/
def through_obj_to_through_both {G : C ‚•§ D} {U V} {f : V ‚ü∂ U}
  {O : finset (structured_arrow U G)} (H : factors_through_image_obj G f)
  (H' : ‚àÄ (f : O), { g : H.obj ‚ü∂ f.val.right // G.map g = H.map ‚â´ f.val.hom }) :
  factors_through_image_obj_and_map G f O :=
{ premap := Œª f, (H' f).1, map_fac := Œª f, (H' f).2, ..H}

/--
A functor `G : (C, J) ‚•§ (D, K)` is called `cover_dense` if
1. For each object in `D`, there exists a covering sieve in `D` that factors through images of `G`.
2. For each map `f : G(X) ‚ü∂ G(Y)` in `D`, there exists a covering sieve `{ g·µ¢ }` in `C` such that
   each `G(g·µ¢) ‚â´ f` has a preimage wrt `G`.

This definition can be found in https://ncatlab.org/nlab/show/dense+sub-site Definition 2.2.
-/
@[nolint has_inhabited_instance]
structure cover_dense (J : grothendieck_topology C) (K : grothendieck_topology D) (G : C ‚•§ D) :=
(obj          : ‚àÄ (U : D), K U)
(obj_fac      : ‚àÄ (U : D), all_factors_through_image_obj G (obj U))
(map          : ‚àÄ {U V : C} (f : G.obj U ‚ü∂ G.obj V), J U)
(map_fac_map  : ‚àÄ {U V W} (f : G.obj U ‚ü∂ G.obj V) {g : W ‚ü∂ U} (hg : map f g), W ‚ü∂ V)
(map_fac      : ‚àÄ {U V W} (f : G.obj U ‚ü∂ G.obj V) {g : W ‚ü∂ U} (hg : map f g),
                  G.map (map_fac_map f hg) = G.map g ‚â´ f)

/-- If `G` is full, then it suffices to provide the covering sieves for the objects. -/
def cover_dense_mk_of_full (J : grothendieck_topology C) (K : grothendieck_topology D) (G : C ‚•§ D)
  [full G] (create : ‚àÄ (U : D), Œ£ (S : K U), all_factors_through_image_obj G S) :
  cover_dense J K G :=
{ obj          := Œª U, (create U).1,
  obj_fac      := Œª U, (create U).2,
  map          := Œª U V f, ‚ü®_, J.top_mem U‚ü©,
  map_fac_map  := Œª U V W f g hg, g ‚â´ G.preimage f,
  map_fac      := Œª U V W f g hg, by simp }

variables {J} {K} {G : C ‚•§ D} (H : cover_dense J K G) (H' : cover_preserving J K G)
variables {X : D} {Y : C} (f : X ‚ü∂ G.obj Y) (S : K X) (HS : all_factors_through_image_obj G S)

/--
Actually the sieve geneated by all the arrows that factors through images of `G` is a covering sieve
of `U : D`/
-/
def cover_dense.obj' (H : cover_dense J K G) (U : D) : K U :=
‚ü®‚ü®Œª Y f, nonempty (factors_through_image_obj G f), Œª Y Z f ‚ü®hf‚ü© g,
  ‚ü®{ obj := hf.obj, lift := g ‚â´ hf.lift, map := hf.map, fac := by rw [category.assoc, ‚Üêhf.fac] }‚ü©‚ü©,
    K.superset_covering (Œª V f hf, ‚ü®H.obj_fac U hf‚ü©) (H.obj U).property‚ü©

/-- The witness of `obj'` analogue to `cover_dense.obj_fac`. -/
noncomputable
def cover_dense.obj_fac' (H : cover_dense J K G) (U : D) :
  all_factors_through_image_obj G (H.obj' U) := Œª V f hf, hf.some

/-- Every map wose target is in the image of `G` is in `obj'`. -/
lemma cover_dense.obj'_in (H : cover_dense J K G) {U : D} {V : C} (f : G.obj V ‚ü∂ U) :
  H.obj' U f := ‚ü®{ obj := V, lift := ùüô _, map := f, fac := by simp }‚ü©

include H H' f S HS

/-
In https://ncatlab.org/nlab/show/comparison+lemma, the definition of a dense subsite is given by
1. For each object in `D`, there exists a covering sieve in `D` that factors through images of `G`.
2. For each finite family of morphisms `f·µ¢ : X ‚ü∂ G(Y·µ¢)`, there exists a covering sieve of `X`
   that `all_factors_through_image_obj_and_map` wrt the family.

We will prove that our definition implies 2.
If the topology on `C` is the induced topology, then the converse also holds (not formalized).
-/

/--
Given a covering sieve in `D` that factors through images of `G`, we can construct another
covering sieve that furthermore factors through an image map when composed with `f·µ¢`.
-/
@[simps] def factor_cover_sieve_one : K X :=
begin
  split, apply K.bind_covering S.property,
  intros Z g hg,
  exact (K.pullback_stable (HS hg).lift
    (H'.cover_preserve (H.map ((HS hg).map ‚â´ f)).property) : _)
end

omit f S HS

/-
Thus given any finite family of morphisms `{ f·µ¢ : X ‚ü∂ G(Y·µ¢) }`, we may obtain a covering sieve of
`X` that factors through the image of `G`, and factors through an image map of `G` after composing
with each `f·µ¢` by repeated application of `factor_cover_sieve_one`.
-/
lemma factor_cover_sieve_exists (O : finset (structured_arrow X G)) :
  ‚àÉ (S : K X) (H‚ÇÅ : all_factors_through_image_obj_and_map G S O), true :=
begin
  classical,
  apply finset.induction_on O,
  { use H.obj X, split, swap, trivial,
    intros Y g hg,
    apply through_obj_to_through_both (H.obj_fac X hg),
    intro X, exfalso, exact X.2 },
  rintros f O' - ‚ü®S, hS, -‚ü©,
  use factor_cover_sieve_one H H' f.hom S (all_through_both_to_through_obj hS),
  split, swap, trivial,
  intros Y g hg,
  choose Y' g' f' H‚ÇÅ H‚ÇÇ H‚ÇÉ using hg,
  rcases presieve.get_functor_pushforward_structure H‚ÇÇ with ‚ü®Y'', g'', f'', H‚ÇÑ, H‚ÇÖ‚ü©,
  let : factors_through_image_obj G g :=
  { obj := Y'', lift := f'', map := G.map g'' ‚â´ (hS H‚ÇÅ).map, fac := by
    { rw [‚Üê H‚ÇÉ, ‚Üê category.assoc, ‚Üê H‚ÇÖ, category.assoc], congr, exact (hS H‚ÇÅ).fac } },
  apply through_obj_to_through_both this,
  rintros ‚ü®f‚ÇÄ, hf‚ÇÄ‚ü©,
  by_cases hf‚ÇÄ' : f‚ÇÄ = f,
  { cases hf‚ÇÄ',
    use H.map_fac_map ((hS H‚ÇÅ).map ‚â´ f.hom) H‚ÇÑ,
    rw category.assoc,
    exact H.map_fac _ H‚ÇÑ },
  { let hf‚ÇÄ' := finset.mem_of_mem_insert_of_ne hf‚ÇÄ hf‚ÇÄ',
    use g'' ‚â´ (hS H‚ÇÅ).premap ‚ü®f‚ÇÄ, hf‚ÇÄ'‚ü©,
    rw [G.map_comp, (hS H‚ÇÅ).map_fac ‚ü®_, hf‚ÇÄ'‚ü©, category.assoc] }
end

/-- The sieve that `all_factors_through_image_obj_and_map` wrt a `finset`. -/
noncomputable
def factor_cover_sieve {G : C ‚•§ D} (H : cover_dense J K G) (H' : cover_preserving J K G)
  {X : D} (O : finset (structured_arrow X G)) : K X :=
(factor_cover_sieve_exists H H' O).some

/-- The witness that `factor_cover_sieve` indeed factors through the image of `G`. -/
noncomputable
def factor_cover_sieve_factor {G : C ‚•§ D} (H : cover_dense J K G) (H' : cover_preserving J K G)
  {X : D} (O : finset (structured_arrow X G)) :
  all_factors_through_image_obj_and_map G (factor_cover_sieve H H' O) O :=
(factor_cover_sieve_exists H H' O).some_spec.some

end cover_dense

open presieve opposite structured_arrow
variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÅ} D]
variables {J : grothendieck_topology C} {K : grothendieck_topology D}
variables {G : C ‚•§ D} (H : cover_dense J K G) (H' : cover_preserving J K G)

include H H'

/-
We ought to show that for each `f‚ÇÅ ‚â´ G.map g‚ÇÅ = f‚ÇÇ ‚â´ G.map g‚ÇÇ`, the restriction of
`x` along the two paths are the same given `x` is compatible in the image of `G`.
-/
lemma functor_pushforward_compatible_of_dense_subsite
  (‚Ñ± : SheafOfTypes K)
  {Y‚ÇÅ Y‚ÇÇ : C} {X Z: D}
  (f‚ÇÅ : X ‚ü∂ G.obj Y‚ÇÅ) (f‚ÇÇ : X ‚ü∂ G.obj Y‚ÇÇ) (g‚ÇÅ : G.obj Y‚ÇÅ ‚ü∂ Z) (g‚ÇÇ : G.obj Y‚ÇÇ ‚ü∂ Z)
  (eq : f‚ÇÅ ‚â´ g‚ÇÅ = f‚ÇÇ ‚â´ g‚ÇÇ)
  (x‚ÇÅ : ‚Ñ±.val.obj (op (G.obj Y‚ÇÅ))) (x‚ÇÇ : ‚Ñ±.val.obj (op (G.obj Y‚ÇÇ)))
  (hx : ‚àÄ {X' : C} (f‚ÇÅ' : X' ‚ü∂ Y‚ÇÅ) (f‚ÇÇ' : X' ‚ü∂ Y‚ÇÇ) (h : G.map f‚ÇÅ' ‚â´ g‚ÇÅ = G.map f‚ÇÇ' ‚â´ g‚ÇÇ),
    ‚Ñ±.val.map (G.map f‚ÇÅ').op x‚ÇÅ = ‚Ñ±.val.map (G.map f‚ÇÇ').op x‚ÇÇ) :
  ‚Ñ±.val.map f‚ÇÅ.op x‚ÇÅ = ‚Ñ±.val.map f‚ÇÇ.op x‚ÇÇ :=
begin
  classical,
  let O := [mk f‚ÇÅ, mk f‚ÇÇ].to_finset,
  let f‚ÇÅ' : O := ‚ü®mk f‚ÇÅ, by simp‚ü©,
  let f‚ÇÇ' : O := ‚ü®mk f‚ÇÇ, by simp‚ü©,
  apply (‚Ñ±.property _ (factor_cover_sieve H H' O).property).is_separated_for.ext,
  intros Y f hf,
  let H := factor_cover_sieve_factor H H' O hf,
  simp only [‚Üê types_comp_apply (‚Ñ±.val.map _) (‚Ñ±.val.map _), ‚Üê ‚Ñ±.val.map_comp, ‚Üê op_comp],
  have e‚ÇÅ : _ = f ‚â´ f‚ÇÅ := H.map_fac' f‚ÇÅ',
  have e‚ÇÇ : _ = f ‚â´ f‚ÇÇ := H.map_fac' f‚ÇÇ',
  simp only [‚Üêe‚ÇÅ, ‚Üêe‚ÇÇ, op_comp, ‚Ñ±.val.map_comp, types_comp_apply],
  congr,
  apply hx (H.premap f‚ÇÅ') (H.premap f‚ÇÇ'),
  simp [H.map_fac f‚ÇÅ', H.map_fac f‚ÇÇ', eq],
end

/--
If a functor is faithful and cover-preserving and cover-dense, then it is compatible-preserving.
-/
def compatible_preserving_of_dense_and_cover_preserving [faithful G] : compatible_preserving K G :=
begin
  split,
  intros ‚Ñ± Z T x hx Y‚ÇÅ Y‚ÇÇ X f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ eq,
  apply functor_pushforward_compatible_of_dense_subsite H H' ‚Ñ± f‚ÇÅ f‚ÇÇ _ _ eq,
  intros X' f‚ÇÅ' f‚ÇÇ' eq',
  apply hx,
  apply G.map_injective,
  simpa using eq'
end

end category_theory
