import data.nat.prime
import tactic

open nat

lemma thing' {a b c : ℕ} (ha : 0 < a) (hab : a < b) (hbc : b < c)
  (recip : (1 : ℚ)/a + 1/b + 1/c = 1) :
  prime (a + b + c) :=
begin
  cases lt_or_ge a 3,
  { interval_cases a,
    { have : 0 < (1 : ℚ) / b,
      { rw one_div_pos,
        norm_cast,
        linarith },
      have : 0 < (1 : ℚ) / c,
      { rw one_div_pos,
        norm_cast,
        linarith },
      exfalso,
      simp only [cast_one, div_one] at recip,
      rw [add_assoc, add_eq_left_iff] at recip,
      have := add_pos ‹0 < (1 : ℚ) / b› ‹0 < (1 : ℚ) / c›,
      linarith },
    { rw add_assoc at recip,
      rw ←eq_sub_iff_add_eq' at recip,
      norm_num at recip,
      have : (c : ℚ) = (2 * b) / (b - 2),
      { rw ←eq_sub_iff_add_eq' at recip,
        apply_fun (λ x, 1 / x) at recip,
        rw [one_div, one_div, inv_inv'] at recip,
        rw recip,
        rw eq_div_iff,
        rw div_mul_eq_mul_div,
        rw div_eq_iff,
        simp only [mul_sub, one_mul, mul_one, one_div],
        have b0 : (b : ℚ) ≠ 0,
        { norm_cast,
          apply ne_of_gt,
          apply ha.trans hab },
        have : (2 : ℚ) ≠ 0,
        { norm_num },
        rw mul_right_comm (2 : ℚ),
        simp [b0, this],
        apply ne_of_gt,
        rw gt_iff_lt,
        rw sub_pos,
        apply one_div_lt_one_div_of_lt,
        norm_num,
        assumption_mod_cast,
        apply ne_of_gt,
        rw gt_iff_lt,
        rw sub_pos,
        assumption_mod_cast },
      have : (b : ℚ) < c,
      { assumption_mod_cast },
      rw ‹↑c = _› at this,
      have : b < 4,
      { rw lt_div_iff at this,
        rw mul_comm at this,
        rw mul_lt_mul_right at this,
        rw sub_lt_iff_lt_add at this,
        assumption_mod_cast,
        norm_cast,
        apply lt_trans ha hab,
        rw sub_pos,
        norm_cast,
        assumption },
      interval_cases b,
      clear this,
      clear this,
      norm_num at this,
      norm_cast at this,
      subst c,
      norm_num, } },
  { have : (1 : ℚ) / b < 1 / 3,
    { apply one_div_lt_one_div_of_lt,
      { norm_num },
      { norm_cast,
        apply lt_of_le_of_lt h hab } },
    have : (1 : ℚ) / c < 1 / 3,
    { apply one_div_lt_one_div_of_lt,
      { norm_num },
      { norm_cast,
        apply lt_of_le_of_lt h (hab.trans hbc) } },
    have : (1 : ℚ) / a ≤ 1 / 3,
    { apply one_div_le_one_div_of_le,
      { norm_num },
      { assumption_mod_cast } },
    linarith },
end

lemma thing {a b c : ℕ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)
  (hab : a ≠ b) (hac : a ≠ c) (hbc : b ≠ c)
  (recip : (1 : ℚ)/a + 1/b + 1/c = 1) :
  prime (a + b + c) :=
begin
  wlog hab' : a < b := lt_or_gt_of_ne hab using a b,
  wlog : a < b ∧ b < c using [a b c, a c b, c a b],
  { refine or.imp (and.intro hab') (λ t, _) (lt_or_gt_of_ne hbc),
    refine or.imp (λ z, ⟨z, t⟩) (λ z, ⟨z, hab'⟩) (lt_or_gt_of_ne hac) },
  { apply thing' ha hab' case.2 recip },
end
