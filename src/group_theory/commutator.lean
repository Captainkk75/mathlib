/-
Copyright (c) 2021 Jordan Brown, Thomas Browning, Patrick Lutz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jordan Brown, Thomas Browning, Patrick Lutz
-/

import group_theory.subgroup.basic
import tactic.group

/-!
# Commutators.

If `G` is a group and `H₁ H₂ : subgroup G`, then the commutator `⁅H₁, H₂⁆ : subgroup G`
is the subgroup of `G` generated by the commutators `⁅h₁, h₂⁆ = h₁ * h₂ * h₁⁻¹ * h₂⁻¹`.

## Main definitions

* `⁅g₁, g₂⁆` : the commutator of the elements `g₁` and `g₂`.
* `⁅H₁, H₂⁆` : the commutator of the subgroups `H₁` and `H₂`.
-/

variables {G G' : Type*} [group G] [group G'] (f : G →* G') (g₁ g₂ g₃ : G) (H₁ H₂ H₃ : subgroup G)

lemma commutator_element_inv : ⁅g₁, g₂⁆⁻¹ = ⁅g₂, g₁⁆ :=
by simp_rw [commutator_element_def, mul_inv_rev, inv_inv, mul_assoc]

lemma map_commutator_element : f ⁅g₁, g₂⁆ = ⁅f g₁, f g₂⁆ :=
by simp_rw [commutator_element_def, f.map_mul, f.map_inv]

lemma conjugate_commutator_element : g₃ * ⁅g₁, g₂⁆ * g₃⁻¹ = ⁅g₃ * g₁ * g₃⁻¹, g₃ * g₂ * g₃⁻¹⁆ :=
map_commutator_element (mul_aut.conj g₃).to_monoid_hom g₁ g₂

namespace subgroup

/-- The commutator of two subgroups `H₁` and `H₂`. -/
instance commutator : has_bracket (subgroup G) (subgroup G) :=
⟨λ H₁ H₂, closure {g | ∃ (g₁ ∈ H₁) (g₂ ∈ H₂), ⁅g₁, g₂⁆ = g}⟩

lemma commutator_def : ⁅H₁, H₂⁆ = closure {g | ∃ (g₁ ∈ H₁) (g₂ ∈ H₂), ⁅g₁, g₂⁆ = g} := rfl

variables {g₁ g₂} {H₁ H₂ H₃}

lemma commutator_mem_commutator (h₁ : g₁ ∈ H₁) (h₂ : g₂ ∈ H₂) : ⁅g₁, g₂⁆ ∈ ⁅H₁, H₂⁆ :=
subset_closure ⟨g₁, h₁, g₂, h₂, rfl⟩

lemma commutator_le : ⁅H₁, H₂⁆ ≤ H₃ ↔ ∀ (g₁ ∈ H₁) (g₂ ∈ H₂), ⁅g₁, g₂⁆ ∈ H₃ :=
H₃.closure_le.trans ⟨λ h g₁ h₁ g₂ h₂, h ⟨g₁, h₁, g₂, h₂, rfl⟩,
  λ h g ⟨g₁, h₁, g₂, h₂, h_eq⟩, h_eq ▸ h g₁ h₁ g₂ h₂⟩

lemma commutator_mono {K₁ K₂ : subgroup G} (h₁ : H₁ ≤ K₁) (h₂ : H₂ ≤ K₂) : ⁅H₁, H₂⁆ ≤ ⁅K₁, K₂⁆ :=
commutator_le.mpr (λ g₁ hg₁ g₂ hg₂, commutator_mem_commutator (h₁ hg₁) (h₂ hg₂))

variables (H₁ H₂)

lemma commutator_comm_le : ⁅H₁, H₂⁆ ≤ ⁅H₂, H₁⁆ :=
commutator_le.mpr (λ g₁ h₁ g₂ h₂,
  commutator_element_inv g₂ g₁ ▸ ⁅H₂, H₁⁆.inv_mem_iff.mpr (commutator_mem_commutator h₂ h₁))

lemma commutator_comm : ⁅H₁, H₂⁆ = ⁅H₂, H₁⁆ :=
le_antisymm (commutator_comm_le H₁ H₂) (commutator_comm_le H₂ H₁)

section normal

instance commutator_normal [h₁ : H₁.normal] [h₂ : H₂.normal] : normal ⁅H₁, H₂⁆ :=
begin
  let base : set G := {g | ∃ (g₁ ∈ H₁) (g₂ ∈ H₂), ⁅g₁, g₂⁆ = g},
  change (closure base).normal,
  suffices h_base : base = group.conjugates_of_set base,
  { rw h_base,
    exact subgroup.normal_closure_normal },
  apply set.subset.antisymm group.subset_conjugates_of_set,
  intros a h,
  simp_rw [group.mem_conjugates_of_set_iff, is_conj_iff] at h,
  rcases h with ⟨b, ⟨c, hc, e, he, rfl⟩, d, rfl⟩,
  exact ⟨d * c * d⁻¹, h₁.conj_mem c hc d, d * e * d⁻¹, h₂.conj_mem e he d, by group⟩,
end

lemma commutator_def' [H₁.normal] [H₂.normal] :
  ⁅H₁, H₂⁆ = normal_closure {g | ∃ (g₁ ∈ H₁) (g₂ ∈ H₂), ⁅g₁, g₂⁆ = g} :=
le_antisymm closure_le_normal_closure (normal_closure_le_normal subset_closure)

lemma commutator_le_right [h : normal H₂] : ⁅H₁, H₂⁆ ≤ H₂ :=
commutator_le.mpr (λ g₁ h₁ g₂ h₂, H₂.mul_mem (h.conj_mem g₂ h₂ g₁) (H₂.inv_mem h₂))

lemma commutator_le_left [h : normal H₁] : ⁅H₁, H₂⁆ ≤ H₁ :=
commutator_comm H₂ H₁ ▸ commutator_le_right H₂ H₁

@[simp] lemma commutator_bot : ⁅H₁, ⊥⁆ = (⊥ : subgroup G) :=
le_bot_iff.mp (commutator_le_right H₁ ⊥)

@[simp] lemma bot_commutator : ⁅(⊥ : subgroup G), H₂⁆ = (⊥ : subgroup G) :=
le_bot_iff.mp (commutator_le_left ⊥ H₂)

lemma commutator_le_inf [normal H₁] [normal H₂] : ⁅H₁, H₂⁆ ≤ H₁ ⊓ H₂ :=
le_inf (commutator_le_left H₁ H₂) (commutator_le_right H₁ H₂)

end normal

lemma map_commutator : map f ⁅H₁, H₂⁆ = ⁅map f H₁, map f H₂⁆ :=
begin
  rw [le_antisymm_iff, map_le_iff_le_comap, commutator_le, commutator_le],
  refine ⟨λ g₁ h₁ g₂ h₂, _, _⟩,
  { rw [mem_comap, map_commutator_element],
    exact commutator_mem_commutator ⟨g₁, h₁, rfl⟩ ⟨g₂, h₂, rfl⟩ },
  { rintros _ ⟨g₁, h₁, rfl⟩ _ ⟨g₂, h₂, rfl⟩,
    rw ← map_commutator_element,
    refine mem_map_of_mem f (commutator_mem_commutator h₁ h₂) },
end

lemma general_commutator_prod_prod (K₁ K₂ : subgroup G') :
  ⁅H₁.prod K₁, H₂.prod K₂⁆ = ⁅H₁, H₂⁆.prod ⁅K₁, K₂⁆ :=
begin
  refine le_antisymm (commutator_le.mpr (λ g₁ h₁ g₂ h₂, ⟨commutator_mem_commutator h₁.1 h₂.1,
    commutator_mem_commutator h₁.2 h₂.2⟩)) _,
  rw [prod_le_iff, map_commutator, map_commutator]; split; apply commutator_mono;
  simp [le_prod_iff, map_map, monoid_hom.fst_comp_inl, monoid_hom.snd_comp_inl,
      monoid_hom.fst_comp_inr, monoid_hom.snd_comp_inr],
end

/-- The commutator of direct product is contained in the direct product of the commutators.

See `commutator_pi_pi_of_fintype` for equality given `fintype η`.
-/
lemma commutator_pi_pi_le {η : Type*} {Gs : η → Type*} [∀ i, group (Gs i)]
  (H K : Π i, subgroup (Gs i)) : ⁅pi set.univ H, pi set.univ K⁆ ≤ pi set.univ (λ i, ⁅H i, K i⁆) :=
commutator_le.mpr $ λ g₁ h₁ g₂ h₂ i hi, commutator_mem_commutator (h₁ i hi) (h₂ i hi)

/-- The commutator of a finite direct product equals the direct product of the commutators. -/
lemma commutator_pi_pi_of_fintype {η : Type*} [fintype η] {Gs : η → Type*}
  [∀ i, group (Gs i)] (H K : Π i, subgroup (Gs i)) :
  ⁅pi set.univ H, pi set.univ K⁆ = pi set.univ (λ i, ⁅H i, K i⁆) :=
begin
  classical,
  apply le_antisymm (commutator_pi_pi_le H K),
  { rw pi_le_iff, intros i hi,
    rw map_commutator,
    apply commutator_mono;
    { rw le_pi_iff,
      rintros j hj _ ⟨_, ⟨x, hx, rfl⟩, rfl⟩,
      by_cases h : j = i,
      { subst h, simpa using hx, },
      { simp [h, one_mem] }, }, },
end

end subgroup
