/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/
import category_theory.limits.colimit_limit2
import category_theory.limits.shapes.finite_limits

/-!
# Filtered colimits commute with finite limits.

We show that for a functor `F : J √ó K ‚•§ Type v`, when `J` is finite and `K` is filtered,
the universal morphism `colimit_limit_to_limit_colimit F` comparing the
colimit (over `K`) of the limits (over `J`) with the limit of the colimits is an isomorphism.

(In fact, to prove that it is injective only requires that `J` has finitely many objects.)

## References
* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4
* [Stacks: Filtered colimits](https://stacks.math.columbia.edu/tag/002W)
-/

universes v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ u‚ÇÉ

open category_theory
open category_theory.category
open category_theory.limits.types
open category_theory.limits.types.filtered_colimit

namespace category_theory.limits

variables {J : Type u‚ÇÅ} {K : Type u‚ÇÇ} [category.{v‚ÇÅ} J] [category.{v‚ÇÇ} K]

variables (F : J ‚•§ K ‚•§ Type u‚ÇÉ)

variables {cj : Œ† (j : J), cone (F.obj j)}
variables {ck : Œ† (k : K), cocone (F.flip.obj k)}
variables (tj : Œ† (j : J), is_limit (cj j))
variables (tk : Œ† (k : K), is_colimit (ck k))
variables {c‚ÇÅ : cocone (cones_to_functor tj)} (t‚ÇÅ : is_colimit c‚ÇÅ)
variables {c‚ÇÇ : cone (cocones_to_functor tk)} (t‚ÇÇ : is_limit c‚ÇÇ)

variables [is_filtered J]
section
variables [fintype K]

lemma colimit_to_limit_injective :
  function.injective (colimit_to_limit tj tk t‚ÇÅ t‚ÇÇ) :=
begin
  classical,
  -- Suppose we have two terms `x y` in the colimit (over `K`) of the limits (over `J`),
  -- and that these have the same image under `colimit_limit_to_limit_colimit F`.
  intros x y h,
  -- These elements of the colimit have representatives somehwere:
  obtain ‚ü®kx, x, rfl‚ü© := jointly_surjective (cones_to_functor tj) t‚ÇÅ x,
  obtain ‚ü®ky, y, rfl‚ü© := jointly_surjective (cones_to_functor tj) t‚ÇÅ y,
  dsimp at x y,
  -- Since the images of `x` and `y` are equal in a limit, they are equal componentwise
  -- (indexed by `j : J`),
  replace h := Œª (j : K), congr_arg (c‚ÇÇ.œÄ.app j) h,
  change ‚àÄ j, (c‚ÇÅ.Œπ.app kx ‚â´ limits.colimit_to_limit tj tk t‚ÇÅ t‚ÇÇ ‚â´ c‚ÇÇ.œÄ.app j) x =
              (c‚ÇÅ.Œπ.app ky ‚â´ limits.colimit_to_limit tj tk t‚ÇÅ t‚ÇÇ ‚â´ c‚ÇÇ.œÄ.app j) y at h,
  simp_rw Œπ_colimit_to_limit_œÄ at h,
  dsimp at h,
  have : ‚àÄ (k : K), ‚àÉ (j : J) (f : kx ‚ü∂ j) (g : ky ‚ü∂ j),
              (F.flip.obj k).map f ((cj kx).œÄ.app k x) = (F.flip.obj k).map g ((cj ky).œÄ.app k y),
  { intro k,
    rw ‚Üêis_colimit_eq_iff _ (tk k),
    rw h },
  choose j f g w using this,

  -- We now use that `J` is filtered, picking some point to the right of all these
  -- morphisms `f k` and `g k`.
  let O : finset J := finset.univ.image j ‚à™ {kx, ky},
  have kxO : kx ‚àà O := finset.mem_union.mpr (or.inr (by simp)),
  have kyO : ky ‚àà O := finset.mem_union.mpr (or.inr (by simp)),
  have kjO : ‚àÄ k, j k ‚àà O := Œª j, finset.mem_union.mpr (or.inl (by simp)),

  let H : finset (Œ£' (X Y : J) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) :=
    (finset.univ).image (Œª k : K, ‚ü®kx, j k, kxO,
      finset.mem_union.mpr (or.inl (by simp)),
      f k‚ü©) ‚à™
    (finset.univ).image (Œª k : K, ‚ü®ky, j k, kyO,
      finset.mem_union.mpr (or.inl (by simp)),
      g k‚ü©),
  obtain ‚ü®S, T, W‚ü© := is_filtered.sup_exists O H,

  have fH : ‚àÄ k, (‚ü®kx, j k, kxO, kjO k, f k‚ü© : (Œ£' (X Y : J) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) ‚àà H :=
    Œª j, (finset.mem_union.mpr (or.inl
    begin
      simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true,
        finset.mem_image, heq_iff_eq],
      refine ‚ü®j, rfl, _‚ü©,
      simp only [heq_iff_eq],
      exact ‚ü®rfl, rfl, rfl‚ü©,
    end)),
  have gH : ‚àÄ k, (‚ü®ky, j k, kyO, kjO k, g k‚ü© : (Œ£' (X Y : J) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y)) ‚àà H :=
    Œª j, (finset.mem_union.mpr (or.inr
    begin
      simp only [true_and, finset.mem_univ, eq_self_iff_true, exists_prop_of_true,
        finset.mem_image, heq_iff_eq],
      refine ‚ü®j, rfl, _‚ü©,
      simp only [heq_iff_eq],
      exact ‚ü®rfl, rfl, rfl‚ü©,
    end)),
  rw is_colimit_eq_iff _ t‚ÇÅ,
  refine ‚ü®_, T kxO, T kyO, _‚ü©,
  apply is_limit_ext (tj _),
  intro k,
  change (limits.is_limit.map (cj kx) (tj S) (F.map (T kxO)) ‚â´ (cj S).œÄ.app k) x = (limits.is_limit.map (cj ky) (tj S) (F.map (T kyO)) ‚â´ (cj S).œÄ.app k) y,
  rw is_limit.map_œÄ,
  rw is_limit.map_œÄ,
  rw ‚Üê W _ _ (fH k),
  rw ‚Üê W _ _ (gH k),
  rw functor.map_comp,
  rw nat_trans.comp_app,
  rw functor.map_comp,
  rw nat_trans.comp_app,
  dsimp,
  have := w k,
  dsimp at this,
  rw this,
end

end

section

variables [fin_category K]

/--
This follows this proof from
* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4
although with different names.
-/
lemma colimit_limit_to_limit_colimit_surjective :
  function.surjective (colimit_to_limit tj tk t‚ÇÅ t‚ÇÇ) :=
begin
  classical,
  -- We begin with some element `x` in the limit (over K) over the colimits (over J),
  intro x,

  -- This consists of some coherent family of elements in the various colimits,
  -- and so our first task is to pick representatives of these elements.
  have z := Œª k, jointly_surjective _ (tk k) (c‚ÇÇ.œÄ.app _ x),

  -- `j : K ‚ü∂ J` records where the representative of the element in the `k`-th element of `x` lives
  -- `y j : F.obj (j, k j)` is the representative
  -- and we record that these representatives, when mapped back into the relevant colimits,
  -- are actually the components of `x`.
  choose j y e using z,

  -- As a first step, we use that `J` is filtered to pick some point `j' : J` above all the `j k`
  let j' : J := is_filtered.sup (finset.univ.image j) ‚àÖ,
  -- and name the morphisms as `g k : j k ‚ü∂ j'`.
  have g : Œ† k, j k ‚ü∂ j' := Œª k, is_filtered.to_sup (finset.univ.image j) ‚àÖ (by simp),
  clear_value j',

  -- Recalling that the components of `x`, which are indexed by `k : K`, are "coherent",
  -- in other words preserved by morphisms in the `K` direction,
  -- we see that for any morphism `f : k ‚ü∂ k'` in `K`,
  -- the images of `y k` and `y k'`, when mapped to `F.obj (k', j')` respectively by
  -- `(f, g k)` and `(ùüô k', g k')`, both represent the same element in the colimit.
  have w : ‚àÄ {k k' : K} (f : k ‚ü∂ k'),
              (ck k').Œπ.app j' ((F.map (g k')).app k' (y k')) =
              (ck k').Œπ.app j' ((F.obj j').map f ((F.map (g _)).app k (y k))),
  { intros k k' f,
    change ((F.flip.obj k').map (g k') ‚â´ (ck k').Œπ.app j') (y k') =
      ((F.flip.obj k).map (g k) ‚â´ (F.obj j').map f ‚â´ (ck k').Œπ.app j') (y k),
    rw (ck k').w,
    have : (F.flip.obj k).map (g k) ‚â´ (F.obj j').map f = (F.obj _).map f ‚â´ (F.flip.obj _).map (g _),
    { simp only [functor.flip_obj_map, nat_trans.naturality] },
    rw [reassoc_of this, (ck _).w, e, ‚Üê c‚ÇÇ.w f],
    change (tk k).map (ck k') (F.flip.map f) (c‚ÇÇ.œÄ.app k x) =
      (ck k').Œπ.app (j k) ((F.obj (j k)).map f (y k)),
    rw [‚Üê e, ‚Üê types_comp_apply ((ck k).Œπ.app (j k)) ((tk k).map (ck k') (F.flip.map f)) (y k),
      is_colimit.Œπ_map],
    refl },

  -- Because `J` is filtered, we can restate this as saying that
  -- for each such `f`, there is some place to the right of `j'`
  -- where these images of `y k` and `y k'` become equal.
  have w' : ‚àÄ (k k' : K) (f : k ‚ü∂ k'),
        ‚àÉ (j : J) (g' h' : j' ‚ü∂ j),
          (F.map g').app k' ((F.map (g k')).app k' (y k')) =
            (F.map h').app k' ((F.obj j').map f ((F.map (g k)).app k (y k))),
  { intros k k' f,
    specialize w f,
    rw is_colimit_eq_iff _ (tk k') at w,
    apply w },

  -- We take a moment to restate `w` more conveniently.
  choose jf gf hf wf using w',
  clear w,

  -- We're now ready to use the fact that `J` is filtered a second time,
  -- picking some place to the right of all of
  -- the morphisms `gf f : j' ‚ü∂ kh f` and `hf f : j' ‚ü∂ jf f`.
  -- At this point we're relying on there being only finitely morphisms in `K`.
  let O := finset.univ.bUnion (Œª k, finset.univ.bUnion (Œª k', finset.univ.image (jf k k'))) ‚à™ {j'},
  have jfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), jf _ _ f ‚àà O := Œª j j' f, finset.mem_union.mpr (or.inl (
  begin
    rw [finset.mem_bUnion],
    refine ‚ü®j, finset.mem_univ j, _‚ü©,
    rw [finset.mem_bUnion],
    refine ‚ü®j', finset.mem_univ j', _‚ü©,
    rw [finset.mem_image],
    refine ‚ü®f, finset.mem_univ _, _‚ü©,
    refl,
  end)),
  have j'O : j' ‚àà O := finset.mem_union.mpr (or.inr (finset.mem_singleton.mpr rfl)),
  let H : finset (Œ£' (X Y : J) (mX : X ‚àà O) (mY : Y ‚àà O), X ‚ü∂ Y) :=
    finset.univ.bUnion (Œª k : K, finset.univ.bUnion (Œª k' : K, finset.univ.bUnion (Œª f : k ‚ü∂ k',
      {‚ü®j', jf _ _ f, j'O, jfO f, gf _ _ f‚ü©, ‚ü®j', jf _ _ f, j'O, jfO f, hf _ _ f‚ü©}))),

  obtain ‚ü®j'', i', s'‚ü© := is_filtered.sup_exists O H,
  -- We then restate this slightly more conveniently, as a family of morphism `i f : jf _ _ f ‚ü∂ j''`,
  -- satisfying `gf f ‚â´ i f = hf f' ‚â´ i f'`.
  let i : Œ† {k k'} (f : k ‚ü∂ k'), jf _ _ f ‚ü∂ j'' := Œª k k' f, i' (jfO f),
  have s : ‚àÄ {k‚ÇÅ k‚ÇÇ k‚ÇÉ k‚ÇÑ} (f : k‚ÇÅ ‚ü∂ k‚ÇÇ) (f' : k‚ÇÉ ‚ü∂ k‚ÇÑ), gf _ _ f ‚â´ i f = hf _ _ f' ‚â´ i f',
  { intros,
    rw [s', s'],
    swap 2,
    exact j'O,
    swap 2,
    { rw [finset.mem_bUnion],
      refine ‚ü®k‚ÇÅ, finset.mem_univ _, _‚ü©,
      rw [finset.mem_bUnion],
      refine ‚ü®k‚ÇÇ, finset.mem_univ _, _‚ü©,
      rw [finset.mem_bUnion],
      refine ‚ü®f, finset.mem_univ _, _‚ü©,
      simp only [true_or, eq_self_iff_true, and_self, finset.mem_insert, heq_iff_eq], },
    { rw [finset.mem_bUnion],
      refine ‚ü®k‚ÇÉ, finset.mem_univ _, _‚ü©,
      rw [finset.mem_bUnion],
      refine ‚ü®k‚ÇÑ, finset.mem_univ _, _‚ü©,
      rw [finset.mem_bUnion],
      refine ‚ü®f', finset.mem_univ _, _‚ü©,
      simp only [eq_self_iff_true, or_true, and_self, finset.mem_insert, finset.mem_singleton,
        heq_iff_eq], } },
  clear_value i,
  clear s' i' H jfO j'O O,

  -- We're finally ready to construct the pre-image, and verify it really maps to `x`.
  fsplit,

  { -- We construct the pre-image (which, recall is meant to be a point
    -- in the colimit (over `J`) of the limits (over `K`)) via a representative at `j''`.
    apply c‚ÇÅ.Œπ.app j'' _,
    -- This representative is meant to be an element of a limit,
    -- so we need to construct a family of elements in `F.obj (j, k'')` for varying `j`,
    -- then show that are coherent with respect to morphisms in the `j` direction.
    apply types.is_limit.mk (tj j'') (Œª k, _) _,
    { -- We construct the elements as the images of the `y k`.
      apply (F.map _).app k (y k),
      apply g _ ‚â´ gf _ _ (ùüô _) ‚â´ i (ùüô k) },
    { -- After which it's just a calculation, using `s` and `wf`, to see they are coherent.
      intros k k' f,
      change (F.obj j'').map f ((F.map (g k ‚â´ gf k k (ùüô k) ‚â´ i (ùüô k))).app k (y k)) = (F.map (g k' ‚â´ gf k' k' (ùüô k') ‚â´ i (ùüô k'))).app k' (y k'),
      rw s (ùüô _) f,
      simp only [F.map_comp, nat_trans.comp_app],
      change ((F.map (g k)).app k ‚â´ (F.map (hf k k' f)).app k ‚â´ (F.map (i f)).app k ‚â´ (F.obj j'').map f) (y k) = _,
      have : (F.map (hf k k' f)).app k ‚â´ (F.map (i f)).app k ‚â´ (F.obj j'').map f
           = (F.obj _).map f ‚â´ (F.map (hf k k' f)).app _ ‚â´ (F.map (i f)).app _,
      { simp only [nat_trans.naturality, nat_trans.naturality_assoc] },
      rw this,
      change (F.map (i f)).app k' ((F.map (hf k k' f)).app k' ((F.obj j').map f ((F.map (g k)).app k (y k)))) =
        (F.map (i (ùüô k'))).app k' ((F.map (gf k' k' (ùüô k'))).app k' ((F.map (g k')).app k' (y k'))),
      rw ‚Üê wf _ _ f,
      change
        ((F.map (g k') ‚â´ F.map (gf k k' f) ‚â´ F.map (i f)).app k') (y k') =
          (F.map (g k') ‚â´ F.map (gf k' k' (ùüô k')) ‚â´ F.map (i (ùüô k'))).app k' (y k'),
      rw [‚Üê F.map_comp, ‚Üê F.map_comp, ‚Üê F.map_comp, ‚Üê F.map_comp, s (ùüô k') f, ‚Üê s f f] } },
  -- Finally we check that this maps to `x`.
  { -- We can do this componentwise:
    apply is_limit_ext t‚ÇÇ,
    intro k,
    rw ‚Üê e,
    change (c‚ÇÅ.Œπ.app j'' ‚â´ limits.colimit_to_limit tj tk t‚ÇÅ t‚ÇÇ ‚â´ c‚ÇÇ.œÄ.app k) _ = _,
    rw Œπ_colimit_to_limit_œÄ,
    dsimp only [types_comp_apply],

    -- and as each component is an equation in a colimit, we can verify it by
    -- pointing out the morphism which carries one representative to the other:
    rw [types.is_limit.œÄ_mk, is_colimit_eq_iff _ (tk k)],
    refine ‚ü®j'', ùüô _, g k ‚â´ gf _ _ (ùüô k) ‚â´ i (ùüô k), _‚ü©,
    simp only [functor.flip_obj_map, F.map_id, F.map_comp, nat_trans.comp_app, nat_trans.id_app,
      types_comp_apply, types_id_apply] },
end

noncomputable def filtered_colimit_finite_limit_iso : c‚ÇÅ.X ‚âÖ c‚ÇÇ.X :=
equiv.to_iso
  (equiv.of_bijective
    (colimit_to_limit tj tk t‚ÇÅ t‚ÇÇ)
    ‚ü®colimit_to_limit_injective _ _ _ _ _, colimit_limit_to_limit_colimit_surjective _ _ _ _ _‚ü©)

@[simp]
lemma filtered_colimit_finite_limit_iso_hom :
  (filtered_colimit_finite_limit_iso F tj tk t‚ÇÅ t‚ÇÇ).hom = colimit_to_limit tj tk t‚ÇÅ t‚ÇÇ :=
rfl

end

end category_theory.limits
