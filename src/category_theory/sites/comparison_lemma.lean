
import category_theory.sites.dense_subsite
import category_theory.sites.cover_lifting


namespace category_theory

universes v u

section
open limits
open opposite
open presieve
variables {C D : Type u} [category.{u} C] [category.{u} D] {G : C โฅค D}
variables {J : grothendieck_topology C} {K : grothendieck_topology D}
variables {A : Type v} [category.{u} A]
variables (H : cover_dense J K G) (H' : cover_preserving J K G)

namespace comparison_lemma
variables {โฑ โฑ' : SheafOfTypes K} (ฮฑ : G.op โ โฑ.val โถ G.op โ โฑ'.val)

/--
(Implementation). Given an hom between the pullbacks of two sheaves, we can whisker it with
`coyoneda` to obtain an hom between the pullbacks of the sheaves of maps from `X`.
-/
@[simps] def hom_over {โฑ โฑ' : Sheaf K A} (ฮฑ : G.op โ โฑ.val โถ G.op โ โฑ'.val) (X : A) :
  G.op โ (sheaf_over โฑ X).val โถ G.op โ (sheaf_over โฑ' X).val :=
whisker_right ฮฑ (coyoneda.obj (op X))

/--
(Implementation). Given an iso between the pullbacks of two sheaves, we can whisker it with
`coyoneda` to obtain an iso between the pullbacks of the sheaves of maps from `X`.
-/
@[simps] def iso_over {โฑ โฑ' : Sheaf K A} (ฮฑ : G.op โ โฑ.val โ G.op โ โฑ'.val) (X : A) :
  G.op โ (sheaf_over โฑ X).val โ G.op โ (sheaf_over โฑ' X).val :=
iso_whisker_right ฮฑ (coyoneda.obj (op X))


include H โฑ โฑ'
open structured_arrow
namespace types
/--
(Implementation). Given a section of `โฑ` on `X`, we can obtain a family of elements valued in `โฑ'`
that is defined on a cover generated by the images of `G`. -/
@[simp] noncomputable
def pushforward_family {X}
  (x : โฑ.val.obj (op X)) : family_of_elements โฑ'.val (H.obj' X) := ฮป Y f hf,
  โฑ'.val.map (H.obj_fac' _ hf).lift.op $ ฮฑ.app (op (H.obj_fac' X hf).obj) $
    โฑ.val.map (H.obj_fac' _ hf).map.op x

include H'

/-- (Implementation). The `pushforward_family` defined is compatible. -/
lemma pushforward_family_compatible {X} (x : โฑ.val.obj (op X)) :
  (pushforward_family H ฮฑ x).compatible :=
begin
  intros Yโ Yโ Z gโ gโ fโ fโ hโ hโ e,
  change (โฑ'.val.map (H.obj_fac' X hโ).lift.op โซ โฑ'.val.map gโ.op) _ =
  (โฑ'.val.map (H.obj_fac' X hโ).lift.op โซ โฑ'.val.map gโ.op) _,
  simp only [โfunctor.map_comp, โ op_comp],
  apply functor_pushforward_compatible_of_dense_subsite H H'
    โฑ' (gโ โซ (H.obj_fac' X hโ).lift) (gโ โซ (H.obj_fac' X hโ).lift)
    (H.obj_fac' X hโ).map (H.obj_fac' X hโ).map,
  { simp only [category.assoc],
    convert e,
    exact (H.obj_fac' _ hโ).fac.symm,
    exact (H.obj_fac' _ hโ).fac.symm },
  { intros X' fโ' fโ' eq',
    convert congr_fun _ x,
    change โฑ.val.map _ โซ ฮฑ.app (op _) โซ โฑ'.val.map _ =
      โฑ.val.map _ โซ ฮฑ.app (op _) โซ โฑ'.val.map _,
    erw [โ ฮฑ.naturality fโ'.op, โ ฮฑ.naturality fโ'.op],
    simp only [quiver.hom.unop_op, functor.comp_map, G.op_map,
    โ category.assoc, โ โฑ.val.map_comp, โop_comp, eq'] }
end

/-- (Implementation). The morphism `โฑ(X) โถ โฑ'(X)` given by glueing the `pushforward_family`. -/
noncomputable
def app_hom (X : D) : โฑ.val.obj (op X) โถ โฑ'.val.obj (op X) := ฮป x,
  (โฑ'.property _ (H.obj' X).property).amalgamate
    (pushforward_family H ฮฑ x)
    (pushforward_family_compatible H H' ฮฑ x)

lemma pushforward_family_apply {X} (x : โฑ.val.obj (op X)) {Y : C} {f : G.obj Y โถ X} :
  pushforward_family H ฮฑ x f (H.obj'_in f) = ฮฑ.app (op Y) (โฑ.val.map f.op x) :=
begin
  unfold pushforward_family, conv_rhs { rw (H.obj_fac' X (H.obj'_in f)).fac },
  refine eq.trans _ (functor_to_types.map_id_apply โฑ'.val _),
  rw โ op_id,
  apply functor_pushforward_compatible_of_dense_subsite H H' โฑ' _ _
    (H.obj_fac' X (H.obj'_in f)).map f,
  { rw โ(H.obj_fac' X (H.obj'_in f)).fac, simp },
  intros X' fโ' fโ' eq',
  simp only [functor_to_types.map_comp_apply, op_comp],
  change (โฑ.val.map _ โซ ฮฑ.app (op (H.obj_fac' X (H.obj'_in f)).obj) โซ โฑ'.val.map _) _
    = (โฑ.val.map _ โซ โฑ.val.map _ โซ ฮฑ.app (op Y) โซ โฑ'.val.map _) _,
  erw [โ ฮฑ.naturality fโ'.op, โ ฮฑ.naturality fโ'.op],
  simp only [quiver.hom.unop_op, functor.comp_map, G.op_map,
    โ category.assoc, โ โฑ.val.map_comp, โop_comp, eq'],
  conv_lhs { rw (H.obj_fac' X (H.obj'_in f)).fac },
  simp
end

@[simp] lemma app_hom_restrict {X : D} {Y : C} (f : op X โถ op (G.obj Y)) (x) :
  โฑ'.val.map f (app_hom H H' ฮฑ X x) = ฮฑ.app (op Y) (โฑ.val.map f x) :=
begin
  refine ((โฑ'.property _ (H.obj' X).property).valid_glue
    (pushforward_family_compatible H H' ฮฑ x) f.unop (H.obj'_in f.unop)).trans _,
  apply pushforward_family_apply,
  exact H',
end

@[simp] lemma app_hom_valid_glue {X : D} {Y : C} (f : op X โถ op (G.obj Y)) :
  (app_hom H H' ฮฑ X) โซ โฑ'.val.map f = โฑ.val.map f โซ ฮฑ.app (op Y) :=
by { ext, apply app_hom_restrict }

/--
(Implementation). The maps given in `app_iso` is inverse to each other and gives a `โฑ(X) โ โฑ'(X)`.
-/
@[simps] noncomputable
def app_iso (i : G.op โ โฑ.val โ G.op โ โฑ'.val) (X : D) :
  โฑ.val.obj (op X) โ โฑ'.val.obj (op X) :=
{ hom := app_hom H H' i.hom X,
  inv := app_hom H H' i.inv X,
  hom_inv_id' :=
  begin
    ext x,
    apply (โฑ.property _ (H.obj' X).property).is_separated_for.ext,
    intros Y f hf,
    rw (H.obj_fac' _ hf).fac,
    simp
  end,
  inv_hom_id' :=
  begin
    ext x,
    apply (โฑ'.property _ (H.obj' X).property).is_separated_for.ext,
    intros Y f hf,
    rw (H.obj_fac' _ hf).fac,
    simp
  end }

/--
Given an natural transformation `G โ โฑ โถ G โ โฑ'` between sheaves of types, we may obtain a
natural transformation between sheaves.
-/
@[simps] noncomputable
def sheaf_hom (ฮฑ : G.op โ โฑ.val โถ G.op โ โฑ'.val) : โฑ.val โถ โฑ'.val :=
{ app := ฮป X, app_hom H H' ฮฑ (unop X), naturality' := ฮป X Y f,
  begin
    ext x,
    apply (โฑ'.property _ (H.obj' (unop Y)).property).is_separated_for.ext,
    intros Y' f' hf',
    rw (H.obj_fac' _ hf').fac,
    simp only [app_hom_restrict, types_comp_apply, op_comp,
      functor_to_types.map_comp_apply, app_iso],
    change _ = โฑ'.val.map _ ((โฑ'.val.map _ โซ โฑ'.val.map _) _),
    rw [โ โฑ'.val.map_comp, โ f.op_unop, โ op_comp, app_hom_restrict],
    simp
  end }

/--
Given an natural isomorphsim `G โ โฑ โ G โ โฑ'` between sheaves of types, we may obtain a natural
isomorphism between sheaves.
-/
@[simps] noncomputable
def sheaf_iso (i : G.op โ โฑ.val โ G.op โ โฑ'.val) : โฑ.val โ โฑ'.val :=
nat_iso.of_components (ฮป X, app_iso H H' i (unop X)) (sheaf_hom H H' i.hom).naturality

end types
open types

include H'

@[simp, reassoc]
lemma app_hom_is_valid_glue (โฑ โฑ' : Sheaf K A) (i : G.op โ โฑ.val โ G.op โ โฑ'.val) (X) {Y U}
{f : Y โถ U} (hf : (H.obj' U).val f) (x) :
 app_hom H H' (iso_over i (unop X)).hom U x โซ โฑ'.val.map (H.obj_fac' U hf).map.op =
  x โซ โฑ.val.map (H.obj_fac' U hf).map.op โซ i.hom.app (op (H.obj_fac' U hf).obj) :=
(congr_fun (app_hom_valid_glue H H' (iso_over i (unop X)).hom (H.obj_fac' U hf).map.op) x).trans
  (by { rw โcategory.assoc, refl  })

@[simp]
lemma app_hom_apply_comp (โฑ โฑ' : Sheaf K A) (i : G.op โ โฑ.val โ G.op โ โฑ'.val) (X Y) (U) (x y) :
  app_hom H H' (iso_over i (unop X)).hom U (y โซ x) =
    y โซ app_hom H H' (iso_over i (unop Y)).hom U x :=
begin
  apply ((sheaf_over โฑ' (unop X)).property _ (H.obj' U).property).is_separated_for,
  apply is_sheaf_for.is_amalgamation,
  intros Y f h,
  conv_lhs { rw (H.obj_fac' _ h).fac },
  delta sheaf_over,
  simp only [pushforward_family, op_comp, functor_to_types.map_comp_apply, iso_over_hom_app,
    functor.comp_map, coyoneda_obj_map, category.assoc],
  congr' 1,
  simp
end

@[simp]
lemma app_hom_apply_comp_id (โฑ โฑ' : Sheaf K A) (i : G.op โ โฑ.val โ G.op โ โฑ'.val) (X) (U)
  (x : X โถ โฑ.val.obj U) :
  x โซ app_hom H H' (iso_over i (โฑ.val.obj U)).hom (unop U) (๐ _) =
    app_hom H H' (iso_over i X).hom (unop U) x :=
begin
  convert (app_hom_apply_comp H H' โฑ โฑ' i (op X) (op (โฑ.val.obj U)) (unop U) (๐ _) x).symm,
  exact (category.comp_id x).symm,
end

/-- (Implementation). The sheaf map given in `types.sheaf_hom` is natural in terms of `X`. -/
@[simps] noncomputable
def sheaf_coyoneda_hom (โฑ โฑ' : Sheaf K A) (ฮฑ : G.op โ โฑ.val โถ G.op โ โฑ'.val) :
  coyoneda โ (whiskering_left Dแตแต A (Type u)).obj โฑ.val โถ
  coyoneda โ (whiskering_left Dแตแต A (Type u)).obj โฑ'.val :=
{ app := ฮป X, sheaf_hom H H' (hom_over ฮฑ (unop X)), naturality' := ฮป X Y f,
  begin
  ext U x,
  change app_hom H H' (hom_over ฮฑ (unop Y)) (unop U) (f.unop โซ x) =
    f.unop โซ app_hom H H' (hom_over ฮฑ (unop X)) (unop U) x,
  apply ((sheaf_over โฑ' (unop Y)).property _ (H.obj' (unop U)).property).is_separated_for,
  apply is_sheaf_for.is_amalgamation,
  intros Y' f' h',
  dsimp[pushforward_family],
  conv_lhs { rw (H.obj_fac' _ h').fac },
  simp only [category.assoc, op_comp, functor.map_comp],
  congr' 1,
  simp only [โcategory.assoc],
  congr' 1,
  have := app_hom_restrict H H' (hom_over ฮฑ (unop X)) (H.obj_fac' (unop U) h').map.op x,
  refine this.trans _,
  dsimp, simp
  end }

/--
(Implementation). `sheaf_coyoneda_hom` but the order of the arguments of the functor are swapped.
-/
@[simps] noncomputable
def sheaf_yoneda_hom (โฑ โฑ' : Sheaf K A) (ฮฑ : G.op โ โฑ.val โถ G.op โ โฑ'.val) :
  โฑ.val โ yoneda โถ โฑ'.val โ yoneda :=
begin
  let ฮฑ := sheaf_coyoneda_hom H H' โฑ โฑ' ฮฑ,
  refine { app := _, naturality' := _ },
  { intro U,
    refine { app := ฮป X, (ฮฑ.app X).app U,
      naturality' := ฮป X Y f, by simpa using congr_app (ฮฑ.naturality f) U } },
  { intros U V i,
    ext X x,
    exact congr_fun ((ฮฑ.app X).naturality i) x },
end

/--
Given an natural transformation `G โ โฑ โถ G โ โฑ'` between sheaves of arbitrary category,
we may obtain a natural transformation between sheaves.
-/
@[simps] noncomputable
def sheaf_hom (โฑ โฑ' : Sheaf K A) (ฮฑ : G.op โ โฑ.val โถ G.op โ โฑ'.val) :
  โฑ.val โถ โฑ'.val :=
begin
  have ฮฑ' := sheaf_yoneda_hom H H' โฑ โฑ' ฮฑ,
  exact { app := ฮป X, yoneda.preimage (ฮฑ'.app X),
          naturality' := ฮป X Y f, yoneda.map_injective (by simpa using ฮฑ'.naturality f) }
end

/--
Given an natural isomorphism `G โ โฑ โ G โ โฑ'` between sheaves of arbitrary category,
we may obtain a natural isomorphism between sheaves.
-/
@[simps] noncomputable
def sheaf_iso (โฑ โฑ' : Sheaf K A) (i : G.op โ โฑ.val โ G.op โ โฑ'.val) :
  โฑ.val โ โฑ'.val :=
begin
  haveI : โ (X : Dแตแต), is_iso ((sheaf_hom H H' โฑ โฑ' i.hom).app X),
  { intro X,
    apply is_iso_of_reflects_iso _ yoneda,
    use (sheaf_yoneda_hom H H' โฑ' โฑ i.inv).app X,
    split;
      ext x : 2;
      simp only [sheaf_hom_app, nat_trans.comp_app, nat_trans.id_app, functor.image_preimage],
      exact ((sheaf_iso H H' (iso_over i (unop x))).app X).hom_inv_id,
      exact ((sheaf_iso H H' (iso_over i (unop x))).app X).inv_hom_id,
    apply_instance },
  haveI : is_iso (sheaf_hom H H' โฑ โฑ' i.hom) := by apply nat_iso.is_iso_of_is_iso_app,
apply as_iso (sheaf_hom H H' โฑ โฑ' i.hom),
end

/--
If the pullback map is given by whiskering,
then the result `sheaf_hom` is equal to the original one.
-/
lemma sheaf_hom_eq (โฑ โฑ' : Sheaf K A) (ฮฑ : โฑ.val โถ โฑ'.val) :
  ฮฑ = sheaf_hom H H' โฑ โฑ' (whisker_left G.op ฮฑ) :=
begin
  ext X,
  apply yoneda.map_injective,
  ext U,
  erw yoneda.image_preimage,
  apply ((sheaf_over โฑ' (unop U)).property _ (H.obj' (unop X)).property).is_separated_for,
  swap,
  apply is_sheaf_for.is_amalgamation,
  intros Y f hf,
  conv_lhs { rw (H.obj_fac' _ hf).fac },
  simpa,
  apply_instance
end

/--
Given an natural transformation `โฑ โถ โฑ'`, if its pullback wrt `G` is an iso, then it is also iso.
-/
lemma iso_of_restrict_iso {โฑ โฑ' : Sheaf K A} (ฮฑ : โฑ.val โถ โฑ'.val)
  (i : is_iso (whisker_left G.op ฮฑ)) : is_iso ฮฑ :=
begin
  convert is_iso.of_iso (sheaf_iso H H' โฑ โฑ' (as_iso (whisker_left G.op ฮฑ))),
  apply sheaf_hom_eq,
end

variables [has_limits A] (hG'' : cover_lifting J K G)

end comparison_lemma
end
end category_theory
