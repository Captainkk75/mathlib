/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Scott Morrison
-/
import algebra.homology.complex_shape
import category_theory.subobject.limits

/-!
# Homological complexes.

A `homological_complex V c` with a "shape" controlled by `c : complex_shape Œπ`
has chain groups `X i` (objects in `V`) indexed by `i : Œπ`,
and a differential `d i j` whenever `c.rel i j`.

We in fact ask for differentials `d i j` for all `i j : Œπ`,
but have a field `shape'` requiring that these are zero when not allowed by `c`.
This avoids a lot of dependent type theory hell!

The composite of any two differentials `d i j ‚â´ d j k` must be zero.

We provide `chain_complex V Œ±` for
`Œ±`-indexed chain complexes in which `d i j ‚â† 0` only if `j + 1 = i`,
and similarly `cochain_complex V Œ±`, with `i = j + 1`.

There is a category structure, where morphisms are chain maps.

For `C : homological_complex V c`, we define `C.X_next i`, which is either `C.X j` for some
arbitrarily chosen `j` such that `c.r i j`, or the zero object if there is no such `j`.
Similarly we have `C.X_prev j`.
Defined in terms of these we have `C.d_from i : C.X i ‚ü∂ C.X_next i` and
`C.d_to j : C.X_prev j ‚ü∂ C.X j`, which are either defined in as `C.d i j`, or zero, as needed.
-/

universes v u

open category_theory category_theory.limits

variables {Œπ : Type*}
variables (V : Type u) [category.{v} V] [has_zero_morphisms V]

/--
A `homological_complex V c` with a "shape" controlled by `c : complex_shape Œπ`
has chain groups `X i` (objects in `V`) indexed by `i : Œπ`,
and a differential `d i j` whenever `c.rel i j`.

We in fact ask for differentials `d i j` for all `i j : Œπ`,
but have a field `shape'` requiring that these are zero when not allowed by `c`.
This avoids a lot of dependent type theory hell!

The composite of any two differentials `d i j ‚â´ d j k` must be zero.
-/
structure homological_complex (c : complex_shape Œπ) :=
(X : Œπ ‚Üí V)
(d : Œ† i j, X i ‚ü∂ X j)
(shape' : ‚àÄ i j, ¬¨ c.rel i j ‚Üí d i j = 0 . obviously)
(d_comp_d' : ‚àÄ i j k, d i j ‚â´ d j k = 0 . obviously)

restate_axiom homological_complex.shape'
restate_axiom homological_complex.d_comp_d'

attribute [simp] homological_complex.shape
attribute [simp, reassoc] homological_complex.d_comp_d

/--
An `Œ±`-indexed chain complex is a `homological_complex`
in which `d i j ‚â† 0` only if `j + 1 = i`.
-/
abbreviation chain_complex (Œ± : Type*) [add_right_cancel_semigroup Œ±] [has_one Œ±] :=
homological_complex V (complex_shape.down Œ±)

/--
An `Œ±`-indexed cochain complex is a `homological_complex`
in which `d i j ‚â† 0` only if `i + 1 = j`.
-/
abbreviation cochain_complex (Œ± : Type*) [add_right_cancel_semigroup Œ±] [has_one Œ±] :=
homological_complex V (complex_shape.up Œ±)

@[simp] lemma chain_complex.prev (Œ± : Type*) [add_right_cancel_semigroup Œ±] [has_one Œ±] (i : Œ±) :
  (complex_shape.down Œ±).prev i = some ‚ü®i+1, rfl‚ü© :=
option.choice_eq _

@[simp] lemma chain_complex.next (Œ± : Type*) [add_group Œ±] [has_one Œ±] (i : Œ±) :
  (complex_shape.down Œ±).next i = some ‚ü®i-1, sub_add_cancel i 1‚ü© :=
option.choice_eq _

@[simp] lemma chain_complex.next_nat_zero :
  (complex_shape.down ‚Ñï).next 0 = none :=
option.choice_eq_none (by rintro ‚ü®j, ‚ü®‚ü©‚ü©)

@[simp] lemma chain_complex.next_nat_succ (i : ‚Ñï) :
  (complex_shape.down ‚Ñï).next (i+1) = some ‚ü®i, rfl‚ü© :=
option.choice_eq _

@[simp] lemma cochain_complex.prev (Œ± : Type*) [add_group Œ±] [has_one Œ±] (i : Œ±) :
  (complex_shape.up Œ±).prev i = some ‚ü®i-1, sub_add_cancel i 1‚ü© :=
option.choice_eq _

@[simp] lemma cochain_complex.next (Œ± : Type*) [add_right_cancel_semigroup Œ±] [has_one Œ±] (i : Œ±) :
  (complex_shape.up Œ±).next i = some ‚ü®i+1, rfl‚ü© :=
option.choice_eq _

@[simp] lemma cochain_complex.prev_nat_zero :
  (complex_shape.up ‚Ñï).prev 0 = none :=
option.choice_eq_none (by rintro ‚ü®j, ‚ü®‚ü©‚ü©)

@[simp] lemma cochain_complex.prev_nat_succ (i : ‚Ñï) :
  (complex_shape.up ‚Ñï).prev (i+1) = some ‚ü®i, rfl‚ü© :=
option.choice_eq _

namespace homological_complex
variables {V} {c : complex_shape Œπ} (C : homological_complex V c)

local attribute [instance] has_zero_object.has_zero

instance [has_zero_object V] : inhabited (homological_complex V c) :=
‚ü®{ X := Œª i, 0,
  d := Œª i j, 0, }‚ü©

/--
A morphism of homological complexes consists of maps between the chain groups,
commuting with the differentials.
-/
@[ext] structure hom (A B : homological_complex V c) :=
(f : ‚àÄ i, A.X i ‚ü∂ B.X i)
(comm' : ‚àÄ i j, f i ‚â´ B.d i j = A.d i j ‚â´ f j . obviously)

restate_axiom hom.comm'
attribute [simp, reassoc, elementwise] hom.comm

instance (A B : homological_complex V c) : inhabited (hom A B) :=
‚ü®{ f := Œª i, 0, }‚ü©

/-- Identity chain map. -/
def id (A : homological_complex V c) : hom A A :=
{ f := Œª _, ùüô _ }

/-- Composition of chain maps. -/
def comp (A B C : homological_complex V c) (œÜ : hom A B) (œà : hom B C) : hom A C :=
{ f := Œª i, œÜ.f i ‚â´ œà.f i }

section
local attribute [simp] id comp

instance : category (homological_complex V c) :=
{ hom := hom,
  id := id,
  comp := comp, }

end

@[simp] lemma id_f (C : homological_complex V c) (i : Œπ) : hom.f (ùüô C) i = ùüô (C.X i) := rfl
@[simp] lemma comp_f {C‚ÇÅ C‚ÇÇ C‚ÇÉ : homological_complex V c} (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) (g : C‚ÇÇ ‚ü∂ C‚ÇÉ) (i : Œπ) :
  (f ‚â´ g).f i = f.f i ‚â´ g.f i :=
rfl

-- We'll use this later to show that `homological_complex V c` is preadditive when `V` is.
lemma hom_f_injective {C‚ÇÅ C‚ÇÇ : homological_complex V c} :
  function.injective (Œª f : hom C‚ÇÅ C‚ÇÇ, hom.f f) :=
by tidy

instance : has_zero_morphisms (homological_complex V c) :=
{ has_zero := Œª C D, ‚ü®{ f := Œª i, 0, }‚ü© }

@[simp] lemma zero_apply (C D : homological_complex V c) (i : Œπ) :
  (0 : C ‚ü∂ D).f i = 0 := rfl

lemma congr_hom {C D : homological_complex V c} {f g : C ‚ü∂ D} (w : f = g) (i : Œπ) : f.f i = g.f i :=
congr_fun (congr_arg hom.f w) i

/--
Picking out the `i`-th object, as a functor.
-/
def eval_at (i : Œπ) : homological_complex V c ‚•§ V :=
{ obj := Œª C, C.X i,
  map := Œª C D f, f.f i, }

open_locale classical
noncomputable theory

/--
If `C.d i j` and `C.d i j'` are both allowed, then we must have `j = j'`,
and so the differentials only differ by an `eq_to_hom`.
-/
lemma d_comp_eq_to_hom {i j j' : Œπ} (rij : c.rel i j) (rij' : c.rel i j') :
  C.d i j' ‚â´ eq_to_hom (congr_arg C.X (c.next_eq rij' rij)) = C.d i j :=
begin
  have P : ‚àÄ h : j' = j, C.d i j' ‚â´ eq_to_hom (congr_arg C.X h) = C.d i j,
  { rintro rfl, simp, },
  apply P,
end

/--
If `C.d i j` and `C.d i' j` are both allowed, then we must have `i = i'`,
and so the differentials only differ by an `eq_to_hom`.
-/
lemma eq_to_hom_comp_d {i i' j : Œπ} (rij : c.rel i j) (rij' : c.rel i' j) :
  eq_to_hom (congr_arg C.X (c.prev_eq rij rij')) ‚â´ C.d i' j = C.d i j :=
begin
  have P : ‚àÄ h : i = i', eq_to_hom (congr_arg C.X h) ‚â´ C.d i' j = C.d i j,
  { rintro rfl, simp, },
  apply P,
end

lemma kernel_eq_kernel [has_kernels V] {i j j' : Œπ} (r : c.rel i j) (r' : c.rel i j') :
  kernel_subobject (C.d i j) = kernel_subobject (C.d i j') :=
begin
  rw ‚Üêd_comp_eq_to_hom C r r',
  apply kernel_subobject_comp_mono,
end

lemma image_eq_image [has_images V] [has_equalizers V]
  {i i' j : Œπ} (r : c.rel i j) (r' : c.rel i' j) :
  image_subobject (C.d i j) = image_subobject (C.d i' j) :=
begin
  rw ‚Üêeq_to_hom_comp_d C r r',
  apply image_subobject_iso_comp,
end

section

variables [has_zero_object V]
local attribute [instance] has_zero_object.has_zero

/-- Either `C.X i`, if there is some `i` with `c.rel i j`, or the zero object. -/
def X_prev (j : Œπ) : V :=
match c.prev j with
| none := 0
| (some ‚ü®i,_‚ü©) := C.X i
end

/-- If `c.rel i j`, then `C.X_prev j` is isomorphic to `C.X i`. -/
def X_prev_iso {i j : Œπ} (r : c.rel i j) :
  C.X_prev j ‚âÖ C.X i :=
begin
  apply eq_to_iso,
  dsimp [X_prev],
  rw c.prev_eq_some r,
  refl,
end

/-- If there is no `i` so `c.rel i j`, then `C.X_prev j` is isomorphic to `0`. -/
def X_prev_iso_zero {j : Œπ} (h : c.prev j = none) :
  C.X_prev j ‚âÖ 0 :=
begin
  apply eq_to_iso,
  dsimp [X_prev],
  rw h,
  refl,
end

/-- Either `C.X j`, if there is some `j` with `c.rel i j`, or the zero object. -/
def X_next (i : Œπ) : V :=
match c.next i with
| none := 0
| (some ‚ü®j,_‚ü©) := C.X j
end

/-- If `c.rel i j`, then `C.X_next i` is isomorphic to `C.X j`. -/
def X_next_iso {i j : Œπ} (r : c.rel i j) :
  C.X_next i ‚âÖ C.X j :=
begin
  apply eq_to_iso,
  dsimp [X_next],
  rw c.next_eq_some r,
  refl,
end

/-- If there is no `j` so `c.rel i j`, then `C.X_next i` is isomorphic to `0`. -/
def X_next_iso_zero {i : Œπ} (h : c.next i = none) :
  C.X_next i ‚âÖ 0 :=
begin
  apply eq_to_iso,
  dsimp [X_next],
  rw h,
  refl,
end

/--
The differential mapping into `C.X j`, or zero if there isn't one.
-/
def d_to (j : Œπ) : C.X_prev j ‚ü∂ C.X j :=
match c.prev j with
| none := (0 : C.X_prev j ‚ü∂ C.X j)
| (some ‚ü®i, w‚ü©) := (C.X_prev_iso w).hom ‚â´ C.d i j
end

/--
The differential mapping out of `C.X i`, or zero if there isn't one.
-/
def d_from (i : Œπ) : C.X i ‚ü∂ C.X_next i :=
match c.next i with
| none := (0 : C.X i ‚ü∂ C.X_next i)
| (some ‚ü®j, w‚ü©) := C.d i j ‚â´ (C.X_next_iso w).inv
end

lemma d_to_eq {i j : Œπ} (r : c.rel i j) :
  C.d_to j = (C.X_prev_iso r).hom ‚â´ C.d i j :=
begin
  dsimp [d_to, X_prev_iso],
  rw c.prev_eq_some r,
  refl,
end

@[simp]
lemma d_to_eq_zero {j : Œπ} (h : c.prev j = none) :
  C.d_to j = 0 :=
begin
  dsimp [d_to],
  rw h, refl,
end

lemma d_from_eq {i j : Œπ} (r : c.rel i j) :
  C.d_from i = C.d i j ‚â´ (C.X_next_iso r).inv :=
begin
  dsimp [d_from, X_next_iso],
  rw c.next_eq_some r,
  refl,
end

@[simp]
lemma d_from_eq_zero {i : Œπ} (h : c.next i = none) :
  C.d_from i = 0 :=
begin
  dsimp [d_from],
  rw h, refl,
end

@[simp, reassoc] lemma X_prev_iso_comp_d_to {i j : Œπ} (r : c.rel i j) :
  (C.X_prev_iso r).inv ‚â´ C.d_to j = C.d i j :=
by simp [C.d_to_eq r]

@[simp, reassoc] lemma X_prev_iso_zero_comp_d_to {j : Œπ} (h : c.prev j = none) :
  (C.X_prev_iso_zero h).inv ‚â´ C.d_to j = 0 :=
by simp [h]

@[simp, reassoc] lemma d_from_comp_X_next_iso {i j : Œπ} (r : c.rel i j) :
  C.d_from i ‚â´ (C.X_next_iso r).hom = C.d i j :=
by simp [C.d_from_eq r]

@[simp, reassoc] lemma d_from_comp_X_next_iso_zero {i : Œπ} (h : c.next i = none) :
  C.d_from i ‚â´ (C.X_next_iso_zero h).hom = 0 :=
by simp [h]

@[simp]
lemma d_to_comp_d_from (j : Œπ) : C.d_to j ‚â´ C.d_from j = 0 :=
begin
  rcases h‚ÇÅ : c.next j with _ | ‚ü®k,w‚ÇÅ‚ü©,
  { rw [d_from_eq_zero _ h‚ÇÅ], simp, },
  { rw [d_from_eq _ w‚ÇÅ],
    rcases h‚ÇÇ : c.prev j with _ | ‚ü®i,w‚ÇÇ‚ü©,
    { rw [d_to_eq_zero _ h‚ÇÇ], simp, },
    { rw [d_to_eq _ w‚ÇÇ], simp, } }
end

lemma kernel_from_eq_kernel [has_kernels V] {i j : Œπ} (r : c.rel i j) :
  kernel_subobject (C.d_from i) = kernel_subobject (C.d i j) :=
begin
  rw C.d_from_eq r,
  apply kernel_subobject_comp_mono,
end

lemma image_to_eq_image [has_images V] [has_equalizers V]
  {i j : Œπ} (r : c.rel i j) :
  image_subobject (C.d_to j) = image_subobject (C.d i j) :=
begin
  rw C.d_to_eq r,
  apply image_subobject_iso_comp,
end

end

namespace hom

variables {C‚ÇÅ C‚ÇÇ : homological_complex V c}
variables [has_zero_object V]
local attribute [instance] has_zero_object.has_zero

/-! Lemmas relating chain maps and `d_to`/`d_from`. -/

/-- `f.f_prev j` is `f.f i` if there is some `r i j`, and zero otherwise. -/
def f_prev (f : hom C‚ÇÅ C‚ÇÇ) (j : Œπ) : C‚ÇÅ.X_prev j ‚ü∂ C‚ÇÇ.X_prev j :=
match c.prev j with
| none := 0
| some ‚ü®i,w‚ü© := (C‚ÇÅ.X_prev_iso w).hom ‚â´ f.f i ‚â´ (C‚ÇÇ.X_prev_iso w).inv
end

lemma f_prev_eq (f : hom C‚ÇÅ C‚ÇÇ) {i j : Œπ} (w : c.rel i j) :
  f.f_prev j = (C‚ÇÅ.X_prev_iso w).hom ‚â´ f.f i ‚â´ (C‚ÇÇ.X_prev_iso w).inv :=
begin
  dsimp [f_prev],
  rw c.prev_eq_some w,
  refl,
end

/-- `f.f_next i` is `f.f j` if there is some `r i j`, and zero otherwise. -/
def f_next (f : hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : C‚ÇÅ.X_next i ‚ü∂ C‚ÇÇ.X_next i :=
match c.next i with
| none := 0
| some ‚ü®j,w‚ü© := (C‚ÇÅ.X_next_iso w).hom ‚â´ f.f j ‚â´ (C‚ÇÇ.X_next_iso w).inv
end

lemma f_next_eq (f : hom C‚ÇÅ C‚ÇÇ) {i j : Œπ} (w : c.rel i j) :
  f.f_next i = (C‚ÇÅ.X_next_iso w).hom ‚â´ f.f j ‚â´ (C‚ÇÇ.X_next_iso w).inv :=
begin
  dsimp [f_next],
  rw c.next_eq_some w,
  refl,
end

@[simp, reassoc, elementwise]
lemma comm_from (f : hom C‚ÇÅ C‚ÇÇ) (i : Œπ) :
  f.f i ‚â´ C‚ÇÇ.d_from i = C‚ÇÅ.d_from i ‚â´ f.f_next i :=
begin
  rcases h : c.next i with _ | ‚ü®j,w‚ü©,
  { simp [h], },
  { simp [d_from_eq _ w, f_next_eq _ w], }
end

@[simp, reassoc, elementwise]
lemma comm_to (f : hom C‚ÇÅ C‚ÇÇ) (j : Œπ) :
  f.f_prev j ‚â´ C‚ÇÇ.d_to j = C‚ÇÅ.d_to j ‚â´ f.f j :=
begin
  rcases h : c.prev j with _ | ‚ü®j,w‚ü©,
  { simp [h], },
  { simp [d_to_eq _ w, f_prev_eq _ w], }
end

/--
A morphism of chain complexes
induces a morphism of arrows of the differentials into each object.
-/
def sq_to (f : hom C‚ÇÅ C‚ÇÇ) (j : Œπ) : arrow.mk (C‚ÇÅ.d_to j) ‚ü∂ arrow.mk (C‚ÇÇ.d_to j) :=
arrow.hom_mk (f.comm_to j)

@[simp] lemma sq_to_right (f : hom C‚ÇÅ C‚ÇÇ) (j : Œπ) : (f.sq_to j).right = f.f j := rfl

section mk_inductive

variables (P Q : chain_complex V ‚Ñï)
  (zero : P.X 0 ‚ü∂ Q.X 0)
  (one : P.X 1 ‚ü∂ Q.X 1)
  (one_zero_comm : one ‚â´ Q.d 1 0 = P.d 1 0 ‚â´ zero)
  (succ : ‚àÄ (n : ‚Ñï)
    (p : Œ£' (f : P.X n ‚ü∂ Q.X n) (f' : P.X (n+1) ‚ü∂ Q.X (n+1)), f' ‚â´ Q.d (n+1) n = P.d (n+1) n ‚â´ f),
    Œ£' f'' : P.X (n+2) ‚ü∂ Q.X (n+2), f'' ‚â´ Q.d (n+2) (n+1) = P.d (n+2) (n+1) ‚â´ p.2.1)

/--
An auxiliary construction for `mk_inductive`.

Here we build by induction a family of commutative squares,
but don't require at the type level that these successive commutative squares actually agree.
They do in fact agree, and we then capture that at the type level (i.e. by constructing a chain map)
in `mk_inductive`.
-/
def mk_inductive_aux :
  Œ† n, Œ£' (f : P.X n ‚ü∂ Q.X n) (f' : P.X (n+1) ‚ü∂ Q.X (n+1)), f' ‚â´ Q.d (n+1) n = P.d (n+1) n ‚â´ f
| 0 := ‚ü®zero, one, one_zero_comm‚ü©
| (n+1) := ‚ü®(mk_inductive_aux n).2.1,
    (succ n (mk_inductive_aux n)).1, (succ n (mk_inductive_aux n)).2‚ü©

/--
A constructor for chain maps between `‚Ñï`-indexed chain complexes,
working by induction on commutative squares.

You need to provide the components of the chain map in degrees 0 and 1,
show that these form a commutative square,
and then give a construction of each component,
and the fact that it forms a commutative square with the previous component,
using as an inductive hypothesis the data (and commutativity) of the previous two components.
-/
def mk_inductive : P ‚ü∂ Q :=
{ f := Œª n, (mk_inductive_aux P Q zero one one_zero_comm succ n).1,
  comm' := Œª n m,
  begin
    by_cases h : m + 1 = n,
    { subst h,
      exact (mk_inductive_aux P Q zero one one_zero_comm succ m).2.2, },
    { rw [P.shape n m h, Q.shape n m h], simp, }
  end }

@[simp] lemma mk_inductive_f_0 : (mk_inductive P Q zero one one_zero_comm succ).f 0 = zero := rfl
@[simp] lemma mk_inductive_f_1 : (mk_inductive P Q zero one one_zero_comm succ).f 1 = one := rfl
@[simp] lemma mk_inductive_f_succ_succ (n : ‚Ñï) :
  (mk_inductive P Q zero one one_zero_comm succ).f (n+2) =
    (succ n ‚ü®(mk_inductive P Q zero one one_zero_comm succ).f n,
      (mk_inductive P Q zero one one_zero_comm succ).f (n+1),
        (mk_inductive P Q zero one one_zero_comm succ).comm (n+1) n‚ü©).1 :=
begin
  dsimp [mk_inductive, mk_inductive_aux],
  induction n; congr,
end

end mk_inductive

end hom

end homological_complex
