/-
Copyright (c) 2022 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang
-/
import algebraic_geometry.projective_spectrum.structure_sheaf
import algebraic_geometry.Spec

/-!
# Proj as a scheme

This file is to prove that `Proj` is a scheme.

## Notation

* `Proj`      : `Proj` as a locally ringed space
* `Proj.T`    : the underlying topological space of `Proj`
* `Proj| U`   : `Proj` restricted to some open set `U`
* `Proj.T| U` : the underlying topological space of `Proj` restricted to open set `U`
* `pbo f`     : basic open set at `f` in `Proj`
* `Spec`      : `Spec` as a locally ringed space
* `Spec.T`    : the underlying topological space of `Spec`
* `sbo g`     : basic open set at `g` in `Spec`
* `A‚Å∞_x`       : the degree zero part of localized ring `A‚Çì`

## Implementation

In `src/algebraic_geometry/projective_spectrum/structure_sheaf.lean`, we have given `Proj` a
structure sheaf so that `Proj` is a locally ringed space. In this file we will prove that `Proj`
equipped with this structure sheaf is a scheme. We achieve this by using an affine cover by basic
open sets in `Proj`, more specifically:

1. We prove that `Proj` can be covered by basic open sets at homogeneous element of positive degree.
2. We prove that for any `f : A`, `Proj.T | (pbo f)` is homeomorphic to `Spec.T A‚Å∞_f`:
  - forward direction `to_Spec`:
    for any `x : pbo f`, i.e. a relevant homogeneous prime ideal `x`, send it to
    `x ‚à© span {g / 1 | g ‚àà A}` (see `Proj_iso_Spec_Top_component.to_Spec.carrier`). This ideal is prime, the proof
    is in `Proj_iso_Spec_Top_component.to_Spec.to_fun`. The fact that this function is continuous is found in
    `Proj_iso_Spec_Top_component.to_Spec`
  - backward direction `from_Spec`:
    for any `q : Spec A‚Å∞_f`, we sent it to `{a | forall i, a·µ¢^m/f^i ‚àà q}`; we need this to be a homogeneous prime ideal that is relavent.
    * This is in fact an ideal, the proof can be found in `Proj_iso_Spec_Top_component.from_Spec.carrier.as_ideal`;
    * This ideal is also homogeneous, the proof can be found in `Proj_iso_Spec_Top_component.from_Spec.carrier.as_ideal.homogeneous`;
    * This ideal is relavent, the proof can be found in `Proj_iso_Spec_Top_component.from_Spec.carrier.relavent`;
    * This ideal is prime, the proof can be found in `Proj_iso_Spec_Top_component.from_Spec.carrier.prime`.
    Hence we have a well defined function `Spec.T A‚Å∞_f ‚Üí Proj.T | (pbo f)`, this function is called `Proj_iso_Spec_Top_component.from_Spec.to_fun`.
    But to prove the continuity of this function, we need to prove `from_Spec ‚àò to_Spec` and `to_Spec ‚àò from_Spec` are both identities.

## Main Definitions and Statements

* `degree_zero_part`: the degree zero part of the localized ring `A‚Çì` where `x` is a homogeneous
  element of degree `n` is the subring of elements of the form `a/f^m` where `a` has degree `mn`.

For a homogeneous element `f` of degree `n`
* `Proj_iso_Spec_Top_component.to_Spec`: `forward f` is the
  continuous map between `Proj.T| pbo f` and `Spec.T A‚Å∞_f`
* `Proj_iso_Spec_Top_component.to_Spec.preimage_eq`: for any `a: A`, if `a/f^m` has degree zero, then the preimage
  of `sbo a/f^m` under `to_Spec f` is `pbo f ‚à© pbo a`.


* [Robin Hartshorne, *Algebraic Geometry*][Har77]: Chapter II.2 Proposition 2.5
-/

noncomputable theory

namespace algebraic_geometry

open_locale direct_sum big_operators pointwise big_operators
open direct_sum set_like.graded_monoid localization finset (hiding mk_zero)

variables {R A : Type*}
variables [comm_ring R] [comm_ring A] [algebra R A]

variables (ùíú : ‚Ñï ‚Üí submodule R A)
variables [graded_algebra ùíú]

open Top topological_space
open category_theory opposite
open projective_spectrum.structure_sheaf

local notation `Proj` := Proj.to_LocallyRingedSpace ùíú
-- `Proj` as a locally ringed space
local notation `Proj.T` := Proj .1.1.1
-- the underlying topological space of `Proj`
local notation `Proj| ` U := Proj .restrict (opens.open_embedding (U : opens Proj.T))
-- `Proj` restrict to some open set
local notation `Proj.T| ` U :=
  (Proj .restrict (opens.open_embedding (U : opens Proj.T))).to_SheafedSpace.to_PresheafedSpace.1
-- the underlying topological space of `Proj` restricted to some open set
local notation `pbo` x := projective_spectrum.basic_open ùíú x
-- basic open sets in `Proj`
local notation `sbo` f := prime_spectrum.basic_open f
-- basic open sets in `Spec`
local notation `Spec` ring := Spec.LocallyRingedSpace_obj (CommRing.of ring)
-- `Spec` as a locally ringed space
local notation `Spec.T` ring :=
  (Spec.LocallyRingedSpace_obj (CommRing.of ring)).to_SheafedSpace.to_PresheafedSpace.1
-- the underlying topological space of `Spec`

section
variable {ùíú}
/--
The degree zero part of the localized ring `A‚Çì` is the subring of elements of the form `a/x^n` such
that `a` and `x^n` have the same degree.
-/
def degree_zero_part {f : A} {m : ‚Ñï} (f_deg : f ‚àà ùíú m) : subring (away f) :=
{ carrier := { y | ‚àÉ (n : ‚Ñï) (a : ùíú (m * n)), y = mk a.1 ‚ü®f^n, ‚ü®n, rfl‚ü©‚ü© },
  mul_mem' := Œª _ _ ‚ü®n, ‚ü®a, h‚ü©‚ü© ‚ü®n', ‚ü®b, h'‚ü©‚ü©, h.symm ‚ñ∏ h'.symm ‚ñ∏
    ‚ü®n+n', ‚ü®‚ü®a.1 * b.1, (mul_add m n n').symm ‚ñ∏ mul_mem a.2 b.2‚ü©,
    by {rw mk_mul, congr' 1, simp only [pow_add], refl }‚ü©‚ü©,
  one_mem' := ‚ü®0, ‚ü®1, (mul_zero m).symm ‚ñ∏ one_mem‚ü©,
    by { symmetry, convert ‚Üê mk_self 1, simp only [pow_zero], refl, }‚ü©,
  add_mem' := Œª _ _ ‚ü®n, ‚ü®a, h‚ü©‚ü© ‚ü®n', ‚ü®b, h'‚ü©‚ü©, h.symm ‚ñ∏ h'.symm ‚ñ∏
    ‚ü®n+n', ‚ü®‚ü®f ^ n * b.1 + f ^ n' * a.1, (mul_add m n n').symm ‚ñ∏
      add_mem (mul_mem (by { rw mul_comm, exact set_like.graded_monoid.pow_mem n f_deg }) b.2)
        begin
          rw add_comm,
          refine mul_mem _ a.2,
          rw mul_comm,
          exact set_like.graded_monoid.pow_mem _ f_deg
        end‚ü©, begin
          rw add_mk,
          congr' 1,
          simp only [pow_add],
          refl,
        end‚ü©‚ü©,
  zero_mem' := ‚ü®0, ‚ü®0, (mk_zero _).symm‚ü©‚ü©,
  neg_mem' := Œª x ‚ü®n, ‚ü®a, h‚ü©‚ü©, h.symm ‚ñ∏ ‚ü®n, ‚ü®-a, neg_mk _ _‚ü©‚ü© }

end

local notation `A‚Å∞_` f_deg := degree_zero_part f_deg

section

variable {ùíú}

instance (f : A) {m : ‚Ñï} (f_deg : f ‚àà ùíú m) : comm_ring (A‚Å∞_ f_deg) :=
(degree_zero_part f_deg).to_comm_ring

/--
Every element in the degree zero part of `A‚Çì` can be written as `a/x^n` for some `a` and `n : ‚Ñï`,
`degree_zero_part.deg` picks this natural number `n`
-/
def degree_zero_part.deg {f : A} {m : ‚Ñï} {f_deg : f ‚àà ùíú m} (x : A‚Å∞_ f_deg) : ‚Ñï :=
x.2.some

/--
Every element in the degree zero part of `A‚Çì` can be written as `a/x^n` for some `a` and `n : ‚Ñï`,
`degree_zero_part.deg` picks the numerator `a`
-/
def degree_zero_part.num {f : A} {m : ‚Ñï} {f_deg : f ‚àà ùíú m} (x : A‚Å∞_ f_deg) : A :=
x.2.some_spec.some.1

lemma degree_zero_part.num_mem {f : A} {m : ‚Ñï} {f_deg : f ‚àà ùíú m} (x : A‚Å∞_ f_deg) :
  degree_zero_part.num x ‚àà ùíú (m * degree_zero_part.deg x) :=
x.2.some_spec.some.2

lemma degree_zero_part.eq {f : A} {m : ‚Ñï} {f_deg : f ‚àà ùíú m} (x : A‚Å∞_ f_deg) :
  (x : away f) = mk (degree_zero_part.num x) ‚ü®f^(degree_zero_part.deg x), ‚ü®_, rfl‚ü©‚ü© :=
x.2.some_spec.some_spec

lemma degree_zero_part.coe_mul {f : A} {m : ‚Ñï} (f_deg : f ‚àà ùíú m) (x y : A‚Å∞_ f_deg) :
  (‚Üë(x * y) : away f) = x * y := rfl

end

namespace Proj_iso_Spec_Top_component

/-
This section is to construct the homeomorphism between `Proj` restricted at basic open set at
a homogeneous element `x` and `Spec A‚Å∞‚Çì` where `A‚Å∞‚Çì` is the degree zero part of the localized
ring `A‚Çì`.
-/

namespace to_Spec

open ideal

-- This section is to construct the forward direction :
-- So for any `x` in `Proj| (pbo f)`, we need some point in `Spec A‚Å∞_f`, i.e. a prime ideal,
-- and we need this correspondence to be continuous in their Zariski topology.

variables {ùíú} {f : A} {m : ‚Ñï} (f_deg : f ‚àà ùíú m) (x : Proj| (pbo f))

/--For any `x` in `Proj| (pbo f)`, the corresponding ideal in `Spec A‚Å∞_f`. This fact that this ideal
is prime is proven in `Top_component.forward.to_fun`-/
def carrier : ideal (A‚Å∞_ f_deg) :=
ideal.comap (algebra_map (A‚Å∞_ f_deg) (away f))
  (ideal.span $ algebra_map A (away f) '' x.1.as_homogeneous_ideal)

lemma mem_carrier_iff (z : A‚Å∞_ f_deg) :
  z ‚àà carrier f_deg x ‚Üî
  ‚Üëz ‚àà ideal.span (algebra_map A (away f) '' x.1.as_homogeneous_ideal) :=
iff.rfl

lemma mem_carrier.clear_denominator [decidable_eq (away f)]
  {z : A‚Å∞_ f_deg} (hz : z ‚àà carrier f_deg x) :
  ‚àÉ (c : algebra_map A (away f) '' x.1.as_homogeneous_ideal ‚Üí‚ÇÄ away f)
    (N : ‚Ñï)
    (acd : Œ† y ‚àà c.support.image c, A),
    f ^ N ‚Ä¢ ‚Üëz =
    algebra_map A (away f) (‚àë i in c.support.attach,
      acd (c i) (finset.mem_image.mpr ‚ü®i, ‚ü®i.2, rfl‚ü©‚ü©) * classical.some i.1.2) :=
begin
  rw [mem_carrier_iff, ‚Üêsubmodule_span_eq, finsupp.span_eq_range_total, linear_map.mem_range] at hz,
  rcases hz with ‚ü®c, eq1‚ü©,
  rw [finsupp.total_apply, finsupp.sum] at eq1,
  obtain ‚ü®‚ü®_, N, rfl‚ü©, hN‚ü© := is_localization.exist_integer_multiples_of_finset (submonoid.powers f)
    (c.support.image c),
  choose acd hacd using hN,
  have prop1 : ‚àÄ i, i ‚àà c.support ‚Üí c i ‚àà finset.image c c.support,
  { intros i hi, rw finset.mem_image, refine ‚ü®_, hi, rfl‚ü©, },

  refine ‚ü®c, N, acd, _‚ü©,
  rw [‚Üê eq1, smul_sum, map_sum, ‚Üê sum_attach],
  congr' 1,
  ext i,
  rw [_root_.map_mul, hacd, (classical.some_spec i.1.2).2, smul_eq_mul, smul_mul_assoc],
  refl
end

lemma disjoint :
  (disjoint (x.1.as_homogeneous_ideal.to_ideal : set A) (submonoid.powers f : set A)) :=
begin
  by_contra rid,
  rw [set.not_disjoint_iff] at rid,
  choose g hg using rid,
  obtain ‚ü®hg1, ‚ü®k, rfl‚ü©‚ü© := hg,
  by_cases k_ineq : 0 < k,
  { erw x.1.is_prime.pow_mem_iff_mem _ k_ineq at hg1,
    exact x.2 hg1 },
  { erw [show k = 0, by linarith, pow_zero, ‚Üêideal.eq_top_iff_one] at hg1,
    apply x.1.is_prime.1,
    exact hg1 },
end

lemma carrier_ne_top :
  carrier f_deg x ‚â† ‚ä§ :=
begin
  have eq_top := disjoint x,
  classical,
  contrapose! eq_top,
  obtain ‚ü®c, N, acd, eq1‚ü© := mem_carrier.clear_denominator _ x ((ideal.eq_top_iff_one _).mp eq_top),
  rw [algebra.smul_def, subring.coe_one, mul_one] at eq1,
  change localization.mk (f ^ N) 1 = mk (‚àë _, _) 1 at eq1,
  simp only [mk_eq_mk', is_localization.eq] at eq1,
  rcases eq1 with ‚ü®‚ü®_, ‚ü®M, rfl‚ü©‚ü©, eq1‚ü©,
  erw [mul_one, mul_one] at eq1,
  change f^_ * f^_ = _ * f^_ at eq1,
  rw set.not_disjoint_iff_nonempty_inter,
  refine ‚ü®f^N * f^M, eq1.symm ‚ñ∏ mul_mem_right _ _
    (sum_mem _ (Œª i hi, mul_mem_left _ _ _)), ‚ü®N+M, by rw pow_add‚ü©‚ü©,
  generalize_proofs h,
  exact (classical.some_spec h).1,
end

/--The function between the basic open set `D(f)` in `Proj` to the corresponding basic open set in
`Spec A‚Å∞_f`. This is bundled into a continuous map in `Top_component.forward`.
-/
def to_fun (x : Proj.T| (pbo f)) : (Spec.T (A‚Å∞_ f_deg)) :=
‚ü®carrier f_deg x, carrier_ne_top f_deg x, Œª x1 x2 hx12, begin
  classical,
  rcases ‚ü®x1, x2‚ü© with ‚ü®‚ü®x1, hx1‚ü©, ‚ü®x2, hx2‚ü©‚ü©,
  induction x1 using localization.induction_on with data_x1,
  induction x2 using localization.induction_on with data_x2,
  rcases ‚ü®data_x1, data_x2‚ü© with ‚ü®‚ü®a1, _, ‚ü®n1, rfl‚ü©‚ü©, ‚ü®a2, _, ‚ü®n2, rfl‚ü©‚ü©‚ü©,
  rcases mem_carrier.clear_denominator f_deg x hx12 with ‚ü®c, N, acd, eq1‚ü©,
  simp only [degree_zero_part.coe_mul, algebra.smul_def] at eq1,
  change localization.mk (f ^ N) 1 * (mk _ _ * mk _ _) = mk (‚àë _, _) _ at eq1,
  simp only [localization.mk_mul, one_mul] at eq1,
  simp only [mk_eq_mk', is_localization.eq] at eq1,
  rcases eq1 with ‚ü®‚ü®_, ‚ü®M, rfl‚ü©‚ü©, eq1‚ü©,
  rw [submonoid.coe_one, mul_one] at eq1,
  change _ * _ * f^_ = _ * (f^_ * f^_) * f^_ at eq1,

  rcases x.1.is_prime.mem_or_mem (show a1 * a2 * f ^ N * f ^ M ‚àà _, from _) with h1|rid2,
  rcases x.1.is_prime.mem_or_mem h1 with h1|rid1,
  rcases x.1.is_prime.mem_or_mem h1 with h1|h2,
  { left,
    rw mem_carrier_iff,
    simp only [show (mk a1 ‚ü®f ^ n1, _‚ü© : away f) = mk a1 1 * mk 1 ‚ü®f^n1, ‚ü®n1, rfl‚ü©‚ü©,
      by rw [localization.mk_mul, mul_one, one_mul]],
    exact ideal.mul_mem_right _ _ (ideal.subset_span ‚ü®_, h1, rfl‚ü©), },
  { right,
    rw mem_carrier_iff,
    simp only [show (mk a2 ‚ü®f ^ n2, _‚ü© : away f) = mk a2 1 * mk 1 ‚ü®f^n2, ‚ü®n2, rfl‚ü©‚ü©,
      by rw [localization.mk_mul, mul_one, one_mul]],
    exact ideal.mul_mem_right _ _ (ideal.subset_span ‚ü®_, h2, rfl‚ü©), },
  { exact false.elim (x.2 (x.1.is_prime.mem_of_pow_mem N rid1)), },
  { exact false.elim (x.2 (x.1.is_prime.mem_of_pow_mem M rid2)), },
  { rw [mul_comm _ (f^N), eq1],
    refine mul_mem_right _ _ (mul_mem_right _ _ (sum_mem _ (Œª i hi, mul_mem_left _ _ _))),
    generalize_proofs h,
    exact (classical.some_spec h).1 },
end‚ü©

/-
The preimage of basic open set `D(a/f^n)` in `Spec A‚Å∞_f` under the forward map from `Proj A` to
`Spec A‚Å∞_f` is the basic open set `D(a) ‚à© D(f)` in  `Proj A`. This lemma is used to prove that the
forward map is continuous.
-/
lemma preimage_eq (a : A) (n : ‚Ñï)
  (a_mem_degree_zero : (mk a ‚ü®f ^ n, ‚ü®n, rfl‚ü©‚ü© : away f) ‚àà A‚Å∞_ f_deg) :
  to_fun ùíú f_deg ‚Åª¬π'
      ((sbo (‚ü®mk a ‚ü®f ^ n, ‚ü®_, rfl‚ü©‚ü©, a_mem_degree_zero‚ü© : A‚Å∞_ f_deg)) :
        set (prime_spectrum {x // x ‚àà A‚Å∞_ f_deg}))
  = {x | x.1 ‚àà (pbo f) ‚äì (pbo a)} :=
begin
  classical,
  ext1 y, split; intros hy,
  { refine ‚ü®y.2, _‚ü©,
    rw [set.mem_preimage, opens.mem_coe, prime_spectrum.mem_basic_open] at hy,
    rw projective_spectrum.mem_coe_basic_open,
    intro a_mem_y,
    apply hy,
    rw [to_fun, mem_carrier_iff],
    simp only [show (mk a ‚ü®f^n, ‚ü®_, rfl‚ü©‚ü© : away f) = mk 1 ‚ü®f^n, ‚ü®_, rfl‚ü©‚ü© * mk a 1,
      by rw [mk_mul, one_mul, mul_one]],
    exact ideal.mul_mem_left _ _ (ideal.subset_span ‚ü®_, a_mem_y, rfl‚ü©), },
  { change y.1 ‚àà _ at hy,
    rcases hy with ‚ü®hy1, hy2‚ü©,
    rw projective_spectrum.mem_coe_basic_open at hy1 hy2,
    rw [set.mem_preimage, to_fun, opens.mem_coe, prime_spectrum.mem_basic_open],
    intro rid,
    rcases mem_carrier.clear_denominator f_deg _ rid with ‚ü®c, N, acd, eq1‚ü©,
    rw [algebra.smul_def] at eq1,
    change localization.mk (f^N) 1 * mk _ _ = mk (‚àë _, _) _ at eq1,
    rw [mk_mul, one_mul, mk_eq_mk', is_localization.eq] at eq1,
    rcases eq1 with ‚ü®‚ü®_, ‚ü®M, rfl‚ü©‚ü©, eq1‚ü©,
    rw [submonoid.coe_one, mul_one] at eq1,
    simp only [subtype.coe_mk] at eq1,

    rcases y.1.is_prime.mem_or_mem (show a * f ^ N * f ^ M ‚àà _, from _) with H1 | H3,
    rcases y.1.is_prime.mem_or_mem H1 with H1 | H2,
    { exact hy2 H1, },
    { exact y.2 (y.1.is_prime.mem_of_pow_mem N H2), },
    { exact y.2 (y.1.is_prime.mem_of_pow_mem M H3), },
    { rw [mul_comm _ (f^N), eq1],
      refine mul_mem_right _ _ (mul_mem_right _ _ (sum_mem _ (Œª i hi, mul_mem_left _ _ _))),
      generalize_proofs h,
      exact (classical.some_spec h).1, }, },
end

end to_Spec

section

variable {ùíú}

/--The continuous function between the basic open set `D(f)` in `Proj` to the corresponding basic
open set in `Spec A‚Å∞_f`.
-/
def to_Spec {f : A} (m : ‚Ñï) (f_deg : f ‚àà ùíú m) :
  (Proj.T| (pbo f)) ‚ü∂ (Spec.T (A‚Å∞_ f_deg)) :=
{ to_fun := to_Spec.to_fun ùíú f_deg,
  continuous_to_fun := begin
    apply is_topological_basis.continuous (prime_spectrum.is_topological_basis_basic_opens),
    rintros _ ‚ü®‚ü®g, hg‚ü©, rfl‚ü©,
    induction g using localization.induction_on with data,
    obtain ‚ü®a, ‚ü®_, ‚ü®n, rfl‚ü©‚ü©‚ü© := data,

    erw to_Spec.preimage_eq,
    refine is_open_induced_iff.mpr ‚ü®(pbo f).1 ‚äì (pbo a).1, is_open.inter (pbo f).2 (pbo a).2, _‚ü©,
    ext z, split; intros hz; simpa [set.mem_preimage],
  end }

end

namespace from_Spec

open graded_algebra finset (hiding mk_zero)
variable {ùíú}

variables {f : A} {m : ‚Ñï} {f_deg : f ‚àà ùíú m}

/--The underlying set-/
def carrier (q : Spec.T (A‚Å∞_ f_deg)) : set A :=
{a | ‚àÄ i, (‚ü®mk ((proj ùíú i a)^m) ‚ü®_, ‚ü®_, rfl‚ü©‚ü©, ‚ü®i, ‚ü®_, by exact set_like.graded_monoid.pow_mem m (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) ‚àà q.1}

lemma mem_carrier_iff (q : Spec.T (A‚Å∞_ f_deg)) (a : A) :
  a ‚àà carrier q ‚Üî ‚àÄ i, (‚ü®mk ((proj ùíú i a)^m) ‚ü®_, ‚ü®_, rfl‚ü©‚ü©, ‚ü®i, ‚ü®_, by exact set_like.graded_monoid.pow_mem m (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) ‚àà q.1 := iff.rfl

lemma carrier.zero_mem (hm : 0 < m) (q : Spec.T (A‚Å∞_ f_deg)) :
  (0 : A) ‚àà carrier q := Œª i,
by simpa only [linear_map.map_zero, zero_pow hm, mk_zero] using submodule.zero_mem _

lemma carrier.add_mem (q : Spec.T (A‚Å∞_ f_deg)) {a b : A}
  (ha : a ‚àà carrier q) (hb : b ‚àà carrier q) :
  a + b ‚àà carrier q :=
begin
  rw carrier at ha hb ‚ä¢,
  intro i,
  set Œ± := (‚ü®mk ((proj ùíú i (a + b))^m) ‚ü®f^i, ‚ü®_, rfl‚ü©‚ü©, ‚ü®i, ‚ü®_, by exact set_like.graded_monoid.pow_mem m (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg),
  suffices : Œ± * Œ± ‚àà q.1,
  { cases q.2.mem_or_mem this, assumption, assumption },
  { rw show Œ± * Œ± =
    ‚ü®mk ((proj ùíú i (a + b))^(2*m)) ‚ü®f^(2*i), ‚ü®_, rfl‚ü©‚ü©,
      ‚ü®2 * i, ‚ü®_, by { rw show m * (2 * i) = (2 * m) * i, by ring, exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _) }‚ü©, rfl‚ü©‚ü©,
    { rw [subtype.ext_iff_val, degree_zero_part.mul_val, mk_mul],
      congr' 1,
      { rw [two_mul, pow_add] },
      { simp only [subtype.ext_iff, submonoid.coe_mul, ‚Üê subtype.val_eq_coe, two_mul, pow_add],
        refl, } },
      clear Œ±,

      set s := ‚àë j in range (2 * m + 1), ((proj ùíú i) a)^j * ((proj ùíú i) b)^(2 * m - j) * (2 * m).choose j,
      set s' := ‚àë j in (range (2*m + 1)).attach, (proj ùíú i a)^j.1 * (proj ùíú i b)^(2 * m - j.1) * (2 * m).choose j.1,
      have ss' : s = s',
      { change finset.sum _ _ = finset.sum _ _,
        simp_rw [subtype.val_eq_coe],
        symmetry,
        convert sum_attach,
        refl, },
      have mem1 : (proj ùíú i) (a + b) ^ (2 * m) ‚àà ùíú (m * (2 * i)),
      { rw show m * (2 * i) = (2 * m) * i, by ring, exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _) },
      have eq1 : (proj ùíú i (a + b))^(2*m) = s,
      { rw [linear_map.map_add, add_pow] },
      rw calc (‚ü®mk ((proj ùíú i (a + b))^(2*m)) ‚ü®f^(2*i), ‚ü®_, rfl‚ü©‚ü©, ‚ü®2 * i, ‚ü®_, mem1‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg)
            = ‚ü®mk s ‚ü®f ^ (2 * i), ‚ü®_, rfl‚ü©‚ü©, ‚ü®2*i, ‚ü®s, eq1 ‚ñ∏ mem1‚ü©, rfl‚ü©‚ü©
            : begin
              erw [subtype.ext_iff_val],
              dsimp only,
              erw [linear_map.map_add, add_pow],
            end
        ... = ‚ü®mk s' ‚ü®f ^ (2 * i), ‚ü®_, rfl‚ü©‚ü©, ‚ü®2*i, ‚ü®s', ss' ‚ñ∏ eq1 ‚ñ∏ mem1‚ü©, rfl‚ü©‚ü© : by congr' 2
        ... = ‚àë j in (range (2 * m + 1)).attach,
                ‚ü®mk ((proj ùíú i a)^j.1 * (proj ùíú i b)^(2 * m - j.1) * (2 * m).choose j.1) ‚ü®f^(2 * i), ‚ü®2*i, rfl‚ü©‚ü©,
                ‚ü®2*i, ‚ü®_, begin
                  have mem1 : (proj ùíú i) a ^ j.1 ‚àà ùíú (j.1 * i),
                  { exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _), },
                  have mem2 : (proj ùíú i) b ^ (2 * m - j.1) ‚àà ùíú ((2*m-j.1) * i),
                  { exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _) },
                  have mem3 : ((2 * m).choose j.1 : A) ‚àà ùíú 0,
                  { exact set_like.graded_monoid.nat_mem _ _, },
                  rw show m * (2 * i) = ((j.1*i) + (2*m-j.1)*i + 0),
                  { zify,
                    rw [show (‚Üë(2 * m - j.1) : ‚Ñ§) = 2 * m - j.1,
                    { rw [eq_sub_iff_add_eq, ‚Üêint.coe_nat_add, nat.sub_add_cancel (nat.lt_succ_iff.mp (mem_range.mp j.2))],
                      refl, }, sub_mul, add_zero],
                    ring, },
                  apply set_like.graded_monoid.mul_mem _ mem3,
                  apply set_like.graded_monoid.mul_mem mem1 mem2,
                end‚ü©, rfl‚ü©‚ü©
            : by simp only [subtype.ext_iff_val, degree_zero_part.sum_val, localization.mk_sum],
      clear' s s' ss' eq1,
      apply ideal.sum_mem,
      intros k hk,
      by_cases ineq : m ‚â§ k.1,
      { -- use (proj ùíú i) a ^ k
        set Œ± := (‚ü®mk ((proj ùíú i) a ^ m) ‚ü®f^i, ‚ü®i, rfl‚ü©‚ü©, ‚ü®i, ‚ü®_, by exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg),
        set Œ≤ := (‚ü®mk ((proj ùíú i) a ^ (k.val - m) *
            (proj ùíú i) b ^ (2 * m - k.val) * (2*m).choose k.1) ‚ü®f^i, ‚ü®i, rfl‚ü©‚ü©, begin
              refine ‚ü®i, ‚ü®_, _‚ü©, rfl‚ü©,
              have mem1 : (proj ùíú i) a ^ (k.val - m) ‚àà ùíú ((k.val - m) * i),
              { exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _), },
              have mem2 : (proj ùíú i) b ^ (2 * m - k.val) ‚àà ùíú ((2*m-k.1) * i),
              { exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _), },
              have mem3 : ((2*m).choose k.1 : A) ‚àà ùíú 0,
              { exact set_like.graded_monoid.nat_mem _ _, },
              rw show m * i = ((k.val - m) * i) + ((2*m-k.1) * i) + 0,
              { rw [add_zero, ‚Üêadd_mul],
                congr' 1,
                symmetry,
                exact calc k.val - m + (2*m - k.val)
                          = (k.val + (2 * m - k.1)) - m : by { rw nat.sub_add_comm ineq, }
                      ... = (k.1 + 2 * m) - k.1 - m
                          : begin
                            rw ‚Üênat.add_sub_assoc,
                            have hk := k.2,
                            rw [finset.mem_range, nat.lt_succ_iff] at hk,
                            exact hk,
                          end
                      ... = 2 * m - m : by { rw nat.add_sub_cancel_left k.1 (2*m), }
                      ... = m + m - m : by { rw two_mul, }
                      ... = m : by rw nat.add_sub_cancel, },
              apply set_like.graded_monoid.mul_mem,
              apply set_like.graded_monoid.mul_mem,
              exact mem1, exact mem2, exact mem3,
            end‚ü© : A‚Å∞_ f_deg),
        suffices : Œ± * Œ≤ ‚àà q.1,
        { convert this,
          rw [mk_mul],
          congr' 1,
          { simp only [‚Üê mul_assoc],
            congr' 2,
            rw [‚Üê pow_add],
            congr' 1,
          symmetry,
          exact calc m + (k.1 - m)
                    = m + k.1 - m : by erw ‚Üênat.add_sub_assoc ineq
                ... = k.1 + m - m : by rw nat.add_comm
                ... = k.1 + (m-m) : by erw nat.add_sub_assoc (le_refl _)
                ... = k.1 + 0 : by rw nat.sub_self
                ... = k.1 : by rw add_zero },
          { simp only [two_mul, pow_add], refl, } },
        { apply ideal.mul_mem_right,
          apply ha, } },

      { set Œ± := (‚ü®mk ((proj ùíú i) b ^ m) ‚ü®f^i, ‚ü®_, rfl‚ü©‚ü©, ‚ü®i, ‚ü®_, by exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg),
        set Œ≤ := (‚ü®mk ((proj ùíú i) a ^ k.val * (proj ùíú i) b ^ (m - k.val) * ((2 * m).choose k.val))
          ‚ü®f^i, ‚ü®_, rfl‚ü©‚ü©, begin
            have mem1 : (proj ùíú i) a ^ k.val ‚àà ùíú (k.1 * i),
            { exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _), },
            have mem2 : (graded_algebra.proj ùíú i) b ^ (m - k.val) ‚àà ùíú ((m - k.1) * i),
            { exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _), },
            have mem3 : ‚Üë((2 * m).choose k.val) ‚àà ùíú 0,
            { apply set_like.graded_monoid.nat_mem, },
            refine ‚ü®_, ‚ü®_, _‚ü©, rfl‚ü©,
            rw ‚Üê show k.1 * i + (m - k.1) * i + 0 = m * i,
            { exact calc k.1 * i + (m - k.1) * i + 0
                      = k.1 * i + (m - k.1) * i : by { rw add_zero }
                  ... = (k.1 + (m - k.1)) * i : by { rw add_mul, }
                  ... = (k.1 + m - k.1) * i
                        : begin
                          rw nat.add_sub_assoc,
                          rw not_le at ineq,
                          apply le_of_lt,
                          exact ineq,
                        end
                  ... = m * i : by rw nat.add_sub_cancel_left, },
            apply set_like.graded_monoid.mul_mem,
            apply set_like.graded_monoid.mul_mem,
            exact mem1, exact mem2, exact mem3,
          end‚ü© : A‚Å∞_ f_deg),
        suffices : Œ± * Œ≤ ‚àà q.1,
        { convert this,
          rw [localization.mk_mul],
          congr' 1,
          { simp only [‚Üê mul_assoc],
            congr' 1,
            conv_rhs { rw [mul_comm _ (proj ùíú i a ^ k.1), mul_assoc] },
            congr' 1,
            simp only [‚Üê pow_add],
            congr' 1,
            rw [‚Üê nat.add_sub_assoc],
            congr' 1,
            rw [two_mul],
            rw not_le at ineq,
            apply le_of_lt,
            exact ineq, },
          { simp only [two_mul, pow_add],
            refl, } },
        { apply ideal.mul_mem_right,
          apply hb, } }, },
end

lemma carrier.smul_mem (hm : 0 < m) (q : Spec.T (A‚Å∞_ f_deg)) (c x : A) (hx : x ‚àà carrier q) :
  c ‚Ä¢ x ‚àà carrier q :=
begin
  classical,
  let ùíú' : ‚Ñï ‚Üí add_submonoid A := Œª i, (ùíú i).to_add_submonoid,
  letI : graded_ring ùíú' :=
    { decompose' := (direct_sum.decompose ùíú : A ‚Üí ‚®Å i, ùíú i),
      left_inv := direct_sum.decomposition.left_inv,
      right_inv := direct_sum.decomposition.right_inv,
      ..(by apply_instance : set_like.graded_monoid ùíú), },
  have mem_supr : ‚àÄ x, x ‚àà supr ùíú',
  { intro x,
    rw direct_sum.is_internal.add_submonoid_supr_eq_top ùíú'
      (direct_sum.decomposition.is_internal ùíú'),
    exact add_submonoid.mem_top x },

  refine add_submonoid.supr_induction ùíú' (mem_supr c) (Œª n a ha, _) _ _,
  { intros i,
    by_cases ineq1 : n ‚â§ i,
    { have eq1 : (graded_algebra.proj ùíú i) (a * x) =
          ite (i - n ‚àà (direct_sum.decompose_alg_equiv ùíú x).support) (a * (graded_algebra.proj ùíú (i - n)) x) 0,
      { exact calc (proj ùíú i) (a * x)
              = proj ùíú i ‚àë j in (direct_sum.decompose_alg_equiv ùíú x).support, (a * (proj ùíú j x))
              : begin
                conv_lhs { rw [‚Üê sum_support_decompose ùíú x] },
                simp_rw [proj_apply],
                rw [finset.mul_sum],
                refl,
              end
          ... = ‚àë j in (direct_sum.decompose_alg_equiv ùíú x).support, (proj ùíú i (a * (proj ùíú j x)))
              : by rw linear_map.map_sum
          ... = ‚àë j in (direct_sum.decompose_alg_equiv ùíú x).support, (ite (j = i - n) (proj ùíú i (a * (proj ùíú j x))) 0)
              : begin
                rw finset.sum_congr rfl,
                intros j hj,
                symmetry,
                split_ifs with H,
                refl,
                symmetry,
                have mem1 : a * graded_algebra.proj ùíú j x ‚àà ùíú (n + j),
                { exact mul_mem ha (submodule.coe_mem _), },
                rw graded_algebra.proj_apply,
                apply direct_sum.decompose_of_mem_ne ùíú mem1,
                intro rid,
                rw [‚Üêrid, add_comm, nat.add_sub_assoc, nat.sub_self, add_zero] at H,
                apply H, refl, refl,
              end
          ... = ‚àë j in (direct_sum.decompose_alg_equiv ùíú x).support,
                (ite (j = i - n) (a * (graded_algebra.proj ùíú j x)) 0)
              : begin
                rw finset.sum_congr rfl,
                intros j hj,
                split_ifs with eq1 ineq1,
                rw [graded_algebra.proj_apply, graded_algebra.proj_apply],
                apply direct_sum.decompose_of_mem_same,
                rw ‚Üêgraded_algebra.proj_apply,
                have eq2 : i = j + n,
                { rw [eq1, nat.sub_add_cancel], exact ineq1, },
                rw [eq2, add_comm],
                apply set_like.graded_monoid.mul_mem ha (submodule.coe_mem _),
                refl,
              end
          ... = ite (i - n ‚àà (direct_sum.decompose_alg_equiv ùíú x).support) (a * (proj ùíú (i - n)) x) 0 : by rw finset.sum_ite_eq', },

      split_ifs at eq1,
      { generalize_proofs h1 h2,
        erw calc
                (‚ü®mk ((proj ùíú i) (a * x) ^ m) ‚ü®f ^ i, h1‚ü©, h2‚ü© : A‚Å∞_ f_deg)
              = (‚ü®mk ((a * (proj ùíú (i - n) x))^m) ‚ü®f ^ i, h1‚ü©, eq1 ‚ñ∏ h2‚ü© : A‚Å∞_ f_deg)
              : by { simp only [subtype.ext_iff_val, eq1], }
          ... = (‚ü®localization.mk ((a^m * (graded_algebra.proj ùíú (i - n) x)^m))
                  ‚ü®f^i, h1‚ü©, by { rw [‚Üêmul_pow, ‚Üêeq1], exact h2 }‚ü© : A‚Å∞_ f_deg)
              : begin
                rw subtype.ext_iff_val,
                dsimp only,
                rw mul_pow,
              end
          ... = (‚ü®mk (a^m) ‚ü®f^n, ‚ü®_, rfl‚ü©‚ü©, begin
                  refine ‚ü®n, ‚ü®a^m, _‚ü©, rfl‚ü©,
                  exact set_like.graded_monoid.pow_mem m ha,
                end‚ü© : A‚Å∞_ f_deg) *
                (‚ü®mk ((proj ùíú (i-n) x)^m) ‚ü®f^(i-n), ‚ü®_, rfl‚ü©‚ü©, begin
                  refine ‚ü®i-n, ‚ü®(proj ùíú (i-n) x)^m, _‚ü©, rfl‚ü©,
                  dsimp only,
                  exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _),
                end‚ü© : A‚Å∞_ f_deg)
              : begin
                rw [subtype.ext_iff_val, degree_zero_part.mul_val],
                dsimp only,
                rw [localization.mk_mul],
                congr',
                dsimp only,
                rw ‚Üêpow_add,
                congr',
                rw [‚Üênat.add_sub_assoc, add_comm, nat.add_sub_assoc, nat.sub_self, add_zero],
                refl,
                exact ineq1,
              end,
        apply ideal.mul_mem_left,
        apply hx },
      { simp only [smul_eq_mul, eq1, zero_pow hm, localization.mk_zero],
        exact submodule.zero_mem _ } },
    { -- in this case, the left hand side is zero
      rw not_le at ineq1,
      convert submodule.zero_mem _,
      suffices : graded_algebra.proj ùíú i (a ‚Ä¢ x) = 0,
      erw [this, zero_pow hm, localization.mk_zero],

      rw [‚Üê sum_support_decompose ùíú x, smul_eq_mul, finset.mul_sum, linear_map.map_sum],
      simp_rw [‚Üêproj_apply],
      convert finset.sum_eq_zero _,
      intros j hj,
      rw [proj_apply],
      have mem1 : a * graded_algebra.proj ùíú j x ‚àà ùíú (n + j),
      { exact set_like.graded_monoid.mul_mem ha (submodule.coe_mem _), },
      apply direct_sum.decompose_of_mem_ne ùíú mem1,

      suffices : i < n + j,
      symmetry,
      apply ne_of_lt this,

      exact lt_of_lt_of_le ineq1 (nat.le_add_right _ _), }, },
  { rw zero_smul,
    apply carrier.zero_mem,
    exact hm, },
  { intros a b ha hb,
    rw add_smul,
    apply carrier.add_mem q ha hb, },
end

def carrier.as_ideal (hm : 0 < m) (q : Spec.T (A‚Å∞_ f_deg) ) :
  ideal A :=
{ carrier := carrier q,
  zero_mem' := carrier.zero_mem hm q,
  add_mem' := Œª a b, carrier.add_mem q,
  smul_mem' := carrier.smul_mem hm q }

lemma carrier.as_ideal.homogeneous  (hm : 0 < m) (q : Spec.T (A‚Å∞_ f_deg)) :
  (carrier.as_ideal hm q).is_homogeneous ùíú  :=
begin
  intros i a ha,
  rw ‚Üêgraded_algebra.proj_apply,
  change (proj _ i a) ‚àà carrier q,
  change a ‚àà carrier q at ha,
  intros j,
  have := calc (‚ü®mk ((proj ùíú j (proj ùíú i a)) ^ m) ‚ü®f^j, ‚ü®_, rfl‚ü©‚ü©, ‚ü®j, ‚ü®_, by exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg)
          = (‚ü®mk ((ite (j = i) (proj ùíú j a) 0)^m) ‚ü®f^j, ‚ü®_, rfl‚ü©‚ü©, begin
              refine ‚ü®j, ‚ü®((ite (j = i) (proj ùíú j a) 0)^m), _‚ü©, rfl‚ü©,
              have mem1 : ite (j = i) ((proj ùíú j) a) 0 ‚àà ùíú j,
              { split_ifs,
                exact submodule.coe_mem _,
                exact zero_mem _ },
              exact set_like.graded_monoid.pow_mem m mem1,
            end‚ü© : A‚Å∞_ f_deg)
            : begin
              rw [subtype.ext_iff_val],
              dsimp only,
              congr',
              split_ifs with eq1,
              rw [graded_algebra.proj_apply, graded_algebra.proj_apply, eq1],
              apply direct_sum.decompose_of_mem_same,
              rw [‚Üêgraded_algebra.proj_apply],
              exact submodule.coe_mem _,

              apply direct_sum.decompose_of_mem_ne ùíú (submodule.coe_mem _),
              symmetry, exact eq1,
            end
      ... = (‚ü®localization.mk ((ite (j = i) ((graded_algebra.proj ùíú j a)^m) 0))
            ‚ü®f^j, ‚ü®_, rfl‚ü©‚ü©, begin
              refine ‚ü®j, ‚ü®(ite (j = i) ((graded_algebra.proj ùíú j a)^m) 0), _‚ü©, rfl‚ü©,
              split_ifs,
              exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _),
              exact submodule.zero_mem _,
            end‚ü© : A‚Å∞_ f_deg)
            : begin
              rw [subtype.ext_iff_val],
              dsimp only,
              split_ifs, refl,
              rw zero_pow hm,
            end
      ... = ite (j = i)
            (‚ü®localization.mk ((graded_algebra.proj ùíú i a)^m) ‚ü®f^i, ‚ü®_, rfl‚ü©‚ü©,
              ‚ü®i, ‚ü®_, by exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg)
            (0 : A‚Å∞_ f_deg)
            : begin
              split_ifs with H,
              erw H,
              simp only [subtype.ext_iff_val, localization.mk_zero],
              refl,
            end,
    erw this,
    split_ifs with H,
    { apply ha, },
    { exact submodule.zero_mem _, },
end

def carrier.as_homogeneous_ideal (hm : 0 < m) (q : Spec.T (A‚Å∞_ f_deg)) : homogeneous_ideal ùíú :=
‚ü®carrier.as_ideal hm q, carrier.as_ideal.homogeneous hm q‚ü©

lemma carrier.relevant (hm : 0 < m) (q : Spec.T (A‚Å∞_ f_deg)) :
  ¬¨ homogeneous_ideal.irrelevant ùíú ‚â§ carrier.as_homogeneous_ideal hm q :=
begin
  intro rid,
  have mem1 : f ‚àâ carrier.as_ideal hm q,
  { intro rid2,
    specialize rid2 m,
    apply q.is_prime.1,
    rw ideal.eq_top_iff_one,
    convert rid2,
    rw [subtype.ext_iff_val, degree_zero_part.one_val],
    dsimp only,
    symmetry,
    rw [graded_algebra.proj_apply, direct_sum.decompose_of_mem_same],
    convert localization.mk_self _,
    refl,
    exact f_deg },
  apply mem1,
  have mem2 : f ‚àà homogeneous_ideal.irrelevant ùíú,
  { change graded_algebra.proj ùíú 0 f = 0,
    rw [graded_algebra.proj_apply, direct_sum.decompose_of_mem_ne ùíú f_deg],
    symmetry,
    apply ne_of_lt,
    exact hm },
  apply rid mem2,
end

lemma carrier.as_ideal.prime (hm : 0 < m)
  (q : Spec.T (A‚Å∞_ f_deg)) : (carrier.as_ideal hm q).is_prime :=
begin
  apply (carrier.as_ideal.homogeneous hm q).is_prime_of_homogeneous_mem_or_mem,
  { intro rid,
    rw ideal.eq_top_iff_one at rid,
    apply q.is_prime.1,
    rw ideal.eq_top_iff_one,
    specialize rid 0,
    have eq1 : proj ùíú 0 1 = 1,
    { rw [proj_apply, decompose_of_mem_same],
      exact one_mem, },
    simp only [eq1, one_pow] at rid,
    convert rid,
    rw [subtype.ext_iff_val, degree_zero_part.one_val],
    dsimp only,
    symmetry,
    convert localization.mk_one,
    rw pow_zero, },
  { -- homogeneously prime
    rintros x y ‚ü®nx, hnx‚ü© ‚ü®ny, hny‚ü© hxy,
    contrapose hxy,
    rw not_or_distrib at hxy,
    rcases hxy with ‚ü®hx, hy‚ü©,
    change x ‚àâ carrier q at hx,
    change y ‚àâ carrier q at hy,
    change ¬¨ ‚àÄ (i : ‚Ñï),
      (‚ü®mk ((proj ùíú i x)^m) ‚ü®f^i, ‚ü®_, rfl‚ü©‚ü©,
        ‚ü®i, ‚ü®((proj ùíú i x)^m), set_like.graded_monoid.pow_mem _ (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) ‚àà q.1 at hx,
    change ¬¨ ‚àÄ (i : ‚Ñï), (‚ü®mk ((proj ùíú i y)^m) ‚ü®f^i, ‚ü®_, rfl‚ü©‚ü©,
      ‚ü®i, ‚ü®((graded_algebra.proj ùíú i y)^m), set_like.graded_monoid.pow_mem _ (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) ‚àà q.1 at hy,
    rw not_forall at hx hy,
    obtain ‚ü®ix, hix‚ü© := hx,
    obtain ‚ü®iy, hiy‚ü© := hy,
    intro rid,
    change ‚àÄ (i : ‚Ñï), (‚ü®mk ((proj ùíú i (x*y))^m) ‚ü®f^i, ‚ü®_, rfl‚ü©‚ü©,
      ‚ü®i, ‚ü®((proj ùíú i (x*y))^m), set_like.graded_monoid.pow_mem _ (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) ‚àà q.1 at rid,
    specialize rid (nx + ny),
    have eqx : nx = ix,
    { by_contra rid,
      apply hix,
      convert submodule.zero_mem _,
      rw [proj_apply, decompose_of_mem_ne ùíú hnx rid, zero_pow hm, localization.mk_zero], },
    have eqy : ny = iy,
    { by_contra rid,
      apply hiy,
      convert submodule.zero_mem _,
      rw [proj_apply, decompose_of_mem_ne ùíú hny rid, zero_pow hm, localization.mk_zero], },
    rw ‚Üêeqx at hix,
    rw ‚Üêeqy at hiy,

    have eqx2 : (‚ü®mk ((proj ùíú nx) x ^ m) ‚ü®f ^ nx, ‚ü®_, rfl‚ü©‚ü©,
      ‚ü®nx, ‚ü®(proj ùíú nx) x ^ m, by exact set_like.graded_monoid.pow_mem m (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) =
    ‚ü®mk (x^m) ‚ü®f^nx, ‚ü®_, rfl‚ü©‚ü©, ‚ü®nx, ‚ü®_, by exact set_like.graded_monoid.pow_mem m hnx‚ü©, rfl‚ü©‚ü©,
    { rw subtype.ext_iff_val,
      dsimp only,
      congr' 1,
      rw [proj_apply, decompose_of_mem_same],
      exact hnx },
    rw eqx2 at hix,

    have eqy2 : (‚ü®mk ((proj ùíú ny) y ^ m) ‚ü®f ^ ny, ‚ü®_, rfl‚ü©‚ü©, ‚ü®ny, ‚ü®_, by exact set_like.graded_monoid.pow_mem _ (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) =
      (‚ü®mk (y^m) ‚ü®f^ny, ‚ü®_, rfl‚ü©‚ü©, ‚ü®ny, ‚ü®_, by exact set_like.graded_monoid.pow_mem _ hny‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg),
    { rw subtype.ext_iff_val,
      dsimp only,
      congr' 1,
      rw [proj_apply, decompose_of_mem_same],
      exact hny },
    erw eqy2 at hiy,

    rw show (‚ü®mk ((proj ùíú (nx+ny)) (x*y) ^ m)
        ‚ü®f^(nx+ny), ‚ü®_, rfl‚ü©‚ü©, ‚ü®nx + ny, ‚ü®_, by exact set_like.graded_monoid.pow_mem m (submodule.coe_mem _)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) =
      ‚ü®mk ((x*y)^m) ‚ü®f^(nx+ny), ‚ü®_, rfl‚ü©‚ü©, ‚ü®nx + ny, ‚ü®_, set_like.graded_monoid.pow_mem _ (mul_mem hnx hny)‚ü©, rfl‚ü©‚ü©,
    { rw subtype.ext_iff_val,
      dsimp only,
      congr' 1,
      rw [graded_algebra.proj_apply, direct_sum.decompose_of_mem_same],
      apply set_like.graded_monoid.mul_mem hnx hny, } at rid,

    rw show (‚ü®mk ((x*y)^m) ‚ü®f^(nx+ny), ‚ü®_, rfl‚ü©‚ü©, ‚ü®nx + ny, ‚ü®_, set_like.graded_monoid.pow_mem _ (mul_mem hnx hny)‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg)
    = (‚ü®mk (x^m) ‚ü®f^nx, ‚ü®_, rfl‚ü©‚ü©, ‚ü®nx, ‚ü®_, set_like.graded_monoid.pow_mem _ hnx‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg) *
      (‚ü®mk (y^m) ‚ü®f^ny, ‚ü®_, rfl‚ü©‚ü©, ‚ü®ny, ‚ü®_, set_like.graded_monoid.pow_mem _ hny‚ü©, rfl‚ü©‚ü© : A‚Å∞_ f_deg),
    { rw [subtype.ext_iff_val, degree_zero_part.mul_val],
      dsimp only,
      rw [localization.mk_mul],
      congr',
      rw mul_pow,
      rw pow_add, } at rid,

    rcases ideal.is_prime.mem_or_mem (q.is_prime) rid with L | R,
    { apply hix, exact L },
    { apply hiy, exact R }, },
end

variable (f_deg)
def to_fun (hm : 0 < m) :
  (Spec.T (A‚Å∞_ f_deg)) ‚Üí (Proj.T| (pbo f)) := Œª q,
‚ü®‚ü®carrier.as_homogeneous_ideal hm q,
  carrier.as_ideal.prime hm q,
  carrier.relevant hm q‚ü©, begin
    erw projective_spectrum.mem_basic_open,
    intro rid,
    change ‚àÄ i : ‚Ñï, _ ‚àà q.1 at rid,
    specialize rid m,
    apply q.is_prime.1,
    rw ideal.eq_top_iff_one,
    convert rid,
    symmetry,
    rw [subtype.ext_iff_val, degree_zero_part.one_val],
    dsimp only,
    rw [graded_algebra.proj_apply, direct_sum.decompose_of_mem_same ùíú f_deg],
    convert localization.mk_self _,
    refl,
  end‚ü©

end from_Spec

end Proj_iso_Spec_Top_component

end algebraic_geometry
