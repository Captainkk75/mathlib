/-
Copyright (c) 2021 Eric Wieser. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Eric Wieser
-/
import linear_algebra.quadratic_form.basic

/-! # Quadratic form on product and pi types

## Main definitions

* `quadratic_form.prod Q₁ Q₂`: the quadratic form constructed elementwise on a product
* `quadratic_form.pi Q`: the quadratic form constructed elementwise on a pi type

## Main results

* `quadratic_form.equivalent.prod`, `quadratic_form.equivalent.pi`: quadratic forms are equivalent
  if their components are equivalent
* `quadratic_form.pos_def.prod`, `quadratic_form.pos_def.prod`: quadratic forms are positive-
  definite if their components are positive definite.

-/

universes u v w
variables {ι : Type*} {R : Type*} {M₁ M₂ N₁ N₂ : Type*} {Mᵢ Nᵢ : ι → Type*}
variables [ring R]
variables [add_comm_group M₁] [add_comm_group M₂] [add_comm_group N₁] [add_comm_group N₂]
variables [module R M₁] [module R M₂] [module R N₁] [module R N₂]
variables [Π i, add_comm_group (Mᵢ i)] [Π i, add_comm_group (Nᵢ i)]
variables [Π i, module R (Mᵢ i)] [Π i, module R (Nᵢ i)]

namespace quadratic_form

/-- Construct a quadratic form on a product of two modules from the quadratic form on each module.
-/
@[simps]
def prod (Q₁ : quadratic_form R M₁) (Q₂ : quadratic_form R M₂) : quadratic_form R (M₁ × M₂) :=
Q₁.comp (linear_map.fst _ _ _) + Q₂.comp (linear_map.snd _ _ _)

/-- An isometry between quadratic forms generated by `quadratic_form.prod` can be constructed
from a pair of isometries between the left and right parts. -/
@[simps to_linear_equiv]
def isometry.prod {Q₁ : quadratic_form R M₁} {Q₂ : quadratic_form R M₂}
  {Q₁' : quadratic_form R N₁} {Q₂' : quadratic_form R N₂}
  (e₁ : Q₁.isometry Q₁') (e₂ : Q₂.isometry Q₂') : (Q₁.prod Q₂).isometry (Q₁'.prod Q₂'):=
{ map_app' := λ x, congr_arg2 (+) (e₁.map_app x.1) (e₂.map_app x.2),
  to_linear_equiv := linear_equiv.prod e₁.to_linear_equiv e₂.to_linear_equiv}

lemma equivalent.prod {Q₁ : quadratic_form R M₁} {Q₂ : quadratic_form R M₂}
  {Q₁' : quadratic_form R N₁} {Q₂' : quadratic_form R N₂}
  (e₁ : Q₁.equivalent Q₁') (e₂ : Q₂.equivalent Q₂') : (Q₁.prod Q₂).equivalent (Q₁'.prod Q₂'):=
nonempty.map2 isometry.prod e₁ e₂

example {R} [ordered_ring R] (r₁ r₂ : R) : r₁ + r₂ = 0 → 0 ≤ r₁ → 0 ≤ r₂ → r₁ = 0 ∧ r₂ = 0 :=
begin
  intros h₁₂ h₁ h₂,
  refine (add_eq_zero_iff' h₁ h₂).mp h₁₂
end

lemma pos_def.prod {R} [ordered_ring R] [module R M₁] [module R M₂]
  {Q₁ : quadratic_form R M₁} {Q₂ : quadratic_form R M₂}
  (h₁ : Q₁.pos_def) (h₂ : Q₂.pos_def) : (Q₁.prod Q₂).pos_def :=
begin
  apply pos_def_of_nonneg,
  { intro x,
    exact add_nonneg (h₁.nonneg _) (h₂.nonneg _), },
  { rintro ⟨x₁, x₂⟩ (hx : Q₁ x₁ + Q₂ x₂ = 0),
    rw [add_eq_zero_iff' (h₁.nonneg x₁) (h₂.nonneg x₂), h₁.eq_zero_iff, h₂.eq_zero_iff] at hx,
    rwa [prod.mk_eq_zero], }
end

open_locale big_operators

/-- Construct a quadratic form on a family of modules from the quadratic form on each module. -/
def pi [fintype ι] (Q : Π i, quadratic_form R (Mᵢ i)) : quadratic_form R (Π i, Mᵢ i) :=
∑ i, (Q i).comp (linear_map.proj i : _ →ₗ[R] Mᵢ i)

/-- An isometry between quadratic forms generated by `quadratic_form.prod` can be constructed
from a pair of isometries between the left and right parts. -/
@[simps to_linear_equiv]
def isometry.pi [fintype ι] {Q : Π i, quadratic_form R (Mᵢ i)} {Q' : Π i, quadratic_form R (Nᵢ i)}
  (e : Π i, (Q i).isometry (Q' i)) : (pi Q).isometry (pi Q') :=
{ map_app' := λ x, begin
    simp only [pi, sum_apply, comp_apply, linear_map.proj_apply, linear_equiv.Pi_congr_right_apply,
      linear_equiv.to_fun_eq_coe],
    congr' 1 with i,
    exact (e i).map_app _,
  end,
  to_linear_equiv := linear_equiv.Pi_congr_right (λ i, (e i).to_linear_equiv)}

lemma equivalent.pi [fintype ι] {Q : Π i, quadratic_form R (Mᵢ i)}
  {Q' : Π i, quadratic_form R (Nᵢ i)} (e : ∀ i, (Q i).equivalent (Q' i)) :
  (pi Q).equivalent (pi Q') :=
⟨isometry.pi (λ i, classical.choice (e i))⟩

lemma pos_def.pi [fintype ι] {R} [ordered_ring R] [Π i, module R (Mᵢ i)]
  {Q : Π i, quadratic_form R (Mᵢ i)}
  (h : ∀ i, (Q i).pos_def) : (pi Q).pos_def :=
begin
  apply pos_def_of_nonneg,
  { intro x,
    rw [pi, sum_apply],
    apply finset.sum_nonneg (λ i hi, ((h i).nonneg (x i) : _)), },
  { intros x hx,
    simp_rw [pi, sum_apply, comp_apply, linear_map.proj_apply] at hx,
    rw finset.sum_eq_zero_iff_of_nonneg (λ i hi, _) at hx,
    { ext i,
      have := hx i (finset.mem_univ _),
      rw (h i).eq_zero_iff at this,
      exact this, },
    exact (h i).nonneg _, }
end

end quadratic_form
