/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import topology.instances.irrational
import topology.algebra.order.archimedean
import topology.paracompact
import topology.metric_space.metrizable
import topology.metric_space.emetric_paracompact
import data.set.intervals.monotone

/-!
# Sorgenfrey line

In this file we define `sorgenfrey_line` (notation: `‚Ñù‚Çó`) to be the Sorgenfrey line. It is the real
line with the topology space structure generated by half-open intervals `set.Ico a b`.

We prove that this line is a normal space but its product with itself is not a normal space. In
particular, this implies that the topology on `‚Ñù‚Çó` is neither metrizable, nor second countable.

## Notations

- `‚Ñù‚Çó`: Sorgenfrey line.

## TODO

Prove that the Sorgenfrey line is a paracompact space.

-/

open set filter topological_space
open_locale topological_space filter
noncomputable theory

/-- The Sorgenfrey line. It is the real line with the topology space structure generated by
half-open intervals `set.Ico a b`. -/
@[derive [conditionally_complete_linear_order, linear_ordered_field, archimedean]]
def sorgenfrey_line : Type := ‚Ñù

notation `‚Ñù‚Çó` := sorgenfrey_line

namespace sorgenfrey_line

/-- Ring homomorphism between the Sorgenfrey line and the standard real line. -/
def to_real : ‚Ñù‚Çó ‚âÉ+* ‚Ñù := ring_equiv.refl ‚Ñù

instance : topological_space ‚Ñù‚Çó :=
topological_space.generate_from {s : set ‚Ñù‚Çó | ‚àÉ a b : ‚Ñù‚Çó, Ico a b = s}

lemma is_open_Ico (a b : ‚Ñù‚Çó) : is_open (Ico a b) :=
topological_space.generate_open.basic _ ‚ü®a, b, rfl‚ü©

lemma is_open_Ici (a : ‚Ñù‚Çó) : is_open (Ici a) :=
Union_Ico_right a ‚ñ∏ is_open_Union (is_open_Ico a)

lemma nhds_basis_Ico (a : ‚Ñù‚Çó) : (ùìù a).has_basis ((<) a) (Ico a) :=
begin
  rw topological_space.nhds_generate_from,
  haveI : nonempty {x // x ‚â§ a} := set.nonempty_Iic_subtype,
  have : (‚®Ö (x : {i // i ‚â§ a}), ùìü (Ici ‚Üëx)) = ùìü (Ici a),
  { refine (is_least.is_glb _).infi_eq,
    exact ‚ü®‚ü®‚ü®a, le_rfl‚ü©, rfl‚ü©, forall_range_iff.2 $
      Œª b, principal_mono.2 $ Ici_subset_Ici.2 b.2‚ü©, },
  simp only [mem_set_of_eq, infi_and, infi_exists, @infi_comm _ (_ ‚àà _),
    @infi_comm _ (set ‚Ñù‚Çó), infi_infi_eq_right],
  simp_rw [@infi_comm _ ‚Ñù‚Çó (_ ‚â§ _), infi_subtype', ‚Üê Ici_inter_Iio, ‚Üê inf_principal, ‚Üê inf_infi,
    ‚Üê infi_inf, this, infi_subtype],
  suffices : (‚®Ö x ‚àà Ioi a, ùìü (Iio x)).has_basis ((<) a) Iio, from this.principal_inf _,
  refine has_basis_binfi_principal _ nonempty_Ioi,
  exact directed_on_iff_directed.2 (directed_of_inf $ Œª x y hxy, Iio_subset_Iio hxy),
end

lemma nhds_basis_Ico_rat (a : ‚Ñù‚Çó) :
  (ùìù a).has_countable_basis (Œª r : ‚Ñö, a < r) (Œª r, Ico a r) :=
begin
  refine ‚ü®(nhds_basis_Ico a).to_has_basis (Œª b hb, _) (Œª r hr, ‚ü®_, hr, subset.rfl‚ü©),
    countable_encodable _‚ü©,
  rcases exists_rat_btwn hb with ‚ü®r, har, hrb‚ü©,
  exact ‚ü®r, har, Ico_subset_Ico_right hrb.le‚ü©
end

lemma nhds_basis_Ico_inv_nat_pos (a : ‚Ñù‚Çó) :
  (ùìù a).has_countable_basis (Œª n : ‚Ñï, 0 < n) (Œª n, Ico a (a + 1 / n)) :=
begin
  refine ‚ü®(nhds_basis_Ico a).to_has_basis (Œª b hb, _)
    (Œª n hn, ‚ü®_, lt_add_of_pos_right _ (one_div_pos.2 $ nat.cast_pos.2 hn), subset.rfl‚ü©),
    countable_encodable _‚ü©,
  rcases exists_nat_one_div_lt (sub_pos.2 hb) with ‚ü®k, hk‚ü©,
  rw [‚Üê nat.cast_add_one] at hk,
  exact ‚ü®k + 1, k.succ_pos, Ico_subset_Ico_right (le_sub_iff_add_le'.1 hk.le)‚ü©
end

lemma is_open_iff {s : set ‚Ñù‚Çó} : is_open s ‚Üî ‚àÄ x ‚àà s, ‚àÉ y > x, Ico x y ‚äÜ s :=
is_open_iff_mem_nhds.trans $ forall‚ÇÇ_congr $ Œª x hx, (nhds_basis_Ico x).mem_iff

lemma is_closed_iff {s : set ‚Ñù‚Çó} : is_closed s ‚Üî ‚àÄ x ‚àâ s, ‚àÉ y > x, disjoint (Ico x y) s :=
by simp only [‚Üê is_open_compl_iff, is_open_iff, mem_compl_iff, subset_compl_iff_disjoint,
  disjoint_iff_inter_eq_empty]

lemma exists_Ico_disjoint_closed {a : ‚Ñù‚Çó} {s : set ‚Ñù‚Çó} (hs : is_closed s) (ha : a ‚àâ s) :
  ‚àÉ b > a, disjoint (Ico a b) s :=
is_closed_iff.1 hs a ha

@[simp] lemma map_to_real_nhds (a : ‚Ñù‚Çó) : map to_real (ùìù a) = ùìù[‚â•] (to_real a) :=
begin
  refine ((nhds_basis_Ico a).map _).eq_of_same_basis _,
  simpa only [to_real.image_eq_preimage] using nhds_within_Ici_basis_Ico (to_real a)
end

lemma nhds_eq_map (a : ‚Ñù‚Çó) : ùìù a = map to_real.symm (ùìù[‚â•] a.to_real) :=
by simp_rw [‚Üê map_to_real_nhds, map_map, (‚àò), to_real.symm_apply_apply, map_id']

lemma nhds_eq_comap (a : ‚Ñù‚Çó) : ùìù a = comap to_real (ùìù[‚â•] a.to_real) :=
by rw [‚Üê map_to_real_nhds, comap_map to_real.injective]

@[continuity] lemma continuous_to_real : continuous to_real :=
continuous_iff_continuous_at.2 $ Œª x,
  by { rw [continuous_at, tendsto, map_to_real_nhds], exact inf_le_left }

instance : order_closed_topology ‚Ñù‚Çó :=
‚ü®is_closed_le_prod.preimage (continuous_to_real.prod_map continuous_to_real)‚ü©

instance : has_continuous_add ‚Ñù‚Çó :=
begin
  refine ‚ü®continuous_iff_continuous_at.2 _‚ü©,
  rintro ‚ü®x, y‚ü©,
  simp only [continuous_at, nhds_prod_eq, nhds_eq_map, nhds_eq_comap (x + y), prod_map_map_eq,
    tendsto_comap_iff, tendsto_map'_iff, (‚àò), ‚Üê nhds_within_prod_eq],
  exact (continuous_add.tendsto _).inf (maps_to.tendsto $ Œª x hx, add_le_add hx.1 hx.2)
end

lemma is_clopen_Ici (a : ‚Ñù‚Çó) : is_clopen (Ici a) := ‚ü®is_open_Ici a, is_closed_Ici‚ü©

lemma is_clopen_Iio (a : ‚Ñù‚Çó) : is_clopen (Iio a) :=
by simpa only [compl_Ici] using (is_clopen_Ici a).compl

lemma is_clopen_Ico (a b : ‚Ñù‚Çó) : is_clopen (Ico a b) :=
(is_clopen_Ici a).inter (is_clopen_Iio b)

instance : totally_disconnected_space ‚Ñù‚Çó :=
begin
  refine ‚ü®Œª s hs' hs x hx y hy, _‚ü©, clear hs',
  by_contra' hne : x ‚â† y,
  wlog hlt : x < y := hne.lt_or_lt using [x y, y x],
  exact hlt.not_le (hs.subset_clopen (is_clopen_Ici y) ‚ü®y, hy, le_rfl‚ü© hx)
end

instance : first_countable_topology ‚Ñù‚Çó := ‚ü®Œª x, (nhds_basis_Ico_rat x).is_countably_generated‚ü©

instance : normal_space ‚Ñù‚Çó :=
begin
  refine ‚ü®Œª s t hs ht hd, _‚ü©,
  choose! X hX hXd using Œª x (hx : x ‚àà s), exists_Ico_disjoint_closed ht (disjoint_left.1 hd hx),
  choose! Y hY hYd using Œª y (hy : y ‚àà t), exists_Ico_disjoint_closed hs (disjoint_right.1 hd hy),
  refine ‚ü®‚ãÉ x ‚àà s, Ico x (X x), ‚ãÉ y ‚àà t, Ico y (Y y), is_open_bUnion $ Œª _ _, is_open_Ico _ _,
    is_open_bUnion $ Œª _ _, is_open_Ico _ _, _, _, _‚ü©,
  { exact Œª x hx, mem_Union‚ÇÇ.2 ‚ü®x, hx, left_mem_Ico.2 $ hX x hx‚ü© },
  { exact Œª y hy, mem_Union‚ÇÇ.2 ‚ü®y, hy, left_mem_Ico.2 $ hY y hy‚ü© },
  { simp only [disjoint_Union_left, disjoint_Union_right, Ico_disjoint_Ico],
    intros y hy x hx,
    clear hs ht hd hX hY,
    cases le_total x y with hle hle,
    { calc min (X x) (Y y) ‚â§ X x : min_le_left _ _
      ... ‚â§ y : not_lt.1 (Œª hyx, hXd x hx ‚ü®‚ü®hle, hyx‚ü©, hy‚ü©)
      ... ‚â§ max x y : le_max_right _ _ },
    { calc min (X x) (Y y) ‚â§ Y y : min_le_right _ _
      ... ‚â§ x : not_lt.1 $ Œª hxy, hYd y hy ‚ü®‚ü®hle, hxy‚ü©, hx‚ü©
      ... ‚â§ max x y : le_max_left _ _ } }
end

lemma dense_range_coe_rat : dense_range (coe : ‚Ñö ‚Üí ‚Ñù‚Çó) :=
begin
  refine dense_iff_inter_open.2 _,
  rintro U Uo ‚ü®x, hx‚ü©,
  rcases is_open_iff.1 Uo _ hx with ‚ü®y, hxy, hU‚ü©,
  rcases exists_rat_btwn hxy with ‚ü®z, hxz, hzy‚ü©,
  exact ‚ü®z, hU ‚ü®hxz.le, hzy‚ü©, mem_range_self _‚ü©
end

instance : separable_space ‚Ñù‚Çó := ‚ü®‚ü®_, countable_range _, dense_range_coe_rat‚ü©‚ü©

lemma is_closed_antidiagonal (c : ‚Ñù‚Çó) : is_closed {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = c} :=
is_closed_singleton.preimage continuous_add

lemma is_clopen_Ici_prod (x : ‚Ñù‚Çó √ó ‚Ñù‚Çó) : is_clopen (Ici x) :=
(Ici_prod_eq x).symm ‚ñ∏ (is_clopen_Ici _).prod (is_clopen_Ici _)

lemma is_closed_of_subset_antidiagonal {s : set (‚Ñù‚Çó √ó ‚Ñù‚Çó)} {c : ‚Ñù‚Çó}
  (hs : ‚àÄ x ‚àà s, (x : _).1 + x.2 = c) : is_closed s :=
begin
  rw [‚Üê closure_subset_iff_is_closed],
  rintro ‚ü®x, y‚ü© H,
  obtain rfl : x + y = c,
  { change (x, y) ‚àà {p : ‚Ñù‚Çó √ó ‚Ñù‚Çó | p.1 + p.2 = c},
    exact closure_minimal (hs : s ‚äÜ {x | x.1 + x.2 = c}) (is_closed_antidiagonal c) H },
  rcases mem_closure_iff.1 H (Ici (x, y)) (is_clopen_Ici_prod _).1 le_rfl
    with ‚ü®‚ü®x', y'‚ü©, ‚ü®hx : x ‚â§ x', hy : y ‚â§ y'‚ü©, H‚ü©,
  convert H,
  { refine hx.antisymm _,
    rwa [‚Üê add_le_add_iff_right, hs _ H, add_le_add_iff_left] },
  { refine hy.antisymm _,
    rwa [‚Üê add_le_add_iff_left, hs _ H, add_le_add_iff_right] }
end

lemma nhds_prod_basis_inv_nat_pos (x : ‚Ñù‚Çó √ó ‚Ñù‚Çó) :
  (ùìù x).has_basis (Œª n : ‚Ñï, 0 < n) (Œª n, Ico x.1 (x.1 + 1 / n) √óÀ¢ Ico x.2 (x.2 + 1 / n)) :=
begin
  cases x with x y,
  simp only [nhds_prod_eq],
  refine (nhds_basis_Ico_inv_nat_pos x).to_has_basis.prod'
    (nhds_basis_Ico_inv_nat_pos y).to_has_basis (Œª i j hi hj, _),
  refine ‚ü®max i j, lt_max_iff.2 $ or.inl hi, Ico_subset_Ico_right _, Ico_subset_Ico_right _‚ü©;
    refine add_le_add_left (one_div_le_one_div_of_le (nat.cast_pos.2 ‚Äπ_‚Ä∫) $ nat.mono_cast _) _,
  exacts [le_max_left _ _, le_max_right _ _],
end

lemma not_normal_space_prod : ¬¨normal_space (‚Ñù‚Çó √ó ‚Ñù‚Çó) :=
begin
  have h‚ÇÄ : ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí (0 : ‚Ñù) < 1 / n, from Œª n hn, one_div_pos.2 (nat.cast_pos.2 hn),
  introI,
  set S := {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß ‚àÉ r : ‚Ñö, ‚Üër = x.1},
  set T := {x : ‚Ñù‚Çó √ó ‚Ñù‚Çó | x.1 + x.2 = 0 ‚àß irrational x.1.to_real},
  have hSc : is_closed S, from is_closed_of_subset_antidiagonal (Œª x hx, hx.1),
  have hTc : is_closed T, from is_closed_of_subset_antidiagonal (Œª x hx, hx.1),
  have hd : disjoint S T,
  { rintro ‚ü®x, y‚ü© ‚ü®‚ü®-, r, rfl : _ = x‚ü©, -, hr‚ü©,
    exact r.not_irrational hr },
  rcases normal_separation hSc hTc hd with ‚ü®U, V, Uo, Vo, SU, TV, UV‚ü©,
  have : ‚àÄ x : ‚Ñù‚Çó, irrational x.to_real ‚Üí
    ‚àÉ (k : ‚Ñï) (hk : 0 < k), Ico x (x + 1 / k) √óÀ¢ Ico (-x) (-x + 1 / k) ‚äÜ V,
  { intros x hx,
    have hV : V ‚àà ùìù (x, -x), from Vo.mem_nhds (@TV (x, -x) ‚ü®add_neg_self x, hx‚ü©),
    exact (nhds_prod_basis_inv_nat_pos _).mem_iff.1 hV },
  choose! k hk‚ÇÄ hkV,
  set C : ‚Ñï ‚Üí set ‚Ñù := Œª n, closure {x | irrational x ‚àß k (to_real.symm x) = n},
  have H : {x : ‚Ñù | irrational x} ‚äÜ ‚ãÉ n ‚àà {n : ‚Ñï | 0 < n}, C n,
    from Œª x hx, mem_bUnion (hk‚ÇÄ (to_real.symm x) hx) (subset_closure ‚ü®hx, rfl‚ü©),
  have Hd : dense (‚ãÉ n ‚àà {n : ‚Ñï | 0 < n}, interior (C n)),
    from is_GŒ¥_irrational.dense_bUnion_interior_of_closed dense_irrational
      (countable_encodable {n : ‚Ñï | 0 < n}) (Œª _ _, is_closed_closure) H,
  obtain ‚ü®N, hN‚ÇÄ, hN‚ü© : ‚àÉ n : ‚Ñï, 0 < n ‚àß (interior $ C n).nonempty,
    by simpa only [nonempty_Union, exists_prop] using Hd.nonempty,
  rcases rat.dense_range_cast.exists_mem_open is_open_interior hN with ‚ü®r, hr‚ü©,
  have hrU : ((r, -r) : ‚Ñù‚Çó √ó ‚Ñù‚Çó) ‚àà U, from @SU (r, -r) ‚ü®add_neg_self _, r, rfl‚ü©,
  rcases (nhds_prod_basis_inv_nat_pos _).mem_iff.1 (Uo.mem_nhds hrU) with ‚ü®n, hn‚ÇÄ, hn‚ü©,
  dsimp only at hn,
  obtain ‚ü®Œµ, Œµ‚ÇÄ, hŒµn, hŒµN‚ü© : ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß Œµ ‚â§ 1 / n ‚àß Œµ ‚â§ 1 / N,
    from ‚ü®min (1 / n) (1 / N), lt_min (h‚ÇÄ hn‚ÇÄ) (h‚ÇÄ hN‚ÇÄ), min_le_left _ _, min_le_right _ _‚ü©,
  obtain ‚ü®x, hxŒµ, hx_irr, rfl‚ü© :
    ‚àÉ x : ‚Ñù, x ‚àà Ioo (r : ‚Ñù) (r + Œµ) ‚àß irrational x ‚àß k (to_real.symm x) = N,
  { have : (r : ‚Ñù) ‚àà closure (Ioo (r : ‚Ñù) (r + Œµ)),
    { rw [closure_Ioo]; simp [Œµ‚ÇÄ.ne', Œµ‚ÇÄ.le] },
    rcases mem_closure_iff_nhds.1 this _ (mem_interior_iff_mem_nhds.1 hr) with ‚ü®x', hx', hx'Œµ‚ü©,
    exact mem_closure_iff.1 hx' _ is_open_Ioo hx'Œµ },
  refine @UV (to_real.symm x, -r) ‚ü®hn ‚ü®_, _‚ü©, hkV x hx_irr ‚ü®_, _‚ü©‚ü©,
  { exact ‚ü®hxŒµ.1.le, hxŒµ.2.trans_le $ add_le_add_left hŒµn _‚ü© },
  { exact left_mem_Ico.2 (lt_add_of_pos_right _ (h‚ÇÄ hn‚ÇÄ)) },
  { exact left_mem_Ico.2 (lt_add_of_pos_right _ (h‚ÇÄ $ hk‚ÇÄ x hx_irr)) },
  { refine ‚ü®neg_le_neg hxŒµ.1.le, _‚ü©,
    simp only [add_neg_lt_iff_le_add', lt_neg_add_iff_add_lt],
    exact hxŒµ.2.trans_le (add_le_add_left hŒµN _) }
end

lemma not_metrizable_space : ¬¨metrizable_space ‚Ñù‚Çó :=
begin
  introI,
  letI := metrizable_space_metric ‚Ñù‚Çó,
  exact not_normal_space_prod infer_instance
end

lemma not_second_countable_topology : ¬¨second_countable_topology ‚Ñù‚Çó :=
by { introI, exact not_metrizable_space (metrizable_space_of_regular_second_countable _) }

end sorgenfrey_line
