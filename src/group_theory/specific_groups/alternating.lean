/-
Copyright (c) 2021 Aaron Anderson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson
-/

import group_theory.perm.fin

/-!
# Alternating Groups

The alternating group on a finite type `α` is the subgroup of the permutation group `perm α`
consisting of the even permutations.

## Main definitions

* `alternating_group α` is the alternating group on `α`, defined as a `subgroup (perm α)`.

## Main results
* `two_mul_card_alternating_group` shows that the alternating group is half as large as
  the permutation group it is a subgroup of.

* `closure_three_cycles_eq_alternating` shows that the alternating group is
  generated by three-cycles.

## Tags
alternating group permutation


## TODO
* Show that `alternating_group α` is simple if and only if `fintype.card α ≠ 4`.

-/

@[simp] lemma set.compl_to_finset {α : Type*} [fintype α] [decidable_eq α] (s : set α)
  [fintype s] [fintype (sᶜ : set α)] :
  s.to_finsetᶜ = sᶜ.to_finset :=
by { ext, simp }

lemma fintype.card_compl {α : Type*} [fintype α] (s : set α) [fintype s] [fintype (sᶜ : set α)] :
  fintype.card (sᶜ : set α) = fintype.card α - fintype.card s :=
begin
  classical,
  convert finset.card_compl s.to_finset;
  simp
end

open equiv equiv.perm subgroup fintype
variables (α : Type*) [fintype α] [decidable_eq α]

/-- The alternating group on a finite type, realized as a subgroup of `equiv.perm`.
  For $A_n$, use `alternating_group (fin n)`. -/
@[derive fintype] def alternating_group : subgroup (perm α) :=
sign.ker

instance [subsingleton α] : unique (alternating_group α) :=
⟨⟨1⟩, λ ⟨p, hp⟩, subtype.eq (subsingleton.elim p _)⟩

variables {α}

lemma alternating_group_eq_sign_ker : alternating_group α = sign.ker := rfl

namespace equiv.perm

@[simp]
lemma mem_alternating_group {f : perm α} :
  f ∈ alternating_group α ↔ sign f = 1 :=
sign.mem_ker

lemma prod_list_swap_mem_alternating_group_iff_even_length {l : list (perm α)}
  (hl : ∀ g ∈ l, is_swap g) :
  l.prod ∈ alternating_group α ↔ even l.length :=
begin
  rw [mem_alternating_group, sign_prod_list_swap hl, ← units.coe_eq_one, units.coe_pow,
    units.coe_neg_one, nat.neg_one_pow_eq_one_iff_even],
  dec_trivial
end

lemma is_three_cycle.mem_alternating_group {f : perm α} (h : is_three_cycle f) :
  f ∈ alternating_group α :=
mem_alternating_group.2 h.sign

lemma fin_rotate_bit1_mem_alternating_group {n : ℕ} :
  fin_rotate (bit1 n) ∈ alternating_group (fin (bit1 n)) :=
by rw [mem_alternating_group, bit1, sign_fin_rotate, pow_bit0', int.units_mul_self, one_pow]

end equiv.perm

lemma two_mul_card_alternating_group [nontrivial α] :
  2 * card (alternating_group α) = card (perm α) :=
begin
  let := (quotient_group.quotient_ker_equiv_of_surjective _ (sign_surjective α)).to_equiv,
  rw [←fintype.card_units_int, ←fintype.card_congr this],
  exact (subgroup.card_eq_card_quotient_mul_card_subgroup _).symm,
end

namespace alternating_group
open equiv.perm

instance normal : (alternating_group α).normal := sign.normal_ker

lemma is_conj_of {σ τ : alternating_group α}
  (hc : is_conj (σ : perm α) (τ : perm α))
  (hσ : fintype.card (σ : perm α).support + 2 ≤ fintype.card α) :
  is_conj σ τ :=
begin
  obtain ⟨σ, hσ⟩ := σ,
  obtain ⟨τ, hτ⟩ := τ,
  obtain ⟨π, hπ⟩ := is_conj_iff.1 hc,
  rw [subtype.coe_mk, subtype.coe_mk] at hπ,
  cases int.units_eq_one_or (sign π) with h h,
  { rw is_conj_iff,
    use ⟨π, mem_alternating_group.mpr h⟩,
    apply subtype.val_injective,
    simpa [coe_mk, coe_inv, subgroup.coe_mul, subtype.val_eq_coe] using hπ },
  { have h2 : 2 ≤ fintype.card (σ.supportᶜ : set α),
      { rw [fintype.card_compl, nat.le_sub_left_iff_add_le],
        { exact hσ },
        { exact card_subtype_le _ } },
    obtain ⟨⟨a, ha⟩, -, ⟨b, hb⟩, -, ab⟩ := finset.one_lt_card.1 h2,
    simp only [subtype.mk_eq_mk, ne.def] at ab,
    refine is_conj_iff.2 ⟨⟨π * swap a b, _⟩, subtype.val_injective _⟩,
    { rw [mem_alternating_group, monoid_hom.map_mul, h, sign_swap ab, int.units_mul_self] },
    { simp only [←hπ, coe_mk, subgroup.coe_mul, subtype.val_eq_coe],
      have hd : disjoint (swap a b) σ,
      { rw [disjoint_iff_disjoint_support, support_swap ab, set.disjoint_left],
        rintro z (rfl|rfl|_);
        rwa ←set.mem_compl_iff },
      rw [mul_assoc π _ σ, disjoint.mul_comm hd],
      simp only [mul_assoc, swap_mul_self_mul, mul_inv_rev, coe_mk, swap_inv, coe_inv] } }
end

lemma is_three_cycle_is_conj (h5 : 5 ≤ fintype.card α)
  {σ τ : alternating_group α}
  (hσ : is_three_cycle (σ : perm α)) (hτ : is_three_cycle (τ : perm α)) :
  is_conj σ τ :=
alternating_group.is_conj_of (is_conj_iff_cycle_type_eq.2 (hσ.trans hτ.symm))
  (by { rw hσ.card_support, exact h5 })

end alternating_group

namespace equiv.perm
open alternating_group

@[simp]
theorem closure_three_cycles_eq_alternating :
  closure {σ : perm α | is_three_cycle σ} = alternating_group α :=
closure_eq_of_le _ (λ σ hσ, mem_alternating_group.2 hσ.sign) $ λ σ hσ, begin
  suffices hind : ∀ (n : ℕ) (l : list (perm α)) (hl : ∀ g, g ∈ l → is_swap g)
    (hn : l.length = 2 * n), l.prod ∈ closure {σ : perm α | is_three_cycle σ},
  { obtain ⟨l, rfl, hl⟩ := trunc_swap_factors σ,
    obtain ⟨n, hn⟩ := (prod_list_swap_mem_alternating_group_iff_even_length hl).1 hσ,
    exact hind n l hl hn },
  intro n,
  induction n with n ih; intros l hl hn,
  { simp [list.length_eq_zero.1 hn, one_mem] },
  rw [nat.mul_succ] at hn,
  obtain ⟨a, l, rfl⟩ := l.exists_of_length_succ hn,
  rw [list.length_cons, nat.succ_inj'] at hn,
  obtain ⟨b, l, rfl⟩ := l.exists_of_length_succ hn,
  rw [list.prod_cons, list.prod_cons, ← mul_assoc],
  rw [list.length_cons, nat.succ_inj'] at hn,
  exact mul_mem _ (is_swap.mul_mem_closure_three_cycles (hl a (list.mem_cons_self a _))
    (hl b (list.mem_cons_of_mem a (l.mem_cons_self b))))
    (ih _ (λ g hg, hl g (list.mem_cons_of_mem _ (list.mem_cons_of_mem _ hg))) hn),
end

lemma is_three_cycle.alternating_normal_closure_eq_top (h5 : 5 ≤ fintype.card α)
  {f : perm α} (hf : is_three_cycle f) :
  normal_closure ({⟨f, hf.mem_alternating_group⟩} : set (alternating_group α)) = ⊤ :=
begin
  have hi : function.injective (alternating_group α).subtype := subtype.coe_injective,
  apply map_injective hi,
  rw [← monoid_hom.range_eq_map, subtype_range, normal_closure, monoid_hom.map_closure],
  refine (congr rfl _).trans closure_three_cycles_eq_alternating,
  ext g,
  split,
  { rintro ⟨g', hg', rfl⟩,
    simp_rw [group.mem_conjugates_of_set_iff, is_conj_iff] at hg',
    obtain ⟨⟨f', hf'⟩, ff', ⟨c, hc⟩, rfl, hc'⟩ := hg',
    simp only [subtype.val_eq_coe, subgroup.coe_subtype, coe_mk, coe_inv, subgroup.coe_mul,
      set.mem_set_of_eq],
    rw [is_three_cycle, cycle_type_conj, (subtype.mk_eq_mk.1 (set.mem_singleton_iff.1 ff')),
      hf.cycle_type] },
  { intro h,
    obtain ⟨c, rfl⟩ := is_conj_iff.1 (is_conj_iff_cycle_type_eq.2 (hf.trans h.symm)),
    refine ⟨⟨c * f * c⁻¹, h.mem_alternating_group⟩, _, rfl⟩,
    rw group.mem_conjugates_of_set_iff,
    exact ⟨⟨f, hf.mem_alternating_group⟩, set.mem_singleton _, is_three_cycle_is_conj h5 hf h⟩ }
end

end equiv.perm

namespace alternating_group
open equiv.perm

lemma normal_closure_fin_rotate_five :
  (normal_closure ({⟨fin_rotate 5, fin_rotate_bit1_mem_alternating_group⟩} :
    set (alternating_group (fin 5)))) = ⊤ :=
begin
  have h3 : is_three_cycle ((fin.cycle_range 2) * (fin_rotate 5) *
    (fin.cycle_range 2)⁻¹ * (fin_rotate 5)⁻¹) := card_support_eq_three_iff.1 dec_trivial,
  rw [eq_top_iff, ← h3.alternating_normal_closure_eq_top _],
  swap, { rw [card_fin] },
  refine normal_closure_le_normal _,
  rw [set.singleton_subset_iff, set_like.mem_coe],
  have h : (⟨fin_rotate 5, fin_rotate_bit1_mem_alternating_group⟩ :
    alternating_group (fin 5)) ∈ normal_closure _ :=
    set_like.mem_coe.1 (subset_normal_closure (set.mem_singleton _)),
  exact mul_mem _ (subgroup.normal_closure_normal.conj_mem _ h
    ⟨fin.cycle_range 2, fin.is_three_cycle_cycle_range_two.mem_alternating_group⟩) (inv_mem _ h),
end

end alternating_group
