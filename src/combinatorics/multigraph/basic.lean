/-
Copyright (c) 2021 Kyle Miller. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kyle Miller
-/
import data.fintype.basic
import data.sym2
import data.set.finite
import combinatorics.simple_graph.basic
import combinatorics.digraph.basic
/-!
# Multigraphs

This module defines multigraphs on a vertex type `V` with edges
labeled from a type `α`.  An edge is an unordered pair of vertices
along with a label -- this means that between any pair of vertices,
there can be at most one edge with a given label.

Labels give flexibility to the way multigraphs are used.  At one
extreme, you are free to require that each edge label be used exactly
once, and in this case, the label type is exactly the edge type.  At
the other extreme, `α` might be a singleton, in which case the
definition reduces graphs without multiple edges (i.e., simple graphs
but allowing loop edges).

There is a basic API for locally finite graphs (TODO and for graphs with
finitely many vertices).

The definition has some similarities to [Chou94], but (1) the "links"
are represented as a function `V → V → set α` rather than as
`set (V × α × V)`, (2) not all terms of `α` need to be used, and (3) terms of
`α` are allowed to be reused.

[Chou94] Chou, Ching-Tsun. "A formal theory of undirected graphs in Higher-Order Logic." (1994)
https://doi.org/10.1007/3-540-58450-1_40

## Main definitions

* `multigraph` is a structure for a multigraph with labeled edges.

* `incidence_set` is the `set` of vertex/label pairs for edges incident to a given vertex.

## Implementation notes

* A locally finite graph is one with instances `∀ v, fintype (G.incidence_set v)`.

-/
open finset
universes u v

/--
A multigraph on a vertex type `V` consists of sets of edges between pairs of vertices.
The edges are given by a label from `α`.

See `relabel` for a way to ensure each edge has a unique label.
-/
@[ext]
structure multigraph (V : Type u) (α : Type v):=
(labels : V → V → set α)
(symm : ∀ (u v : V), labels u v = labels v u . obviously)

namespace multigraph
variables {V W X : Type u} {α β γ : Type v} (G : multigraph V α) (G' : multigraph W β) (G'' : multigraph X γ)

lemma mem_labels_comm (u v : V) (a : α) : a ∈ G.labels u v ↔ a ∈ G.labels v u :=
by rw symm

def loopless : Prop := ∀ v a, ¬ a ∈ G.labels v v

/-- Due to the symmetry, the map on labels induces a map from `sym2 V`. -/
def labels' : sym2 V → set α :=
quotient.lift (function.uncurry G.labels) begin
  rintros _ _ (_|⟨v, w⟩),
  { refl },
  { exact G.symm v w }
end

/-- An edge is given by an unordered pair of vertices and an edge label.

We define it this way so that `mem_edge_set` is true definitionally. -/
def edge_set : set (sym2 V × α) := set_of $ function.uncurry (λ e v, v ∈ G.labels' e)

@[simp]
lemma mem_edge_set (v w : V) (a : α) : (⟦(v, w)⟧, a) ∈ G.edge_set ↔ a ∈ G.labels v w := iff.rfl

/-- An incidence at a vertex `v` is an adjacent vertex along with an edge label.  -/
def incidence_set (v : V) : set (V × α) := {p | p.2 ∈ G.labels v p.1}

@[simp]
lemma mem_incidence_set (v w : V) (a : α) : (w, a) ∈ G.incidence_set v ↔ a ∈ G.labels v w := iff.rfl

/-- Given an incidence, give the corresponding element of the edge set. -/
def edge_of_incidence {v : V} (e : G.incidence_set v) : G.edge_set :=
⟨(⟦(v, e.1.1)⟧, e.1.2), e.2⟩

def adj (v w : V) : Prop := (G.labels v w).nonempty

lemma adj_iff (v w : V) : G.adj v w ↔ ∃ a, a ∈ G.labels v w := iff.rfl

lemma adj_comm (u v : V) : G.adj u v ↔ G.adj v u :=
by { rw [adj, symm], refl }

/-- The set of vertices adjacent to the given vertex. -/
def neighbor_set (v : V) : set V := {w : V | G.adj v w}

@[simp]
lemma mem_neighbor_set (v w : V) : w ∈ G.neighbor_set v ↔ G.adj v w := iff.rfl

/-- Gives the simple graph generated by `G.adj`. -/
@[simps]
def to_simple_graph (h : G.loopless) : simple_graph V :=
{ adj := G.adj,
  symm := λ v w h, by rwa adj_comm }

/-- Relabel the multigraph so that each edge gets its own unique label.
We use its element in `G.edge_set` for this. -/
@[simps]
def relabel : multigraph V (sym2 V × α) :=
{ labels := λ v w, {p | ∃ (a : α), p = (⟦(v, w)⟧, a) ∧ a ∈ G.labels v w},
  symm := λ v w, by { ext, simp [sym2.eq_swap, mem_labels_comm] } }

/-- Choose an edge orientation for each edge in the multigraph to produce a multidigraph.

Uses the axiom of choice to select edge orientations. -/
def to_multidigraph : multidigraph V α :=
{ labels := λ v w, {a | a ∈ G.labels v w ∧ v = ⟦(v, w)⟧.out.fst} }

section finite_at

/-!
## Finiteness at a vertex

This section contains definitions and lemmas concerning vertices that
have finitely many incident edges.  We denote this condition by
`fintype (G.incidence_set v)`.
-/

variables (v : V) [fintype (G.incidence_set v)]

/-- `G.degree' v` is the number of distinct edges incident to `v`.  Loop edges are counted once. -/
def degree' : ℕ := fintype.card (G.incidence_set v)

/-- `G.degree v` is the number of edge incident to `v`, counting loop edges twice.
This is the definition for which `∑ (v : V), G.degree v = 2 * fintype.card G.edge_set`. -/
def degree [fintype (G.labels v v)] : ℕ := G.degree' v + fintype.card (G.labels v v)

instance [decidable_eq V] [decidable_pred (∈ G.incidence_set v)]: fintype (G.labels v v) :=
begin
  tactic.unfreeze_local_instances,
  let s : set (V × α) := {p : V × α | p ∈ G.incidence_set v ∧ p.1 = v},
  have f : s ≃ G.labels v v :=
  { to_fun := λ x, ⟨x.1.2, by { obtain ⟨⟨w, a⟩, h, rfl⟩ := x, simpa using h }⟩,
    inv_fun := λ x, ⟨(v, x), by simp⟩,
    left_inv := by { rintro ⟨⟨w, a⟩, h, rfl⟩, simp },
    right_inv := by { rintro ⟨a, h⟩, simp, } },
  have : s ⊆ G.incidence_set v,
  { intros p h, exact h.1, },
  haveI : fintype s := set.fintype_subset _ this,
  apply fintype.of_equiv _ f,
end

end finite_at

section maps

@[ext]
structure hom (G : multigraph V α) (G' : multigraph W β) :=
(on_verts : V → W)
(on_labels : α → β)
(mem_labels : ∀ {v w : V} {a : α}, a ∈ G.labels v w → on_labels a ∈ G'.labels (on_verts v) (on_verts w))

structure embedding (G : multigraph V α) (G' : multigraph W β) :=
(on_verts : V ↪ W)
(on_labels : α ↪ β)
(mem_labels_iff : ∀ {v w : V} {a : α}, a ∈ G.labels v w ↔ on_labels a ∈ G'.labels (on_verts v) (on_verts w))

structure iso (G : multigraph V α) (G' : multigraph W β) :=
(on_verts : V ≃ W)
(on_labels : α ≃ β)
(mem_labels_iff : ∀ {v w : V} {a : α}, a ∈ G.labels v w ↔ on_labels a ∈ G'.labels (on_verts v) (on_verts w))

infix ` →g ` :50 := hom
infix ` ↪g `:50 := embedding
infix ` ≃g ` :50 := iso

namespace hom
variables {G G'} (f : G →g G')

@[simps]
def id : G →g G :=
{ on_verts := id,
  on_labels := id,
  mem_labels := by simp }

@[simps]
def comp (f' : G' →g G'') (f : G →g G') : G →g G'' :=
{ on_verts := f'.on_verts ∘ f.on_verts,
  on_labels := f'.on_labels ∘ f.on_labels,
  mem_labels := λ v w a h, f'.mem_labels (f.mem_labels h) }

end hom

end maps

end multigraph

namespace simple_graph
variables {V : Type u} (G : simple_graph V)

/-- Give a multigraph where all edges are labeled by the same thing. -/
@[simps]
def to_multigraph : multigraph V unit :=
{ labels := λ v w, set_of (λ _, G.adj v w) }

@[simp] lemma to_multigraph.adj_iff (v w : V) : G.to_multigraph.adj v w ↔ G.adj v w :=
begin
  split,
  { rintro ⟨_, h⟩,
    exact h, },
  { intro h,
    use h, },
end

/-- Give a multigraph where each edge is labeled with a unique thing (itself). -/
def to_multigraph' : multigraph V (sym2 V) :=
{ labels := λ v w, {e | e ∈ G.edge_set ∧ e = ⟦(v, w)⟧},
  symm := λ v w, by simp [sym2.eq_swap] }

@[simp] lemma to_multigraph'.adj_iff (v w : V) : G.to_multigraph'.adj v w ↔ G.adj v w :=
begin
  split,
  { rintro ⟨e, h, rfl⟩,
    exact h, },
  { intro h,
    use [⟦(v, w)⟧, h], },
end

end simple_graph
