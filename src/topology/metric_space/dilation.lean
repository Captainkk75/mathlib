import topology.metric_space.antilipschitz
import data.fun_like.basic

noncomputable theory

open function set
open_locale topological_space ennreal nnreal

section setup

variables (Œ± : Type*) (Œ≤ : Type*) [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤]

/-- A dilation is a map uniformly scales the edistance between any two points.  -/
structure dilation (r : ‚Ñù‚â•0) :=
(to_fun : Œ± ‚Üí Œ≤)
(edist_eq' : ‚àÄ x y : Œ±, edist (to_fun x) (to_fun y) = r * edist x y)

attribute [nolint has_inhabited_instance] dilation

/--
`dilation_class F Œ± Œ≤ r` states that `F` is a type of `r`-dilations.

You should extend this typeclass when you extend `dilation`.
-/
class dilation_class (F : Type*) (Œ± Œ≤ : out_param $ Type*) (r : out_param ‚Ñù‚â•0)
  [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] extends fun_like F Œ± (Œª _, Œ≤) :=
(edist_eq'  : ‚àÄ (f : F) (x y : Œ±), edist (f x) (f y) = r * edist x y)

attribute [nolint dangerous_instance] dilation_class.to_fun_like

instance dilation.to_dilation_class (r : ‚Ñù‚â•0) :
  dilation_class (dilation Œ± Œ≤ r) Œ± Œ≤ r :=
{ coe := dilation.to_fun,
  coe_injective' := Œª f g h, by { cases f, cases g, congr' },
  edist_eq' := Œª f, dilation.edist_eq' f }

instance (r : out_param ‚Ñù‚â•0) : has_coe_to_fun (dilation Œ± Œ≤ r) (Œª _, Œ± ‚Üí Œ≤) := fun_like.has_coe_to_fun

@[simp] lemma dilation.to_fun_eq_coe (r : ‚Ñù‚â•0) {f : dilation Œ± Œ≤ r} : f.to_fun = (f : Œ± ‚Üí Œ≤) := rfl

@[ext] theorem dilation.ext (r : ‚Ñù‚â•0) {f g : dilation Œ± Œ≤ r} (h : ‚àÄ x, f x = g x) : f = g := fun_like.ext f g h

/-- Copy of a `dilation` with a new `to_fun` equal to the old one. Useful to fix definitional
equalities. -/
protected def dilation.copy (r : ‚Ñù‚â•0) (f : dilation Œ± Œ≤ r) (f' : Œ± ‚Üí Œ≤) (h : f' = ‚áëf) : dilation Œ± Œ≤ r :=
{ to_fun := f',
  edist_eq' := h.symm ‚ñ∏ f.edist_eq' }

end setup

namespace dilation
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {F : Type*} {G : Type*} (r r‚ÇÇ : ‚Ñù‚â•0)

lemma emetric_iff_metric [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} :
  (‚àÄx y, edist (f x) (f y) = r * edist x y) ‚Üî (‚àÄx y, dist (f x) (f y) = r * dist x y) :=
‚ü®assume H x y, by rw [dist_edist, dist_edist, H x y, ennreal.to_real_mul, ennreal.coe_to_real],
assume H x y,
  by rw [edist_dist, edist_dist, H x y, ennreal.of_real_mul nnreal.zero_le_coe, ennreal.of_real_coe_nnreal]‚ü©

@[simp] lemma edist_eq
  [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] [dilation_class F Œ± Œ≤ r]
  (f : F) (x y : Œ±) : edist (f x) (f y) = r * edist x y := dilation_class.edist_eq' f x y

@[simp] lemma dist_eq
  [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] [dilation_class F Œ± Œ≤ r]
  (f : F) (x y : Œ±) : dist (f x) (f y) = r * dist x y :=
by simp only [dist_edist, edist_eq, ennreal.to_real_mul, ennreal.coe_to_real]

theorem nndist_eq [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] [dilation_class F Œ± Œ≤ r]
  (f : F) (x y : Œ±) : nndist (f x) (f y) = r * nndist x y :=
begin
  apply subtype.ext _,
  simp only [coe_nndist, dist_eq, nonneg.coe_mul],
end

section pseudo_emetric_dilation

variables [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] [pseudo_emetric_space Œ≥]
variables [dilation_class F Œ± Œ≤ r] [dilation_class G Œ≤ Œ≥ r‚ÇÇ]
variables (f : F) (g : G) {x y z : Œ±}  {s : set Œ±}

lemma lipschitz : lipschitz_with r (f : Œ± ‚Üí Œ≤) :=
Œª x y, (dilation_class.edist_eq' f x y).le


-- TODO: add `instance ennreal.div_inv_comm_monoid`
-- TODO: fix `antilipschitz_with` decl header
lemma antilipschitz (hr : r ‚â† 0) : antilipschitz_with (r‚Åª¬π) (f : Œ± ‚Üí Œ≤) :=
Œª x y, begin
  -- `div_eq_mul_inv` should be `div_eq_inv_mul`
  rw [mul_comm, ‚Üê ennreal.div_le_iff_le_mul, div_eq_mul_inv, mul_comm, ennreal.coe_inv hr],
  simp only [inv_inv, edist_eq, le_refl],
  left, simp [hr],
  left, simp [hr],
end

/-- A dilation from an emetric space is injective -/
lemma injective {Œ± : Type*} [emetric_space Œ±]  [dilation_class F Œ± Œ≤ r] (f : F) (hr : r ‚â† 0) :
  injective f := (dilation.antilipschitz r f hr).injective

/-- Any map on a subsingleton is a dilation -/
def of_subsingleton [subsingleton Œ±] (f : Œ± ‚Üí Œ≤) : dilation Œ± Œ≤ r :=
{ to_fun := f,
  edist_eq' := Œª x y, by { rw subsingleton.elim x y, simp, } }

/-- The composition of similarities is a dilation -/
def comp (f : dilation Œ± Œ≤ r) (g : dilation Œ≤ Œ≥ r‚ÇÇ):
  dilation Œ± Œ≥ (r * r‚ÇÇ) :=
{ to_fun := g ‚àò f,
  edist_eq' := Œª x y, by { simp only [edist_eq, ennreal.coe_mul], ring, } }


/-- The constant function of is a dilation -/
def const {Œ± Œ≤} [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (b : Œ≤) :
  dilation Œ± Œ≤ 0 :=
{ to_fun := Œª _, b,
  edist_eq' := Œª x y, by simp }


/-- A dilation from a metric space is a uniform inducing map -/
theorem uniform_inducing (hr : r ‚â† 0) :
  uniform_inducing (f : Œ± ‚Üí Œ≤) :=
(antilipschitz r f hr).uniform_inducing (lipschitz r f).uniform_continuous

lemma tendsto_nhds_iff {Œπ : Type*} {g : Œπ ‚Üí Œ±} {a : filter Œπ} {b : Œ±} (hr : r ‚â† 0) :
  filter.tendsto g a (ùìù b) ‚Üî filter.tendsto ((f : Œ± ‚Üí Œ≤) ‚àò g) a (ùìù (f b)) :=
(uniform_inducing r f hr).inducing.tendsto_nhds_iff

/-- A dilation is continuous. -/
lemma to_continuous : continuous (f : Œ± ‚Üí Œ≤) :=
(lipschitz r f).continuous

/-- Similarities multiply the diameter by their ratio in pseudoemetric spaces. -/
lemma ediam_image (s : set Œ±) :
  emetric.diam ((f: Œ± ‚Üí Œ≤) '' s) = r * emetric.diam s :=
begin
  apply le_antisymm,
  { exact lipschitz_with.ediam_image_le (lipschitz r f) s },
  by_cases hr : r ‚â† 0,
  { rw [mul_comm, ‚Üê ennreal.le_div_iff_mul_le, div_eq_mul_inv, mul_comm, ‚Üê ennreal.coe_inv hr],
    refine antilipschitz_with.le_mul_ediam_image (antilipschitz r f hr) s,
    left, simp [hr],
    left, simp [hr], },
  rw not_not at hr,
  simp [hr],
end

lemma ediam_range :
  emetric.diam (range (f : Œ± ‚Üí Œ≤)) = r * emetric.diam (univ : set Œ±) :=
by { rw ‚Üê image_univ, exact ediam_image r f univ }

lemma maps_to_emetric_ball  (hr : r ‚â† 0) (x : Œ±) (r' : ‚Ñù‚â•0‚àû) :
  maps_to (f : Œ± ‚Üí Œ≤) (emetric.ball x r') (emetric.ball (f x) (r * r')) :=
begin
  intros y hy,
  simp only [emetric.mem_ball, edist_eq] at *,
  rwa ennreal.mul_lt_mul_left _ _,
  simp [hr],
  simp [hr],
end

lemma maps_to_emetric_closed_ball (x : Œ±) (r' : ‚Ñù‚â•0‚àû) :
  maps_to (f : Œ± ‚Üí Œ≤) (emetric.closed_ball x r') (emetric.closed_ball (f x) (r * r')) :=
begin
  by_cases hr : r ‚â† 0,
  { intros y hy,
    simp only [emetric.mem_closed_ball, edist_eq] at *,
    rwa ennreal.mul_le_mul_left _ _,
    simp [hr],
    simp [hr], },
  rw not_not at hr,
  simp [hr, maps_to],
end

lemma comp_continuous_on_iff
  {Œ≥} [topological_space Œ≥] {g : Œ≥ ‚Üí Œ±} {s : set Œ≥} (hr : r ‚â† 0) :
  continuous_on ((f : Œ± ‚Üí Œ≤) ‚àò g) s ‚Üî continuous_on g s :=
(uniform_inducing r f hr).inducing.continuous_on_iff.symm

lemma comp_continuous_iff
  {Œ≥} [topological_space Œ≥] {g : Œ≥ ‚Üí Œ±} (hr : r ‚â† 0) :
  continuous ((f : Œ± ‚Üí Œ≤) ‚àò g) ‚Üî continuous g :=
(uniform_inducing r f hr).inducing.continuous_iff.symm

end pseudo_emetric_dilation --section

section emetric_dilation
variables [emetric_space Œ±]

/-- A dilation from a metric space is a uniform embedding -/
theorem uniform_embedding [pseudo_emetric_space Œ≤] [dilation_class F Œ± Œ≤ r]
  (f : F) (hr : r ‚â† 0) : uniform_embedding f :=
(antilipschitz r f hr).uniform_embedding (lipschitz r f).uniform_continuous

/-- A dilation from a metric space is an embedding -/
theorem embedding [pseudo_emetric_space Œ≤] [dilation_class F Œ± Œ≤ r]
  (f : F) (hr : r ‚â† 0) : embedding (f : Œ± ‚Üí Œ≤) :=
(uniform_embedding r f hr).embedding

/-- A dilation from a complete emetric space is a closed embedding -/
theorem closed_embedding
  [complete_space Œ±] [emetric_space Œ≤] [dilation_class F Œ± Œ≤ r]
  (f : F) (hr : r ‚â† 0) : closed_embedding (f : Œ± ‚Üí Œ≤) :=
(antilipschitz r f hr).closed_embedding (lipschitz r f).uniform_continuous

end emetric_dilation --section

section pseudo_metric_dilation
variables [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] [dilation_class F Œ± Œ≤ r] (f : F)

/-- An isometry preserves the diameter in pseudometric spaces. -/
lemma diam_image (s : set Œ±) : metric.diam ((f : Œ± ‚Üí Œ≤) '' s) = r * metric.diam s :=
by { simp [metric.diam, metric.diam, ediam_image, ennreal.to_real_mul], }

lemma diam_range : metric.diam (range (f : Œ± ‚Üí Œ≤)) = r * metric.diam (univ : set Œ±) :=
by rw [‚Üê image_univ, diam_image]

lemma maps_to_ball (hr : r ‚â† 0) (x : Œ±) (r' : ‚Ñù) :
  maps_to (f : Œ± ‚Üí Œ≤) (metric.ball x r') (metric.ball (f x) (r * r')) :=
begin
  intros y hy,
  rw [metric.mem_ball, dist_eq],
  refine mul_lt_mul' (le_refl _) _ dist_nonneg _,
  rwa metric.mem_ball at hy,
  rwa [nnreal.coe_pos, pos_iff_ne_zero],
end

lemma maps_to_sphere (x : Œ±) (r' : ‚Ñù) :
  maps_to (f : Œ± ‚Üí Œ≤) (metric.sphere x r') (metric.sphere (f x) (r * r')) :=
begin
  intros y hy,
  rw metric.mem_sphere at hy,
  rw [metric.mem_sphere, dist_eq, hy],
end

lemma maps_to_closed_ball (x : Œ±) (r' : ‚Ñù) :
  maps_to (f : Œ± ‚Üí Œ≤) (metric.closed_ball x r') (metric.closed_ball (f x) (r * r')) :=
begin
  intros y hy,
  rw [metric.mem_closed_ball] at hy,
  rw [metric.mem_closed_ball, dist_eq],
  refine mul_le_mul (le_refl _) hy dist_nonneg nnreal.zero_le_coe,
end

end pseudo_metric_dilation -- section

end dilation
#lint
